# Sliding_window

## 1. Activate Prior Knowledge
- Какво представлява "прозорец" в контекста на обработка на данни или сигнали?
- Как бихте използвали техника, която обработва последователни части от голям набор от данни, без да зареждате всичко наведнъж?
- В кои ситуации в софтуерното инженерство или изкуствения интелект бихте искали да анализирате или оптимизирате локални сегменти от информация?

## 2. Overview
Sliding window (плъзгащ се прозорец) е техника, която позволява ефективна обработка на последователни подмножества от данни чрез "придвижване" на фиксиран размер прозорец през тях. Тя е широко използвана в алгоритми за обработка на сигнали, анализ на времеви серии, оптимизация и машинно обучение.

Тази техника се използва, за да се избегне повторното изчисляване на стойности за целия набор от данни при всяка итерация, като вместо това се обновява само информацията, която влиза и излиза от прозореца. Това я прави изключително ценна при работа с големи обеми данни или в реално време.

В контекста на AI системи и софтуерното инженерство, sliding window помага за локализиране на модели, откриване на аномалии, обработка на потоци от данни и оптимизиране на алгоритми, които трябва да работят с ограничени ресурси.

## 3. Key Concepts
- **Window Size (Размер на прозореца)** – Броят на елементите, които се разглеждат едновременно. Представете си прозорец, който гледа само част от дълга улица.
- **Sliding Step (Стъпка на плъзгане)** – Колко позиции се премества прозорецът при всяка итерация. Може да е 1 (плъзга се с един елемент) или повече.
- **Overlapping Windows (Прозорци с припокриване)** – Когато стъпката е по-малка от размера на прозореца, някои елементи се разглеждат в няколко последователни прозореца.
- **Non-overlapping Windows (Без припокриване)** – Когато стъпката е равна на размера на прозореца, прозорците са отделни и не споделят елементи.
- **Incremental Update (Инкрементално обновяване)** – Изчисляване на новите стойности, като се използва резултатът от предишния прозорец и се добавя/премахва информация само за новите елементи.

## 4. Step-by-step Learning Path
1. **Разберете основната идея на прозореца**
   - Фокус: Какво означава да разглеждаме подмножество от данни с фиксиран размер.
   - Задача: Вземете масив от числа и ръчно извадете всички подмасиви с дължина 3.
   - Въпроси: Какво е общото между тези подмасиви? Какво се променя при преминаване към следващия?

2. **Имплементирайте базов sliding window алгоритъм**
   - Фокус: Плъзгане на прозореца с фиксирана стъпка и изчисляване на сума на елементите.
   - Задача: Напишете функция, която връща сумата на всеки прозорец с размер 4 в масив.
   - Въпроси: Какво се случва с изчислената сума при преминаване към следващия прозорец? Може ли да оптимизирате изчисленията?

3. **Оптимизирайте с инкрементално обновяване**
   - Фокус: Използване на предишната сума, за да изчислите новата без пълно пресмятане.
   - Задача: Модифицирайте функцията да използва инкрементално обновяване.
   - Въпроси: Какво спестявате с тази оптимизация? В какви случаи тя е особено полезна?

4. **Приложете sliding window в реален проблем**
   - Фокус: Откриване на максимална средна стойност в поток от данни.
   - Задача: Напишете програма, която намира максималната средна стойност на прозорец с размер k.
   - Въпроси: Какви са ограниченията при избор на размер на прозореца? Как се отразява на резултатите?

5. **Изследвайте вариации и приложения**
   - Фокус: Sliding window в обработка на текст, изображения или времеви серии.
   - Задача: Използвайте sliding window за откриване на повтарящи се шаблони в текст.
   - Въпроси: Как се променя подходът при различни типове данни? Какви са предизвикателствата?

## 5. Examples

**Пример 1: Сума на всеки прозорец с размер 3**

```python
def sliding_window_sums(arr, k=3):
    n = len(arr)
    if n < k:
        return []
    window_sum = sum(arr[:k])
    sums = [window_sum]
    for i in range(k, n):
        window_sum += arr[i] - arr[i - k]
        sums.append(window_sum)
    return sums

print(sliding_window_sums([1, 2, 3, 4, 5, 6]))
# Изход: [6, 9, 12, 15]
```

**Пример 2: Максимална средна стойност на прозорец**

```python
def max_average_subarray(arr, k):
    n = len(arr)
    if n < k:
        return None
    window_sum = sum(arr[:k])
    max_sum = window_sum
    for i in range(k, n):
        window_sum += arr[i] - arr[i - k]
        if window_sum > max_sum:
            max_sum = window_sum
    return max_sum / k

print(max_average_subarray([1, 12, -5, -6, 50, 3], 4))
# Изход: 12.75
```

**Пример 3: Откриване на повтарящи се шаблони в текст**

```python
def find_repeated_substrings(s, k):
    seen = set()
    repeated = set()
    for i in range(len(s) - k + 1):
        substr = s[i:i+k]
        if substr in seen:
            repeated.add(substr)
        else:
            seen.add(substr)
    return repeated

print(find_repeated_substrings("banana", 2))
# Изход: {'an', 'na'}
```

## 6. Common Pitfalls
- **Неправилен избор на размер на прозореца** – твърде малък прозорец може да пропусне важна информация, твърде голям – да загуби локални детайли.
- **Игнориране на гранични случаи** – например, когато размерът на прозореца е по-голям от входните данни.
- **Повторно изчисляване на стойности** – липсата на инкрементална оптимизация води до излишни изчисления и по-ниска производителност.
- **Неправилно управление на индекси** – грешки при изчисляване на началото и края на прозореца могат да доведат до извънредни грешки.
- **Пренебрегване на припокриването** – когато стъпката на плъзгане е по-малка от размера на прозореца, трябва да се внимава с обработката на припокриващи се данни.

## 7. Short Retrieval Quiz
1. Какво представлява техниката sliding window?
2. Какво е значението на размера на прозореца?
3. Какво е инкрементално обновяване и защо е важно?
4. Какво се случва, ако стъпката на плъзгане е по-малка от размера на прозореца?
5. Как бихте използвали sliding window за откриване на максимална средна стойност?
6. Кои са основните грешки при имплементация на sliding window?
7. Как се различават overlapping и non-overlapping windows?

## 8. Quick Recap
- Sliding window е техника за ефективна обработка на последователни подмножества от данни.
- Размерът на прозореца и стъпката на плъзгане определят как се разглеждат данните.
- Инкременталното обновяване оптимизира изчисленията, като използва предишни резултати.
- Техниката е широко приложима в AI, обработка на сигнали и софтуерно инженерство.
- Грешките при управление на индекси и избор на параметри могат да компрометират резултатите.
- Sliding window може да се използва за откриване на шаблони, аномалии и оптимизация на алгоритми.
- Разбирането на припокриването и стъпката е ключово за правилна имплементация.

## 9. Spaced Review Plan

| Време след учене | Промпт за преглед                              |
|------------------|-----------------------------------------------|
| 1 ден            | Обяснете какво е sliding window и защо е полезен. |
| 3 дни            | Опишете разликата между overlapping и non-overlapping windows. |
| 1 седмица        | Имплементирайте функция за изчисляване на суми с sliding window. |
| 1 месец          | Дайте пример за приложение на sliding window в AI или обработка на данни. |