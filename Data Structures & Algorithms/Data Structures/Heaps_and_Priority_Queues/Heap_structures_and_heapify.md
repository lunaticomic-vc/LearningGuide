# Heap_structures_and_heapify

## 1. Activate Prior Knowledge
- Какво знаете за дървовидните структури от данни и как те се използват за организиране на информация в софтуерни системи?
- Как бихте оптимизирали намирането на максимума или минимума в голям набор от данни, например в AI алгоритъм за приоритизиране на задачи?
- Какво предполагате, че означава операцията "heapify" и как тя може да помогне при поддържането на определен ред в структура от данни?

## 2. Overview
Heap (купа) е специализирана дървовидна структура от данни, която поддържа частичен ред между елементите си, така че най-големият (max-heap) или най-малкият (min-heap) елемент винаги да е лесно достъпен. Тази структура е фундаментална за множество алгоритми, включително приоритетни опашки, които са широко използвани в системи за изкуствен интелект, графови алгоритми и сортиране.

Heapify е процесът на преобразуване на несортиран масив в heap структура, като се гарантира, че свойството на купата е изпълнено за всички възли. Тази операция е ключова за ефективното изграждане на купа и за алгоритъма heapsort. В контекста на софтуерното инженерство, правилното разбиране и имплементиране на heap и heapify подобрява производителността и надеждността на системи, които изискват бърз достъп до приоритетни елементи.

## 3. Key Concepts
- **Heap (Купа)** – дървовидна структура, в която всеки възел е по-голям (max-heap) или по-малък (min-heap) от своите деца. Мислете за нея като за "полу-сортиран" масив, където върхът е най-важният елемент.
- **Heap Property (Свойство на купата)** – условието, което гарантира, че всеки родител е по-голям или по-малък от децата си, осигурявайки бърз достъп до екстремума.
- **Heapify (Процес на купиране)** – процедура, която преобразува поддърво или масив в heap, като коригира позициите на елементите, за да се спази свойството на купата.
- **Priority Queue (Приоритетна опашка)** – абстракция, базирана на heap, която позволява бързо вмъкване и извличане на елементи с най-висок приоритет.
- **Complete Binary Tree (Пълно двоично дърво)** – дърво, в което всички нива са напълно запълнени, с изключение на последното, което е запълнено отляво надясно. Heap обикновено се реализира като такова дърво.

## 4. Step-by-step Learning Path
1. **Разберете структурата на пълно двоично дърво**
   - Фокус: Как се представя heap като масив и как се намират родители и деца.
   - Задача: Напишете функция, която за даден индекс в масив връща индексите на родител, ляво и дясно дете.
   - Въпроси: Как се изчислява индексът на родителя? Защо heap се реализира като масив, а не като свързан списък?

2. **Изучете свойството на купата**
   - Фокус: Разберете разликата между max-heap и min-heap.
   - Задача: Създайте ръчно max-heap от даден масив с 7 елемента.
   - Въпроси: Какво гарантира свойството на купата? Какво се случва, ако то не е изпълнено?

3. **Имплементирайте heapify**
   - Фокус: Научете алгоритъма за heapify и неговата времева сложност.
   - Задача: Напишете функция heapify, която коригира поддърво, започвайки от даден индекс.
   - Въпроси: Защо heapify се извършва отдолу нагоре? Какво е времето за изпълнение на heapify?

4. **Създайте функция за изграждане на heap от масив**
   - Фокус: Използвайте heapify, за да конструирате heap от произволен масив.
   - Задача: Имплементирайте buildHeap, която прилага heapify на всички подходящи възли.
   - Въпроси: Каква е общата сложност на buildHeap? Защо е по-ефективна от повтарящо се вмъкване?

5. **Приложете heap в приоритетна опашка**
   - Фокус: Вмъкване и извличане на елементи с поддържане на heap свойството.
   - Задача: Имплементирайте insert и extractMax (или extractMin) за heap.
   - Въпроси: Как се поддържа свойството на купата при вмъкване? Каква е сложността на тези операции?

## 5. Examples

### Пример 1: Представяне на heap като масив
```python
# Индексиране в масив за heap
def parent(i): return (i - 1) // 2
def left(i): return 2 * i + 1
def right(i): return 2 * i + 2

heap = [20, 15, 18, 8, 10, 17, 5]
print(f"Parent of index 3: {heap[parent(3)]}")  # Output: 15
print(f"Left child of index 1: {heap[left(1)]}")  # Output: 8
```

### Пример 2: Heapify (max-heap) функция
```python
def heapify(arr, n, i):
    largest = i
    l = 2 * i + 1
    r = 2 * i + 2

    if l < n and arr[l] > arr[largest]:
        largest = l
    if r < n and arr[r] > arr[largest]:
        largest = r
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

arr = [3, 9, 2, 1, 4, 5]
heapify(arr, len(arr), 0)
print(arr)  # Output: [9, 4, 5, 1, 3, 2]
```

### Пример 3: Изграждане на heap от масив
```python
def buildHeap(arr):
    n = len(arr)
    for i in range(n//2 - 1, -1, -1):
        heapify(arr, n, i)

arr = [3, 9, 2, 1, 4, 5]
buildHeap(arr)
print(arr)  # Output: [9, 4, 5, 1, 3, 2]
```

## 6. Common Pitfalls
- **Неправилно изчисляване на индекси** – често грешка при намиране на родители и деца в масива води до неправилна работа на heapify.
- **Пропускане на рекурсията в heapify** – ако не се извика heapify рекурсивно след размяна, свойството на купата може да бъде нарушено.
- **Опит за heapify от върха надолу** – ефективният алгоритъм започва от последния вътрешен възел нагоре, а не от корена.
- **Използване на heap за сортиране без buildHeap** – вмъкването на елементи един по един е по-бавно от еднократно изграждане на heap.
- **Забравяне за пълнотата на дървото** – heap трябва да е пълно двоично дърво, иначе индексите и логиката се нарушават.

## 7. Short Retrieval Quiz
1. Какво представлява свойството на купата?
2. Как се намира индексът на родител в масив, представящ heap?
3. Защо heapify започва от последния вътрешен възел, а не от корена?
4. Каква е времевата сложност на buildHeap?
5. Каква е разликата между max-heap и min-heap?
6. Как heap помага при реализиране на приоритетна опашка?
7. Какво се случва, ако не се извърши рекурсивно heapify след размяна?

## 8. Quick Recap
- Heap е пълно двоично дърво, което поддържа частичен ред между родители и деца.
- Heapify е процес за коригиране на поддърво, за да се спази свойството на купата.
- Heap се реализира ефективно като масив, използвайки индекси за родители и деца.
- BuildHeap изгражда heap от произволен масив с времева сложност O(n).
- Heap е основа за приоритетни опашки и алгоритъма heapsort.
- Често срещани грешки включват неправилни индекси и непълна рекурсия в heapify.
- Разбирането на heap е ключово за оптимизация на алгоритми в AI и софтуерното инженерство.

## 9. Spaced Review Plan

| Време след изучаване | Промпти за преговор                                  |
|----------------------|-----------------------------------------------------|
| 1 ден                | Обяснете какво е heap и как се реализира като масив |
| 3 дни                | Опишете алгоритъма heapify и защо започва отдолу    |
| 1 седмица            | Имплементирайте buildHeap и обяснете сложността му  |
| 1 месец              | Свържете heap с приоритетни опашки и приложението им в AI системи |