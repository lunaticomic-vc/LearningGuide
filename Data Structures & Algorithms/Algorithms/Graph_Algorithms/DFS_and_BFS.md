# DFS_and_BFS

## 1. Activate Prior Knowledge
- Какво представлява граф и какви са основните му компоненти?
- Как бихте търсили информация в голяма мрежа от свързани обекти, например социална мрежа или уеб страници?
- Какви алгоритми познавате за обхождане или търсене в структури от данни и как биха се приложили в системи за изкуствен интелект?

## 2. Overview
Обхождането на графове е фундаментална задача в компютърните науки и изкуствения интелект, която позволява систематично посещаване на всички върхове и ребра в графова структура. Два от най-известните и широко използвани алгоритми за това са DFS (Depth-First Search) и BFS (Breadth-First Search). Те осигуряват различни стратегии за преминаване през графа, които са полезни в различни контексти.

DFS се фокусира върху изследването на възможно най-дълбок път преди да се върне назад, докато BFS разглежда всички съседи на даден връх преди да премине към следващото ниво. Тези алгоритми са основа за решаване на множество практически задачи като намиране на пътища, проверка за свързаност, откриване на цикли, както и за приложения в изкуствения интелект като търсене в дървета на състояния.

В по-широк контекст, DFS и BFS са ключови компоненти в системи за планиране, оптимизация и анализ на мрежи, където ефективното обхождане на големи и сложни структури е критично. Разбирането им не само подобрява уменията за програмиране, но и развива аналитичното мислене при моделиране на проблеми.

## 3. Key Concepts
- **Graph (Граф)** – структура от върхове (nodes) и ребра (edges), която моделира връзки между обекти. Можем да си го представим като карта на град с улици (ребра) и кръстовища (върхове).
- **Vertex (Връх)** – основна единица в графа, която може да представлява обект, състояние или точка.
- **Edge (Ребро)** – връзка между два върха, която може да е насочена или ненасочена.
- **Depth-First Search (DFS)** – алгоритъм, който изследва графа, като се спуска максимално дълбоко по един път преди да се върне назад. Ментален модел: изкачване по дърво до върха, преди да се върнете надолу.
- **Breadth-First Search (BFS)** – алгоритъм, който изследва графа ниво по ниво, разглеждайки всички съседи на текущия връх преди да премине към следващите. Ментален модел: разпространение на вълна от източника.
- **Queue (Опашка)** – структура от данни, използвана в BFS за съхранение на върхове за посещение в реда на тяхното откриване.
- **Stack (Стек) или рекурсия** – използва се в DFS за връщане назад по пътя.
- **Visited Set (Множество на посетените върхове)** – механизъм за избягване на безкрайни цикли и повторно посещение.

## 4. Step-by-step Learning Path
1. **Запознайте се с основите на графовете**
   - Фокус: Разберете какво е граф, върхове и ребра.
   - Задача: Нарисувайте прост ненасочен граф с поне 5 върха и 6 ребра.
   - Въпроси: Какво е разликата между насочен и ненасочен граф? Какво означава свързан граф?

2. **Научете принципите на DFS**
   - Фокус: Разберете как работи обхождането в дълбочина.
   - Задача: Имплементирайте DFS рекурсивно за даден граф.
   - Въпроси: Какво се случва, ако не маркирате върховете като посетени? Защо DFS използва стек или рекурсия?

3. **Изучете BFS и неговата структура**
   - Фокус: Разберете как работи обхождането в ширина и ролята на опашката.
   - Задача: Имплементирайте BFS с помощта на опашка.
   - Въпроси: Как BFS гарантира, че намира най-краткия път в ненасочен граф? Каква е разликата в паметната сложност между BFS и DFS?

4. **Приложете DFS и BFS за решаване на задачи**
   - Фокус: Използвайте двата алгоритъма за намиране на пътища, проверка за цикли и свързаност.
   - Задача: Напишете функция, която проверява дали графът съдържа цикъл с DFS.
   - Въпроси: Как бихте модифицирали BFS, за да намерите най-краткия път? Кога е по-подходящ DFS пред BFS?

5. **Оптимизирайте и анализирайте алгоритмите**
   - Фокус: Изучете времева и пространствена сложност.
   - Задача: Анализирайте сложността на вашите имплементации и оптимизирайте кода.
   - Въпроси: Какво е времето за изпълнение на DFS и BFS? Как паметта се използва при двата алгоритъма?

## 5. Examples

### Пример 1: DFS рекурсивно обхождане на граф
```python
def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    print(start)
    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
    return visited

graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}

dfs(graph, 'A')
```

### Пример 2: BFS с опашка за намиране на най-кратък път
```python
from collections import deque

def bfs_shortest_path(graph, start, goal):
    queue = deque([(start, [start])])
    visited = set()

    while queue:
        vertex, path = queue.popleft()
        if vertex == goal:
            return path
        visited.add(vertex)
        for neighbor in graph[vertex]:
            if neighbor not in visited:
                queue.append((neighbor, path + [neighbor]))
    return None

graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}

print(bfs_shortest_path(graph, 'A', 'F'))
```

### Пример 3: Проверка за цикъл с DFS
```python
def has_cycle(graph):
    visited = set()
    rec_stack = set()

    def dfs(v):
        visited.add(v)
        rec_stack.add(v)
        for neighbor in graph[v]:
            if neighbor not in visited:
                if dfs(neighbor):
                    return True
            elif neighbor in rec_stack:
                return True
        rec_stack.remove(v)
        return False

    for node in graph:
        if node not in visited:
            if dfs(node):
                return True
    return False

graph_with_cycle = {
    'A': ['B'],
    'B': ['C'],
    'C': ['A']
}

print(has_cycle(graph_with_cycle))  # True
```

## 6. Common Pitfalls
- **Неотбелязване на посетени върхове** – води до безкрайни цикли и прекъсване на програмата.
- **Използване на стек вместо опашка в BFS** – нарушава логиката на обхождане в ширина.
- **Пренебрегване на насочеността на графа** – алгоритмите трябва да се прилагат според вида на графа.
- **Липса на проверка за съществуването на върхове** – може да доведе до грешки при опит за достъп до несъществуващи ключове.
- **Неправилно управление на пътища в BFS** – ако не се съхраняват пътищата, не може да се възстанови най-краткият маршрут.

## 7. Short Retrieval Quiz
1. Каква е основната разлика между DFS и BFS?
2. Коя структура от данни се използва в BFS и защо?
3. Как DFS избягва безкрайни цикли?
4. В какъв случай BFS намира най-краткия път?
5. Какво представлява множество на посетените върхове?
6. Как бихте проверили дали граф съдържа цикъл?
7. Кога е по-подходящо да използваме DFS вместо BFS?

## 8. Quick Recap
- DFS и BFS са основни алгоритми за обхождане на графове с различни стратегии.
- DFS изследва възможно най-дълбоко по един път, използвайки стек или рекурсия.
- BFS разглежда всички съседи на текущия връх, използвайки опашка.
- И двата алгоритъма използват множество за посетени върхове, за да избегнат цикли.
- BFS е подходящ за намиране на най-кратки пътища в ненасочени графове.
- DFS може да се използва за откриване на цикли и свързаност.
- Правилната имплементация изисква внимание към структурата на графа и управлението на данни.

## 9. Spaced Review Plan

| Време след изучаване | Промпт за преглед                                |
|----------------------|-------------------------------------------------|
| 1 ден                | Обяснете разликите между DFS и BFS с примери.   |
| 3 дни                | Имплементирайте DFS и BFS за прост граф.        |
| 1 седмица            | Решете задача за намиране на цикъл с DFS.       |
| 1 месец              | Сравнете приложенията и сложността на DFS и BFS.|