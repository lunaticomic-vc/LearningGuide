# 18 - Message brokers and queues (Kafka, RabbitMQ, SQS)

## 1. Activate Prior Knowledge

- Какви проблеми могат да възникнат, когато няколко части на една система трябва да обменят данни помежду си в реално време?
- Кога е по-добре да използваме асинхронна комуникация вместо синхронна в мащабни софтуерни системи?
- Можете ли да си спомните ситуации, в които забавяне или загуба на съобщения би била критична за дадено приложение (например в AI системи или финансови услуги)?

## 2. Overview

Message brokers и опашки (queues) са ключови компоненти в съвременните софтуерни архитектури, особено когато системите трябва да бъдат мащабируеми, устойчиви и лесно разширяеми. Те позволяват на различни части на системата да комуникират асинхронно, като изпращат и получават съобщения чрез посредник, наречен message broker.

Вместо компонентите да комуникират директно (което води до силна зависимост и трудна поддръжка), message broker-ите действат като пощенска станция: изпращачът оставя съобщение, а получателят го взима, когато е готов. Това намалява времевата зависимост между компонентите и повишава устойчивостта на системата при натоварване или грешки.

В AI системи, обработващи големи обеми данни, message queues често се използват за разпределяне на задачи между множество работещи процеси (workers), което позволява паралелна обработка и по-добро използване на ресурсите. В облачни среди като AWS, управлявани услуги като SQS опростяват внедряването на такива архитектури.

## 3. Key Concepts

- **Message Broker** – Софтуерен посредник, който приема, съхранява и препраща съобщения между изпращачи (producers) и получатели (consumers). Мислете за него като за централен пощенски клон.
- **Queue (Опашка)** – Структура от данни, в която съобщенията се подреждат по реда на пристигане (FIFO: First-In-First-Out). Аналогия: опашка в магазин – първият пристигнал се обслужва първи.
- **Producer (Изпращач)** – Компонент, който създава и изпраща съобщения към брокера.
- **Consumer (Получател)** – Компонент, който получава и обработва съобщения от брокера.
- **Topic** – В системи като Kafka, това е логически канал, по който се публикуват и консумират съобщения.
- **Publish/Subscribe (Pub/Sub)** – Модел, при който много изпращачи могат да публикуват съобщения към тема, а много получатели могат да се абонират за тази тема и да получават съобщенията.
- **Acknowledgement (Потвърждение)** – Механизъм, чрез който получателят уведомява брокера, че съобщението е успешно обработено.
- **Durability (Устойчивост)** – Гаранция, че съобщенията няма да се загубят при срив на системата.

## 4. Step-by-step Learning Path

1. **Разберете основния модел на комуникация**
   - Фокус: Разлика между синхронна и асинхронна комуникация.
   - Задача: Начертайте схема на система, в която два компонента комуникират директно и такава с message broker.
   - Въпроси: Какви са предимствата на асинхронната комуникация? Как message broker-ът подобрява устойчивостта?

2. **Запознайте се с основните брокери (Kafka, RabbitMQ, SQS)**
   - Фокус: Основни характеристики и разлики между тях.
   - Задача: Направете кратка таблица с плюсове и минуси на Kafka, RabbitMQ и SQS.
   - Въпроси: Кога бихте избрали Kafka пред RabbitMQ? Какви са предимствата на управляваната услуга SQS?

3. **Създайте проста опашка и изпратете съобщение**
   - Фокус: Практическа работа с избран брокер (например RabbitMQ).
   - Задача: Инсталирайте RabbitMQ локално, създайте опашка и изпратете/получете съобщение с примерен код.
   - Въпроси: Как се създава опашка? Как се изпраща и получава съобщение?

4. **Използвайте publish/subscribe модел**
   - Фокус: Работа с теми и много получатели.
   - Задача: Създайте тема в Kafka или exchange в RabbitMQ и изпратете съобщения към няколко получателя.
   - Въпроси: Какво е разликата между queue и topic? Как се гарантира, че всички получатели ще получат съобщението?

5. **Интегрирайте message broker в реална система**
   - Фокус: Връзка между микросервиси чрез брокер.
   - Задача: Свържете два малки сервиса чрез message broker (например Python скриптове, които обменят данни).
   - Въпроси: Какви са предизвикателствата при интеграция? Как се обработват грешки и повторно изпращане на съобщения?

## 5. Examples

### Пример 1: Изпращане и получаване на съобщение с RabbitMQ (Python)

```python
# Producer
import pika

connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()
channel.queue_declare(queue='hello')
channel.basic_publish(exchange='', routing_key='hello', body='Hello, World!')
connection.close()

# Consumer
import pika

connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()
channel.queue_declare(queue='hello')

def callback(ch, method, properties, body):
    print(f"Received {body}")

channel.basic_consume(queue='hello', on_message_callback=callback, auto_ack=True)
channel.start_consuming()
```

### Пример 2: Използване на AWS SQS (boto3)

```python
import boto3

sqs = boto3.resource('sqs')
queue = sqs.get_queue_by_name(QueueName='my-queue')

# Send message
queue.send_message(MessageBody='Hello from SQS!')

# Receive message
for message in queue.receive_messages(MaxNumberOfMessages=1):
    print(message.body)
    message.delete()
```

### Пример 3: Kafka publish/subscribe (концептуално)

- Producer изпраща съобщения към "topic" (например "logs").
- Няколко consumers се абонират за този topic и получават всички съобщения.

## 6. Common Pitfalls

- **Загуба на съобщения:** Ако не се използват acknowledgements или съобщенията не се съхраняват устойчиво, може да се изгубят при сривове. Използвайте durability и потвърждения.
- **Неправилно мащабиране:** Недостатъчно consumers или неправилно конфигурирани партиции/опашки могат да доведат до забавяне или задръстване.
- **Липса на мониторинг:** Без наблюдение на брокера и опашките е трудно да се открият проблеми навреме.
- **Грешки при обработка:** Ако consumer-ът не обработи съобщението правилно, то може да се загуби или да се обработи многократно. Използвайте dead-letter queues и retry механизми.
- **Неправилна конфигурация на сигурността:** Недостатъчно защитени брокери могат да бъдат уязвими към атаки.

## 7. Short Retrieval Quiz

1. Каква е основната роля на message broker в една система?
2. Каква е разликата между queue и topic?
3. Какво е acknowledgement и защо е важно?
4. Кога бихте използвали publish/subscribe модел?
5. Какви са предимствата на асинхронната комуникация?
6. Как може да се избегне загуба на съобщения при срив на брокера?
7. Кои са основните разлики между Kafka, RabbitMQ и SQS?

## 8. Quick Recap

- Message brokers позволяват асинхронна комуникация между компоненти.
- Опашките (queues) съхраняват съобщенията до обработка от получател.
- Kafka, RabbitMQ и SQS са популярни брокери с различни силни страни.
- Publish/subscribe моделът позволява на много получатели да получават едно и също съобщение.
- Потвържденията (acknowledgements) гарантират, че съобщенията са обработени.
- Устойчивостта (durability) предпазва от загуба на данни при сривове.
- Добрата конфигурация и мониторинг са критични за надеждността на системата.

## 9. Spaced Review Plan

| Време     | Преговори/Въпроси                                    |
|-----------|------------------------------------------------------|
| 1 ден     | Обяснете разликата между queue и topic.              |
| 3 дни     | Опишете предимствата на асинхронната комуникация.    |
| 1 седмица | Сравнете Kafka, RabbitMQ и SQS по основни критерии.  |
| 1 месец   | Дайте пример за реална интеграция на message broker. |