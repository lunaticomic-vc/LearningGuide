# Multithreading_and_synchronization

## 1. Activate Prior Knowledge
- Какво представлява процесът на изпълнение на няколко задачи едновременно в компютърна система?
- Защо мислите, че паралелното изпълнение на код може да бъде предизвикателство в софтуерните системи?
- Как бихте използвали многопоточност в контекста на изкуствен интелект, например при обработка на големи данни или обучение на модели?

## 2. Overview
Многопоточността (multithreading) е техника, която позволява едновременно изпълнение на множество потоци (threads) в рамките на един процес. Това е ключов механизъм за повишаване на производителността и ефективността на съвременните софтуерни системи, особено когато се работи с многоядрени процесори. В контекста на AI системи, многопоточността може да ускори обработката на данни, паралелното обучение на модели и отговора на множество заявки.

Синхронизацията е набор от техники и механизми, които гарантират правилното взаимодействие между паралелно изпълняващите се потоци. Тя предотвратява проблеми като състезателни условия (race conditions), мъртви блокировки (deadlocks) и непоследователни състояния на данни. Без адекватна синхронизация, многопоточните програми могат да доведат до труднооткриваеми грешки и нестабилност.

В по-широк контекст, многопоточността и синхронизацията са основни за изграждането на надеждни, мащабируеми и бързи софтуерни приложения, които могат да използват пълния потенциал на хардуера. Те са неразделна част от съвременната софтуерна инженерия и изискват задълбочено разбиране и практика.

## 3. Key Concepts
- **Thread (Поток)** – Най-малката единица на изпълнение в рамките на процес. Можем да си го представим като отделен работник в една фабрика, който изпълнява конкретна задача.
- **Race Condition (Състезателно състояние)** – Ситуация, при която два или повече потока се опитват да променят една и съща споделена променлива едновременно, водеща до непредвидими резултати.
- **Mutex (Взаимно изключване)** – Механизъм, който позволява само на един поток да достъпва критична секция от кода в даден момент, като ключ за заключена врата.
- **Deadlock (Мъртва блокировка)** – Състояние, при което два или повече потока чакат един друг да освободят ресурси, което води до безкрайно блокиране.
- **Critical Section (Критична секция)** – Част от кода, която трябва да бъде изпълнена от един поток наведнъж, за да се избегнат конфликти.
- **Semaphore (Семафор)** – Обект за синхронизация, който контролира достъпа до ограничен брой ресурси, подобно на светофар, който регулира движението.
- **Context Switch (Смяна на контекста)** – Процесът на превключване между изпълнението на различни потоци, който носи допълнителни разходи за системата.

## 4. Step-by-step Learning Path
1. **Основи на многопоточността**
   - Фокус: Разберете какво е поток и как се създава.
   - Задача: Напишете проста програма, която създава два потока, които отпечатват различни съобщения.
   - Въпроси за припомняне: Какво е поток? Как се създава нов поток в избрания език?

2. **Проблеми при паралелно изпълнение**
   - Фокус: Изучете race conditions и защо възникват.
   - Задача: Демонстрирайте race condition с пример, където два потока увеличават една и съща променлива без синхронизация.
   - Въпроси: Какво е race condition? Какви са последствията от него?

3. **Синхронизация с mutex**
   - Фокус: Научете как mutex предотвратява състезателни условия.
   - Задача: Модифицирайте предишния пример, като добавите mutex за защита на променливата.
   - Въпроси: Как mutex гарантира взаимно изключване? Как се използва в кода?

4. **Разбиране на deadlocks**
   - Фокус: Изучете причините и начините за избягване на deadlocks.
   - Задача: Напишете пример, който създава deadlock, и го коригирайте.
   - Въпроси: Какво е deadlock? Как може да бъде предотвратен?

5. **Разширени техники: семафори и други**
   - Фокус: Запознайте се с семафори и други механизми за синхронизация.
   - Задача: Имплементирайте семафор, който контролира достъпа до ограничен ресурс.
   - Въпроси: Как семафорът се различава от mutex? Кога е полезен?

## 5. Examples
### Пример 1: Създаване на два потока в Python
```python
import threading

def print_numbers():
    for i in range(5):
        print(f"Thread 1: {i}")

def print_letters():
    for c in ['a', 'b', 'c', 'd', 'e']:
        print(f"Thread 2: {c}")

t1 = threading.Thread(target=print_numbers)
t2 = threading.Thread(target=print_letters)

t1.start()
t2.start()

t1.join()
t2.join()
```

### Пример 2: Race condition и mutex в C++
```cpp
#include <iostream>
#include <thread>
#include <mutex>

int counter = 0;
std::mutex mtx;

void increment() {
    for (int i = 0; i < 1000; ++i) {
        mtx.lock();
        ++counter;
        mtx.unlock();
    }
}

int main() {
    std::thread t1(increment);
    std::thread t2(increment);

    t1.join();
    t2.join();

    std::cout << "Counter: " << counter << std::endl;
    return 0;
}
```

### Пример 3: Deadlock пример (Java)
```java
public class DeadlockDemo {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();

    public void method1() {
        synchronized(lock1) {
            System.out.println("Thread 1: Holding lock1...");
            try { Thread.sleep(100); } catch (InterruptedException e) {}
            synchronized(lock2) {
                System.out.println("Thread 1: Holding lock1 and lock2...");
            }
        }
    }

    public void method2() {
        synchronized(lock2) {
            System.out.println("Thread 2: Holding lock2...");
            try { Thread.sleep(100); } catch (InterruptedException e) {}
            synchronized(lock1) {
                System.out.println("Thread 2: Holding lock2 and lock1...");
            }
        }
    }

    public static void main(String[] args) {
        DeadlockDemo demo = new DeadlockDemo();
        new Thread(demo::method1).start();
        new Thread(demo::method2).start();
    }
}
```

## 6. Common Pitfalls
- **Игнориране на синхронизацията** – Водещо до race conditions и непредсказуеми грешки.
- **Прекомерна синхронизация** – Води до намалена производителност и потенциални deadlocks.
- **Неправилно използване на mutex** – Забравяне да се освободи mutex, което блокира други потоци.
- **Deadlocks поради неправилен ред на заключване** – Винаги заключвайте ресурсите в една и съща последователност.
- **Пренебрегване на context switch overhead** – Многопоточността не винаги ускорява програмата, ако има прекалено много превключвания.

## 7. Short Retrieval Quiz
1. Какво е поток (thread)?
2. Какво представлява race condition?
3. Как mutex предотвратява състезателни условия?
4. Какво е deadlock и как може да се избегне?
5. Каква е разликата между mutex и semaphore?
6. Какво е критична секция?
7. Защо многопоточността може да не доведе до ускорение на програмата?

## 8. Quick Recap
- Многопоточността позволява паралелно изпълнение на код за по-висока производителност.
- Синхронизацията гарантира правилно взаимодействие между потоците и предотвратява грешки.
- Race conditions възникват при едновременен достъп до споделени ресурси без защита.
- Mutex и семафори са основни механизми за синхронизация.
- Deadlocks са сериозен проблем, причинен от неправилно управление на ресурси.
- Практическото разбиране и тестване са ключови за овладяване на многопоточността.
- Балансът между паралелизъм и синхронизация е критичен за ефективността.

## 9. Spaced Review Plan

| Време       | Промпт за преглед                                        |
|-------------|----------------------------------------------------------|
| 1 ден       | Обяснете с прости думи какво е многопоточност и синхронизация. |
| 3 дни       | Опишете race condition и как mutex го предотвратява.     |
| 1 седмица   | Дайте пример за deadlock и начини за неговото избягване.  |
| 1 месец     | Прегледайте основните механизми за синхронизация и кога се използват. |