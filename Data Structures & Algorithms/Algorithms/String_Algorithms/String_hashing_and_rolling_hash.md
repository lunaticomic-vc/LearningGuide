# String_hashing_and_rolling_hash

## 1. Activate Prior Knowledge
- Какво представлява хеширането и как се използва за бързо търсене на данни в софтуерните системи?
- Как бихте сравнили два текста или низове по ефективен начин, без да ги проверявате символ по символ?
- В какви ситуации при обработка на естествен език или анализ на данни може да е полезно бързо да се изчислява и сравнява хеш на низове?

## 2. Overview
Хеширането на низове е техника, която позволява преобразуването на текстови данни в числови стойности (хешове), които са лесни за сравнение и индексиране. Това е особено важно в алгоритми, които работят с големи обеми текст, като търсачки, системи за откриване на плагиатство или анализ на естествен език.

Ролинг хешът (rolling hash) е специален вид хеширане, който позволява ефективно изчисляване на хешове за всички поднизове с фиксирана дължина в даден текст. Тази техника е ключова за алгоритми като Rabin-Karp, които използват хеширане за бързо търсене на шаблони.

Тези методи са основа за много приложения в софтуерното инженерство и изкуствения интелект, където скоростта и ефективността на обработка на текстови данни са критични. Разбирането и правилното прилагане на string hashing и rolling hash подобрява производителността и надеждността на системите.

## 3. Key Concepts
- **Hash Function** – функция, която преобразува входни данни (например низ) в фиксирана по размер числова стойност. Мислете за нея като за уникален пръстов отпечатък на текста.
- **Collision** – ситуация, при която различни низове дават еднакъв хеш. Това е нежелано, но неизбежно при ограничен размер на хеша.
- **Rolling Hash** – хеш функция, която позволява бързо изчисляване на хешове за последователни поднизове, като използва хеша на предишния подниз и малка корекция.
- **Modular Arithmetic** – аритметика с остатък при деление, използвана за контролиране на размера на числата при изчисляване на хешове и избягване на препълване.
- **Base (Radix)** – числото, използвано като основа при изчисляване на хеша, подобно на основата в позиционна бройна система (например 31 или 53 за букви).
- **Rabin-Karp Algorithm** – алгоритъм за търсене на шаблон в текст, който използва rolling hash за бързо сравнение на поднизове.

## 4. Step-by-step Learning Path
1. **Разберете основите на хеширането**
   - Фокус: Как работи хеш функцията и защо е полезна.
   - Задача: Напишете проста хеш функция за низ, използвайки сума от ASCII стойности.
   - Въпроси: Какво е хеширане? Защо не можем да използваме директно низовете за сравнение?

2. **Изучете modular arithmetic**
   - Фокус: Как да използваме модулна аритметика за контрол на размера на числата.
   - Задача: Изчислете (123456789 * 987654321) mod 1000000007 на ръка или с помощта на код.
   - Въпроси: Защо използваме модул при изчисляване на хешове? Какво е overflow?

3. **Разберете rolling hash**
   - Фокус: Как да изчисляваме хешове на поднизове ефективно.
   - Задача: Имплементирайте rolling hash за низ с фиксирана дължина подниз.
   - Въпроси: Как rolling hash спестява време спрямо изчисляване на хеш от нулата?

4. **Приложете rolling hash в алгоритъм за търсене**
   - Фокус: Използване на rolling hash в Rabin-Karp.
   - Задача: Имплементирайте Rabin-Karp алгоритъм за търсене на шаблон в текст.
   - Въпроси: Как Rabin-Karp използва rolling hash? Как се справя с колизии?

5. **Оптимизирайте и анализирайте производителността**
   - Фокус: Времева и пространствена сложност.
   - Задача: Тествайте алгоритъма с различни дължини на текст и шаблон, анализирайте резултатите.
   - Въпроси: Как времето за изпълнение се променя с дължината на текста? Какво е влиянието на избора на база и модул?

## 5. Examples

### Пример 1: Проста хеш функция за низ
```python
def simple_hash(s):
    h = 0
    for c in s:
        h += ord(c)
    return h
print(simple_hash("abc"))  # Изход: 294 (97+98+99)
```

### Пример 2: Rolling hash за подниз с фиксирана дължина
```python
def rolling_hash(s, length, base=31, mod=10**9+7):
    h = 0
    power = 1
    for i in range(length):
        h = (h * base + ord(s[i])) % mod
        if i < length - 1:
            power = (power * base) % mod
    hashes = [h]
    for i in range(length, len(s)):
        h = (h - ord(s[i - length]) * power) % mod
        h = (h * base + ord(s[i])) % mod
        hashes.append(h)
    return hashes

print(rolling_hash("abracadabra", 3))
```

### Пример 3: Rabin-Karp алгоритъм за търсене на шаблон
```python
def rabin_karp(text, pattern, base=31, mod=10**9+7):
    n, m = len(text), len(pattern)
    if m > n:
        return -1
    p_hash = 0
    t_hash = 0
    power = 1
    for i in range(m):
        p_hash = (p_hash * base + ord(pattern[i])) % mod
        t_hash = (t_hash * base + ord(text[i])) % mod
        if i < m - 1:
            power = (power * base) % mod
    for i in range(n - m + 1):
        if p_hash == t_hash and text[i:i+m] == pattern:
            return i
        if i < n - m:
            t_hash = (t_hash - ord(text[i]) * power) % mod
            t_hash = (t_hash * base + ord(text[i + m])) % mod
            t_hash = (t_hash + mod) % mod
    return -1

print(rabin_karp("abracadabra", "cad"))  # Изход: 4
```

## 6. Common Pitfalls
- **Игнориране на колизии** – не винаги еднаквият хеш означава еднакъв низ, затова е важно да се проверява действителното съвпадение.
- **Неправилно използване на модул** – пропускане на добавяне на модул след изваждане може да доведе до отрицателни стойности.
- **Избор на неподходяща база или модул** – твърде малки стойности увеличават риска от колизии, твърде големи могат да забавят изчисленията.
- **Препълване на цели числа** – без modular arithmetic, числата могат да излязат извън границите на типа.
- **Неоптимално преизчисляване на хешове** – изчисляване на хеш от нулата за всеки подниз е неефективно.

## 7. Short Retrieval Quiz
1. Какво представлява rolling hash и какво предимство дава?
2. Защо използваме модулна аритметика при изчисляване на хешове?
3. Какво е collision и как се справяме с него?
4. Как Rabin-Karp алгоритъм използва rolling hash?
5. Каква е ролята на базата (base) в хеш функцията?
6. Какво трябва да проверим, ако два хеша съвпадат?
7. Какво е времевата сложност на търсене с Rabin-Karp?

## 8. Quick Recap
- Хеширането преобразува низове в числови стойности за бързо сравнение.
- Rolling hash позволява ефективно изчисляване на хешове за последователни поднизове.
- Модулната аритметика предотвратява препълване и контролира размера на числата.
- Rabin-Karp използва rolling hash за бързо търсене на шаблони в текст.
- Колизиите са неизбежни, затова винаги трябва да проверяваме съвпадението на оригиналните низове.
- Изборът на база и модул влияе на качеството и производителността на хеш функцията.
- Правилната имплементация на rolling hash значително ускорява текстовите алгоритми.

## 9. Spaced Review Plan

| Време след изучаване | Промпт за преглед                                      |
|----------------------|--------------------------------------------------------|
| 1 ден                | Обяснете как работи rolling hash и защо е полезен.     |
| 3 дни                | Имплементирайте проста rolling hash функция на ръка.  |
| 1 седмица            | Опишете как Rabin-Karp използва rolling hash.          |
| 1 месец              | Прегледайте и анализирайте потенциални колизии в хеширане. |