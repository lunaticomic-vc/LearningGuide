# Root_finding

## 1. Activate Prior Knowledge
- Какво представлява решаването на уравнения и защо е важно в софтуерното инженерство и изкуствения интелект?
- Можете ли да си представите ситуации, в които трябва да намерим стойност, при която дадена функция приема нула?
- Какви методи за търсене на решения на уравнения знаете и как те могат да се прилагат в автоматизирани системи?

## 2. Overview
Root finding (намиране на корени) е процесът на откриване на стойности на променливата, при които дадена функция приема нулева стойност. Това е фундаментална задача в числения анализ и играе ключова роля в много области на компютърните науки, инженерството и изкуствения интелект. Например, в машинното обучение често се налага оптимизация, която включва решаване на уравнения, а в системите за управление – намиране на стабилни точки.

В по-широк контекст root finding е част от числените методи, които позволяват да се работи с функции, за които няма аналитично решение или то е трудно за изчисление. Тези методи са основа за разработване на алгоритми, които се използват в симулации, оптимизации и моделиране на сложни системи.

Разбирането на root finding не само подобрява способността за решаване на конкретни математически задачи, но и развива умения за анализ на алгоритми, оценка на тяхната ефективност и стабилност, което е критично за изграждане на надежден софтуер.

## 3. Key Concepts
- **Root (корен)** – стойността на променливата, при която функцията става нула. Можем да си го представим като точка, където графиката на функцията пресича хоризонталната ос.
- **Function (функция)** – правило, което свързва всяка входна стойност с точно една изходна стойност. В контекста на root finding, търсим вход, при който изходът е 0.
- **Bracketing methods (методи с ограждане)** – техники, които започват с два начални точки, между които коренът е гарантирано да съществува, и постепенно стесняват интервала. Пример: метод на бисекцията.
- **Open methods (открити методи)** – използват само една начална стойност и се опитват да приближат корена чрез итерации, например метод на Нютон-Рафсън.
- **Convergence (сходимост)** – свойството на алгоритъма да приближава корена с всяка итерация. Важно е да се разбере колко бързо и надеждно се случва това.
- **Tolerance (толеранс)** – задава точността, с която търсим корена, например колко близо до нулата трябва да е стойността на функцията.
- **Derivative (производна)** – мярка за скоростта на промяна на функцията, използвана в някои методи като Нютон-Рафсън за по-бързо приближаване.

## 4. Step-by-step Learning Path
1. **Запознайте се с основната дефиниция на корен и функция.**  
   *Задача:* Намерете корен на функцията f(x) = x² - 4 чрез опити с различни стойности на x.  
   *Въпроси:* Какво означава f(x) = 0? Защо x=2 е корен?

2. **Изучете метода на бисекцията (bracketing method).**  
   *Задача:* Имплементирайте метод на бисекция за f(x) = x³ - x - 2 в Python.  
   *Въпроси:* Какво гарантира, че коренът е между началните точки? Как се избира новата точка?

3. **Разберете метода на Нютон-Рафсън (open method).**  
   *Задача:* Напишете код за метода на Нютон-Рафсън за f(x) = x² - 2, използвайки производна.  
   *Въпроси:* Каква роля играе производната? Какво се случва, ако производната е 0?

4. **Изследвайте сходимостта и толеранса.**  
   *Задача:* Сравнете броя итерации на двата метода при различни толеранси.  
   *Въпроси:* Как толерансът влияе на резултата? Кой метод е по-бърз?

5. **Прилагане в реални задачи.**  
   *Задача:* Използвайте root finding за намиране на оптимална стойност в задача за минимизация на функция.  
   *Въпроси:* Как root finding помага в оптимизацията? Какви са ограниченията?

## 5. Examples
### Пример 1: Метод на бисекцията за f(x) = x³ - x - 2
```python
def bisection(f, a, b, tol=1e-5):
    if f(a)*f(b) >= 0:
        raise ValueError("Функцията трябва да има различни знаци в a и b")
    while (b - a)/2 > tol:
        c = (a + b)/2
        if f(c) == 0:
            return c
        elif f(a)*f(c) < 0:
            b = c
        else:
            a = c
    return (a + b)/2

root = bisection(lambda x: x**3 - x - 2, 1, 2)
print(f"Коренът е приблизително: {root}")
```

### Пример 2: Метод на Нютон-Рафсън за f(x) = x² - 2
```python
def newton_raphson(f, df, x0, tol=1e-5, max_iter=100):
    x = x0
    for _ in range(max_iter):
        fx = f(x)
        if abs(fx) < tol:
            return x
        dfx = df(x)
        if dfx == 0:
            raise ZeroDivisionError("Производната е нула")
        x -= fx/dfx
    raise ValueError("Не се конвергира")

root = newton_raphson(lambda x: x**2 - 2, lambda x: 2*x, 1)
print(f"Коренът е приблизително: {root}")
```

### Пример 3: Приложение в оптимизация – намиране на критична точка
Намиране на корен на производната на функция за намиране на минимум.

## 6. Common Pitfalls
- **Неправилен избор на начални точки:** Ако началните точки не ограждат корен, методът на бисекция не работи.  
- **Производна равна на нула:** В метода на Нютон-Рафсън, ако производната е 0, алгоритъмът се проваля.  
- **Липса на сходимост:** Някои функции или начални стойности могат да доведат до неуспешно приближаване.  
- **Прекалено нисък толеранс:** Води до излишно голям брой итерации и загуба на време.  
- **Игнориране на множествени корени:** Някои функции имат повече от един корен, което изисква внимателен анализ.

## 7. Short Retrieval Quiz
1. Какво е корен на функция?  
2. Какво гарантира методът на бисекция?  
3. Защо производната е важна в метода на Нютон-Рафсън?  
4. Какво означава сходимост?  
5. Какво може да се случи, ако производната е нула в метода на Нютон-Рафсън?  
6. Кога е подходящо да използваме bracketing методи?  
7. Как толерансът влияе на резултата от root finding?

## 8. Quick Recap
- Root finding означава намиране на стойности, при които функцията е нула.  
- Методи с ограждане (bracketing) използват интервал, в който коренът е гарантиран.  
- Методът на Нютон-Рафсън използва производната за бързо приближаване.  
- Сходимостта и толерансът са ключови за ефективността на алгоритмите.  
- Неправилен избор на начални условия и нулева производна са чести проблеми.  
- Root finding е основа за много приложения в инженерството и изкуствения интелект.  
- Практическото имплементиране изисква внимание към стабилност и точност.

## 9. Spaced Review Plan

| Време след учене | Промпт за преглед                                  |
|------------------|---------------------------------------------------|
| 1 ден            | Обяснете с прости думи какво е root finding.      |
| 3 дни            | Опишете разликите между метода на бисекция и Нютон-Рафсън. |
| 1 седмица        | Напишете кратък код за един от методите.          |
| 1 месец          | Приложете root finding в реален инженеринг проблем. |