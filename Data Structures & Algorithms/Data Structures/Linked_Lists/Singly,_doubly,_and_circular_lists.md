# Singly,_doubly,_and_circular_lists

## 1. Activate Prior Knowledge

- Какви структури от данни използвате най-често при реализиране на динамични колекции от елементи в софтуерни системи?
- Как мислите, какви предимства и недостатъци могат да имат линейните списъци спрямо масивите при обработка на големи обеми данни в AI приложения?
- Можете ли да предвидите как различните видове свързани списъци влияят върху ефективността на операции като вмъкване, изтриване и търсене?

## 2. Overview

Свързаните списъци са фундаментална структура от данни, която позволява динамично управление на колекции от елементи чрез връзки между тях. Те са особено полезни, когато размерът на данните не е известен предварително или често се променя, което ги прави незаменими в софтуерната инженерия и изкуствения интелект.

Сингълно свързаните списъци (singly linked lists) са най-простата форма, където всеки елемент съдържа данни и указател към следващия елемент. Двуно свързаните списъци (doubly linked lists) добавят обратна връзка, което улеснява навигацията и модификацията. Кръговите списъци (circular lists) свързват последния елемент обратно към първия, позволявайки циклична итерация.

Тези структури са основа за по-сложни алгоритми и системи, като опашки, стекове, графи и кеширащи механизми. Разбирането им е ключово за оптимизиране на паметта и времето за изпълнение в реални приложения.

## 3. Key Concepts

- **Node (Възел)** – Основната единица в свързан списък, съдържа данни и един или повече указатели към други възли. Мислете за него като за „клетка“ в мрежа.
- **Pointer (Указател)** – Променлива, която съхранява адреса на друг възел, позволявайки динамично свързване между елементите.
- **Singly Linked List (Сингълно свързан списък)** – Линейна структура, където всеки възел сочи към следващия, позволявайки еднопосочно преминаване.
- **Doubly Linked List (Двуно свързан списък)** – Възлите имат два указателя: към следващия и към предишния възел, което улеснява двупосочната навигация.
- **Circular Linked List (Кръгов списък)** – Последният възел сочи обратно към първия, създавайки цикъл, полезен за непрекъснати итерации.
- **Head (Начало)** – Първият възел в списъка, от който започва навигацията.
- **Tail (Край)** – Последният възел в списъка, който при кръговите списъци сочи обратно към head.
- **Insertion (Вмъкване)** – Добавяне на нов възел в списъка, което изисква пренасочване на указатели.
- **Deletion (Изтриване)** – Премахване на възел, като се пренасочват указателите, за да се запази целостта на списъка.

## 4. Step-by-step Learning Path

1. **Запознайте се с концепцията за възел и указател**
   - Фокус: Разберете структурата на възел и ролята на указателите.
   - Задача: Създайте прост възел с данни и указател на език по избор.
   - Въпроси: Какво съдържа един възел? Какво е указател?

2. **Реализирайте сингълно свързан списък**
   - Фокус: Научете как да свързвате възли еднопосочно.
   - Задача: Напишете функции за добавяне и премахване на елементи в сингълно свързан списък.
   - Въпроси: Как се осъществява вмъкване в началото на списъка? Как се изтрива елемент?

3. **Разширете до двуно свързан списък**
   - Фокус: Добавете обратна връзка и навигация в двете посоки.
   - Задача: Имплементирайте двуно свързан списък с операции за вмъкване и изтриване.
   - Въпроси: Какво допълнително трябва да се актуализира при изтриване в двуно свързан списък?

4. **Изследвайте кръговите списъци**
   - Фокус: Разберете как цикличността променя навигацията и операциите.
   - Задача: Създайте кръгов списък и реализирайте функция за обхождане без край.
   - Въпроси: Как се различава итерацията в кръгов списък от линейния?

5. **Приложете списъците в реален проект**
   - Фокус: Използвайте списъци за управление на динамични данни в малък софтуерен модул.
   - Задача: Реализирайте опашка или стек, базирани на свързан списък.
   - Въпроси: Как избраната структура влияе на производителността на операциите?

## 5. Examples

### Пример 1: Сингълно свързан списък на Python

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class SinglyLinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
            return
        current = self.head
        while current.next:
            current = current.next
        current.next = new_node

    def print_list(self):
        current = self.head
        while current:
            print(current.data, end=' -> ')
            current = current.next
        print('None')

# Използване
sll = SinglyLinkedList()
sll.append(10)
sll.append(20)
sll.print_list()
```

### Пример 2: Двуно свързан списък на C++

```cpp
struct Node {
    int data;
    Node* prev;
    Node* next;
    Node(int val) : data(val), prev(nullptr), next(nullptr) {}
};

class DoublyLinkedList {
    Node* head;
public:
    DoublyLinkedList() : head(nullptr) {}

    void append(int val) {
        Node* newNode = new Node(val);
        if (!head) {
            head = newNode;
            return;
        }
        Node* temp = head;
        while (temp->next) temp = temp->next;
        temp->next = newNode;
        newNode->prev = temp;
    }
};
```

### Пример 3: Кръгов списък на JavaScript

```javascript
class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

class CircularLinkedList {
    constructor() {
        this.head = null;
    }

    append(data) {
        const newNode = new Node(data);
        if (!this.head) {
            this.head = newNode;
            newNode.next = this.head;
        } else {
            let current = this.head;
            while (current.next !== this.head) {
                current = current.next;
            }
            current.next = newNode;
            newNode.next = this.head;
        }
    }
}
```

## 6. Common Pitfalls

- **Забравяне да се актуализира указател при изтриване или вмъкване** – води до загуба на достъп до част от списъка или до паметни течове.
- **Обхождане на кръгов списък без условие за прекъсване** – причинява безкраен цикъл.
- **Използване на сингълно свързан списък, когато е нужна двупосочна навигация** – усложнява операциите и намалява ефективността.
- **Игнориране на специални случаи като празен списък или списък с един елемент** – често води до runtime грешки.
- **Пренебрегване на освобождаване на памет при ръчно управление (напр. в C/C++)** – причинява изтичане на ресурси.

## 7. Short Retrieval Quiz

1. Какво представлява възел в свързан списък?
2. Каква е основната разлика между сингълно и двуно свързан списък?
3. Какво е особеното при кръговия списък?
4. Коя операция е по-ефективна в двуно свързан списък спрямо сингълно свързан?
5. Какво се случва, ако не актуализираме указателите при изтриване на елемент?
6. Как се различава итерацията в кръгов списък от тази в линейния?
7. Защо свързаните списъци са предпочитани пред масивите при динамични данни?

## 8. Quick Recap

- Свързаните списъци са динамични структури, съставени от възли с указатели.
- Сингълно свързаните списъци позволяват еднопосочна навигация.
- Двуно свързаните списъци имат указатели и към предишен, и към следващ възел.
- Кръговите списъци свързват последния възел обратно към първия, създавайки цикъл.
- Правилното управление на указателите е критично за целостта на списъка.
- Свързаните списъци са основа за сложни структури и алгоритми в софтуерната инженерия.
- Използването им оптимизира паметта и времето за операции при динамични данни.

## 9. Spaced Review Plan

| Време след учене | Промпт за преглед                                      |
|------------------|-------------------------------------------------------|
| 1 ден            | Опишете разликите между сингълно, двуно и кръгов списък. |
| 3 дни            | Реализирайте функция за изтриване в двуно свързан списък. |
| 1 седмица        | Обяснете как кръгов списък може да се използва в AI система. |
| 1 месец          | Сравнете предимствата и недостатъците на свързаните списъци спрямо масивите в реални приложения. |