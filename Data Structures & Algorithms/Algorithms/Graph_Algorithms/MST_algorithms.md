# MST_algorithms

## 1. Activate Prior Knowledge
- Какво представлява граф и какви са основните му компоненти (върхове, ребра)?
- Как бихте дефинирали минимално покриващо дърво (MST) и защо е важно в оптимизационни задачи?
- Как MST алгоритмите могат да се използват в системи за изкуствен интелект или софтуерна инженерия, например при оптимизация на мрежи или клъстериране?

## 2. Overview
Минималното покриващо дърво (MST) е подграф на свързан, неориентиран граф, който свързва всички върхове с минимална възможна сума от теглата на ребрата и без цикли. MST алгоритмите са фундаментални за решаване на задачи, свързани с оптимизация на мрежи, като минимизиране на разходите за изграждане на комуникационни или транспортни системи.

В контекста на изкуствения интелект и софтуерната инженерия MST алгоритмите се използват за структуриране на данни, оптимизация на ресурси и подобряване на ефективността на системи, които работят с графови структури. Те са основа за по-сложни алгоритми в клъстериране, маршрутизация и разпределени системи.

Разбирането на MST алгоритмите е ключово за изграждането на ефективни и мащабируеми решения, които изискват минимални разходи за свързване или комуникация между множество обекти или възли.

## 3. Key Concepts
- **Graph (Граф)** – структура от върхове (nodes) и ребра (edges), която моделира връзките между обекти. Може да бъде ориентиран или неориентиран.
- **Edge Weight (Тегло на ребро)** – числова стойност, асоциирана с ребро, която често представлява разход, разстояние или време.
- **Minimum Spanning Tree (Минимално покриващо дърво)** – подграф, който свързва всички върхове с минимална обща сума на теглата и без цикли.
- **Cycle (Цикъл)** – последователност от ребра, която започва и завършва в един и същи връх, без да повтаря ребра.
- **Greedy Algorithm (Жаден алгоритъм)** – подход, който взема локално оптимални решения с надеждата да достигне глобален оптимум.
- **Kruskal’s Algorithm** – MST алгоритъм, който добавя ребра с най-малко тегло, като избягва цикли, докато свърже всички върхове.
- **Prim’s Algorithm** – MST алгоритъм, който започва от произволен връх и постепенно разширява дървото, добавяйки най-евтиното ребро към нов връх.
- **Disjoint Set Union (DSU) / Union-Find** – структура от данни за ефективно управление на множества и проверка за цикли при добавяне на ребра.

## 4. Step-by-step Learning Path
1. **Запознайте се с основите на графите и техните представяния (матрица на съседство, списък със съседи).**  
   *Практическа задача:* Имплементирайте граф с помощта на списък със съседи.  
   *Въпроси за припомняне:* Какво е разликата между матрица на съседство и списък със съседи? Защо списъкът е по-ефективен за разредени графи?

2. **Разберете дефиницията и свойствата на MST.**  
   *Практическа задача:* Нарисувайте примерен граф и намерете ръчно минималното покриващо дърво.  
   *Въпроси за припомняне:* Какво гарантира, че MST няма цикли? Защо MST е минимален?

3. **Изучете алгоритъма на Kruskal и структурата данни Union-Find.**  
   *Практическа задача:* Имплементирайте Kruskal и Union-Find за проверка на цикли.  
   *Въпроси за припомняне:* Как Union-Find помага за откриване на цикли? Какво е "path compression"?

4. **Изучете алгоритъма на Prim и прилагането му с приоритетна опашка (heap).**  
   *Практическа задача:* Имплементирайте Prim с помощта на min-heap.  
   *Въпроси за припомняне:* Как Prim избира следващото ребро? Какво е предимството на приоритетната опашка?

5. **Сравнете двата алгоритъма по време на изпълнение и приложимост.**  
   *Практическа задача:* Тествайте и измерете времето за изпълнение на Kruskal и Prim върху различни графове.  
   *Въпроси за припомняне:* В какви случаи Kruskal е по-подходящ? Кога Prim е по-ефективен?

6. **Приложете MST алгоритми в реален проблем (напр. оптимизация на мрежа или клъстериране).**  
   *Практическа задача:* Решете задача за минимално свързване на компютърна мрежа с MST.  
   *Въпроси за припомняне:* Как MST помага за намаляване на разходите? Какви са ограниченията на MST в реални системи?

## 5. Examples

### Пример 1: Kruskal на малък граф
```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0]*n

    def find(self, u):
        if self.parent[u] != u:
            self.parent[u] = self.find(self.parent[u])
        return self.parent[u]

    def union(self, u, v):
        rootU, rootV = self.find(u), self.find(v)
        if rootU == rootV:
            return False
        if self.rank[rootU] < self.rank[rootV]:
            self.parent[rootU] = rootV
        else:
            self.parent[rootV] = rootU
            if self.rank[rootU] == self.rank[rootV]:
                self.rank[rootU] += 1
        return True

def kruskal(edges, n):
    uf = UnionFind(n)
    mst = []
    edges.sort(key=lambda x: x[2])
    for u, v, w in edges:
        if uf.union(u, v):
            mst.append((u, v, w))
    return mst

edges = [(0,1,4), (0,2,3), (1,2,1), (1,3,2), (2,3,4), (3,4,2), (4,5,6)]
mst = kruskal(edges, 6)
print("MST edges:", mst)
```

### Пример 2: Prim с приоритетна опашка
```python
import heapq

def prim(graph, start=0):
    mst = []
    visited = set([start])
    edges = [(weight, start, to) for to, weight in graph[start]]
    heapq.heapify(edges)

    while edges:
        weight, frm, to = heapq.heappop(edges)
        if to not in visited:
            visited.add(to)
            mst.append((frm, to, weight))
            for to_next, w in graph[to]:
                if to_next not in visited:
                    heapq.heappush(edges, (w, to, to_next))
    return mst

graph = {
    0: [(1,4), (2,3)],
    1: [(0,4), (2,1), (3,2)],
    2: [(0,3), (1,1), (3,4)],
    3: [(1,2), (2,4), (4,2)],
    4: [(3,2), (5,6)],
    5: [(4,6)]
}
print("MST edges:", prim(graph))
```

## 6. Common Pitfalls
- **Игнориране на цикли при добавяне на ребра в Kruskal** – без Union-Find може да се добавят ребра, които създават цикли. Винаги използвайте структура за проверка.
- **Неправилно обновяване на приоритетната опашка в Prim** – ако не се следи кои върхове са посетени, алгоритъмът може да добави ребра към вече включени върхове.
- **Грешно сортиране на ребрата в Kruskal** – ребрата трябва да са сортирани по тегло възходящо, за да се гарантира минималност.
- **Използване на MST за графове с отрицателни ребра без проверка** – MST алгоритмите работят за неориентирани графи с положителни тегла; при отрицателни тегла трябва да се внимава.
- **Пренебрегване на свързаността на графа** – MST съществува само за свързани графи; ако графът не е свързан, MST няма да покрие всички върхове.

## 7. Short Retrieval Quiz
1. Какво представлява минималното покриващо дърво?
2. Как алгоритъмът на Kruskal избира ребрата за MST?
3. Каква е ролята на структурата Union-Find в MST алгоритмите?
4. Как Prim разширява текущото MST?
5. Защо MST не съдържа цикли?
6. Кога е по-подходящо да използваме Prim вместо Kruskal?
7. Какво се случва, ако графът не е свързан?

## 8. Quick Recap
- MST е подграф, който свързва всички върхове с минимална сума от теглата на ребрата и без цикли.
- Kruskal и Prim са двата основни жадни алгоритъма за намиране на MST.
- Union-Find структурата е ключова за ефективното откриване на цикли в Kruskal.
- Prim използва приоритетна опашка, за да избира най-евтините ребра, свързани с вече включените върхове.
- MST алгоритмите са широко приложими в оптимизация на мрежи, клъстериране и други инженерни задачи.
- Винаги проверявайте свързаността на графа преди прилагане на MST алгоритъм.
- Практическото имплементиране и тестване помагат за по-добро разбиране и избягване на често срещани грешки.

## 9. Spaced Review Plan

| Време след учене | Прегледна задача                        | Цел на прегледа                          |
|-------------------|---------------------------------------|-----------------------------------------|
| 1 ден             | Прегледайте дефиницията на MST и основните алгоритми | Закрепване на базови понятия             |
| 3 дни             | Имплементирайте Kruskal или Prim отново | Активно припомняне и практическо приложение |
| 1 седмица         | Решете задача с MST върху реален граф | Приложение на знанията в контекст        |
| 1 месец           | Обяснете MST алгоритмите на колега или в писмен вид | Дългосрочно затвърждаване и комуникация |