# Parallel_sorting_and_divide_conquer

## 1. Activate Prior Knowledge

- Какво представлява разделяй и владей (divide and conquer) като алгоритмична стратегия и как мислите, че може да се приложи при сортиране?
- Какви са предимствата на паралелната обработка в съвременните софтуерни системи, особено при работа с големи обеми данни?
- Можете ли да си представите как паралелното сортиране може да ускори обработката в AI системи, например при сортиране на големи масиви от данни за обучение?

## 2. Overview

Паралелното сортиране е техника, която използва множество процесорни ядра или машини, за да ускори процеса на сортиране на големи обеми данни. Тази техника е особено важна в съвременните компютърни системи, където обработката на данни трябва да бъде не само бърза, но и ефективна по отношение на ресурсите.

Стратегията "разделяй и владей" (divide and conquer) е основен подход, който разделя големия проблем на по-малки, по-лесно управляеми подпроблеми, решава ги независимо и след това комбинира резултатите. В контекста на сортирането, това означава разделяне на масива на по-малки части, сортиране на всяка част и след това сливане на сортираните части.

Този подход се вписва в по-широкия контекст на паралелните изчисления и е ключов за оптимизиране на алгоритми, които трябва да работят с огромни данни или в реално време. В AI системи, например, бързото сортиране може да подобри ефективността на алгоритми за търсене, класификация и обработка на данни.

## 3. Key Concepts

- **Divide and Conquer (Разделяй и владей)** – алгоритмична техника, която разбива проблем на по-малки подпроблеми, решава ги отделно и комбинира резултатите. Мислете за това като за разделяне на голям пъзел на по-малки части, които се подреждат поотделно и след това се съединяват.
- **Parallelism (Паралелизъм)** – изпълнение на множество изчислителни задачи едновременно, използвайки няколко процесорни ядра или машини. Аналогия: няколко работника, които работят едновременно върху различни части от една задача.
- **Merge Sort (Сливане при сортиране)** – класически алгоритъм за сортиране, който използва divide and conquer, като разделя масива, сортира частите и ги слива. Той е особено подходящ за паралелизация.
- **Speedup (Ускорение)** – мярка за това колко по-бързо се изпълнява паралелният алгоритъм спрямо последователния.
- **Load Balancing (Баланс на натоварването)** – разпределение на задачите между процесорите така, че всички да работят ефективно и да няма „задържане“ на някой от тях.
- **Granularity (Грануларност)** – размерът на подзадачите, на които се разделя проблемът. Твърде малки задачи могат да доведат до голямо разходване на време за управление, а твърде големи – до неефективно използване на паралелизма.

## 4. Step-by-step Learning Path

1. **Разберете основите на divide and conquer**
   - Фокус: Прегледайте класически алгоритми като Merge Sort и Quick Sort.
   - Задача: Имплементирайте рекурсивен Merge Sort на последователен код.
   - Въпроси: Как divide and conquer разделя проблема? Защо е ефективен?

2. **Изучете основите на паралелното програмиране**
   - Фокус: Запознайте се с концепции като нишки (threads), процеси и синхронизация.
   - Задача: Напишете програма, която използва няколко нишки за паралелно изпълнение на проста задача (напр. сумиране на масив).
   - Въпроси: Какво е speedup? Какво е overhead при паралелизъм?

3. **Паралелизирайте Merge Sort**
   - Фокус: Разделете рекурсивния Merge Sort на паралелни задачи.
   - Задача: Имплементирайте паралелен Merge Sort с използване на нишки или OpenMP.
   - Въпроси: Как се осъществява сливането на резултатите? Как се управлява балансът на натоварването?

4. **Оптимизирайте грануларността и балансa на натоварването**
   - Фокус: Експериментирайте с размера на подзадачите и разпределението им.
   - Задача: Измерете времето за изпълнение при различни нива на паралелизъм и размери на подзадачите.
   - Въпроси: Как грануларността влияе на производителността? Как да избегнем неравномерно натоварване?

5. **Приложете паралелното сортиране в реален проект**
   - Фокус: Интегрирайте паралелен сортиращ алгоритъм в по-голяма система (напр. AI pipeline).
   - Задача: Използвайте паралелен сорт за предварителна обработка на данни в ML проект.
   - Въпроси: Как паралелното сортиране подобрява цялостната производителност? Какви са ограниченията?

## 5. Examples

### Пример 1: Последователен Merge Sort (Python)

```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result
```

### Пример 2: Паралелен Merge Sort с multiprocessing (Python)

```python
import multiprocessing

def parallel_merge_sort(arr):
    if len(arr) <= 1:
        return arr
    if len(arr) < 50000:  # праг за последователна обработка
        return merge_sort(arr)
    mid = len(arr) // 2
    with multiprocessing.Pool(2) as pool:
        left, right = pool.map(parallel_merge_sort, [arr[:mid], arr[mid:]])
    return merge(left, right)
```

### Пример 3: Паралелно сортиране с OpenMP (C++)

```cpp
#include <omp.h>
#include <vector>
#include <algorithm>

void parallel_merge_sort(std::vector<int>& arr, int left, int right) {
    if (left >= right) return;
    int mid = (left + right) / 2;

    #pragma omp parallel sections
    {
        #pragma omp section
        parallel_merge_sort(arr, left, mid);
        #pragma omp section
        parallel_merge_sort(arr, mid + 1, right);
    }
    std::inplace_merge(arr.begin() + left, arr.begin() + mid + 1, arr.begin() + right + 1);
}
```

## 6. Common Pitfalls

- **Прекалено малки подзадачи (твърде фина грануларност)** – води до голямо време за управление на нишките и намалява ефективността.
- **Лош баланс на натоварването** – някои ядра остават без работа, докато други са претоварени, което води до загуба на паралелния потенциал.
- **Синхронизационни проблеми** – неправилно управление на достъпа до споделени ресурси може да доведе до състезателни условия и грешки.
- **Игнориране на overhead-а от паралелизацията** – при малки масиви паралелното сортиране може да е по-бавно от последователното.
- **Неправилно сливане на резултатите** – грешки при комбиниране на сортираните части могат да доведат до неправилна крайна подредба.

## 7. Short Retrieval Quiz

1. Какво представлява стратегията divide and conquer?
2. Защо паралелното сортиране е по-бързо от последователното при големи данни?
3. Кой класически алгоритъм за сортиране е най-подходящ за паралелизация?
4. Какво означава баланс на натоварването в контекста на паралелните алгоритми?
5. Какво може да се случи, ако грануларността е твърде малка?
6. Какъв е основният проблем при сливането на резултатите в паралелния Merge Sort?
7. Какво е speedup и как се измерва?

## 8. Quick Recap

- Divide and conquer разделя проблемите на по-малки части, които се решават независимо.
- Паралелното сортиране използва множество ядра за ускоряване на сортирането.
- Merge Sort е класически алгоритъм, подходящ за паралелизация.
- Балансът на натоварването и грануларността са ключови за ефективността.
- Overhead от паралелизацията може да намали ползата при малки задачи.
- Синхронизацията и правилното сливане на резултатите са критични.
- Паралелното сортиране е важен инструмент в обработката на големи данни и AI системи.

## 9. Spaced Review Plan

| Време след учене | Промпт за преговор                                      |
|-------------------|--------------------------------------------------------|
| 1 ден             | Обяснете на свой език как работи паралелният Merge Sort. |
| 3 дни             | Опишете как грануларността влияе на производителността. |
| 1 седмица         | Идентифицирайте основните предизвикателства при паралелното сортиране. |
| 1 месец           | Сравнете последователен и паралелен Merge Sort и дайте пример за приложение. |