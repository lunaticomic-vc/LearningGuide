# Dijkstra

## 1. Activate Prior Knowledge
- Какво представлява граф и какви видове графи познаваш?
- Как бихме могли да намерим най-краткия път между две точки в мрежа, например в GPS навигация?
- Защо алгоритмите за намиране на пътища са важни в системи за изкуствен интелект и софтуерно инженерство?

## 2. Overview
Алгоритъмът на Дейкстра е класически метод за намиране на най-краткия път от един източник до всички останали върхове в свързан граф с неотрицателни тегла на ребрата. Той е фундаментален за много приложения в компютърните науки, включително мрежова маршрутизация, планиране на пътища и оптимизация.

В по-широк контекст, алгоритъмът се използва в системи за изкуствен интелект, където е необходимо да се вземат решения за оптимални пътища или стратегии, например при роботика или игри. В софтуерното инженерство, Дейкстра служи като основа за по-сложни алгоритми и структури за данни.

Значението му идва от ефективността и универсалността – алгоритъмът гарантира намиране на оптимално решение при условията на неотрицателни тегла и е сравнително лесен за имплементация и разбиране.

## 3. Key Concepts
- **Граф** – структура, съставена от върхове (възли) и ребра (връзки), която моделира мрежи от обекти и връзките между тях.
- **Тегло на ребро** – числова стойност, която показва "цена" или "разстояние" за преминаване по реброто; в Дейкстра трябва да е неотрицателно.
- **Най-кратък път** – път между два върха с минимална сума от теглата на ребрата по пътя.
- **Приоритетна опашка (Priority Queue)** – структура от данни, която позволява бързо извличане на елемента с най-малка стойност; използва се за ефективно избиране на следващия връх за обработка.
- **Отбелязване на върхове** – процес на маркиране на върхове като обработени, за да се избегне повторна обработка и да се гарантира коректност.

## 4. Step-by-step Learning Path
1. **Разбиране на графи и представянето им**  
   - Фокус: Научи как се представят графи чрез списъци със съседи и матрици на съседство.  
   - Задача: Имплементирай граф с поне 5 върха и няколко ребра с тегла.  
   - Въпроси: Какво е предимството на списъка със съседи пред матрицата на съседство? Как се представя теглото на ребро?

2. **Основна идея на алгоритъма на Дейкстра**  
   - Фокус: Разбери логиката на алгоритъма – как се избира следващият връх и как се обновяват разстоянията.  
   - Задача: Ръчно изпълни алгоритъма върху малък граф с 4-5 върха.  
   - Въпроси: Защо не можем да използваме алгоритъма при отрицателни тегла? Как се избира следващият връх за обработка?

3. **Имплементация с приоритетна опашка**  
   - Фокус: Научи как да използваш приоритетна опашка за оптимизация на алгоритъма.  
   - Задача: Имплементирай алгоритъма на Дейкстра на избран език за програмиране, използвайки приоритетна опашка.  
   - Въпроси: Как приоритетната опашка подобрява ефективността? Какво се случва, ако не използваме приоритетна опашка?

4. **Приложения и разширения**  
   - Фокус: Изследвай как алгоритъмът се използва в реални системи и как се адаптира за специфични нужди.  
   - Задача: Намери пример за приложение на Дейкстра в мрежова маршрутизация или роботика и опиши ролята му.  
   - Въпроси: Какво е разликата между Дейкстра и алгоритъма на Белман-Форд? Кога бихме предпочели друг алгоритъм?

## 5. Examples

### Пример 1: Най-кратък път в малък граф
```python
import heapq

def dijkstra(graph, start):
    distances = {vertex: float('inf') for vertex in graph}
    distances[start] = 0
    pq = [(0, start)]
    
    while pq:
        current_distance, current_vertex = heapq.heappop(pq)
        
        if current_distance > distances[current_vertex]:
            continue
        
        for neighbor, weight in graph[current_vertex].items():
            distance = current_distance + weight
            
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(pq, (distance, neighbor))
    
    return distances

graph = {
    'A': {'B': 5, 'C': 1},
    'B': {'A': 5, 'C': 2, 'D': 1},
    'C': {'A': 1, 'B': 2, 'D': 4, 'E': 8},
    'D': {'B': 1, 'C': 4, 'E': 3},
    'E': {'C': 8, 'D': 3}
}

print(dijkstra(graph, 'A'))
```

### Пример 2: Използване в мрежова маршрутизация  
В мрежите, Дейкстра се използва за изчисляване на най-краткия път между рутери, като теглата на ребрата са времето за предаване или натоварването.

### Пример 3: Планиране на път в роботика  
Робот използва алгоритъма, за да намери най-краткия път през мрежа от възли, избягвайки препятствия и минимизирайки времето за достигане.

## 6. Common Pitfalls
- **Използване при отрицателни тегла** – алгоритъмът не работи коректно, защото не може да обработва намаляващи разстояния. Използвайте Белман-Форд при такива случаи.
- **Пренебрегване на приоритетната опашка** – без нея алгоритъмът става много по-бавен, особено при големи графи.
- **Неправилно обновяване на разстоянията** – ако не проверявате дали новото разстояние е по-малко, може да получите грешни резултати.
- **Повторна обработка на върхове** – без подходящо отбелязване или проверка, върховете могат да се обработват многократно, което води до загуба на ефективност.

## 7. Short Retrieval Quiz
1. Какво представлява алгоритъмът на Дейкстра и за какво служи?  
2. Защо теглата на ребрата трябва да са неотрицателни?  
3. Каква структура от данни се използва за оптимизация на алгоритъма?  
4. Как се обновяват разстоянията до съседните върхове?  
5. Какво се случва, ако използваме алгоритъма при граф с отрицателни тегла?  
6. Каква е разликата между списък със съседи и матрица на съседство?  
7. Какво е основното приложение на алгоритъма в мрежовата маршрутизация?

## 8. Quick Recap
- Алгоритъмът на Дейкстра намира най-краткия път в граф с неотрицателни тегла.  
- Използва приоритетна опашка за ефективно избиране на върхове за обработка.  
- Обновява разстоянията до съседните върхове, ако намери по-кратък път.  
- Не работи правилно при отрицателни тегла на ребрата.  
- Широко използван в мрежова маршрутизация, роботика и други области на ИИ.  
- Представянето на графа влияе на ефективността на алгоритъма.  
- Важно е да се отбелязват обработените върхове, за да се избегнат излишни изчисления.

## 9. Spaced Review Plan

| Време след учене | Промпт за преглед                                   |
|------------------|----------------------------------------------------|
| 1 ден            | Обясни основната идея на алгоритъма на Дейкстра.  |
| 3 дни            | Имплементирай алгоритъма на Дейкстра върху малък граф. |
| 1 седмица        | Опиши как приоритетната опашка подобрява алгоритъма. |
| 1 месец          | Сравни алгоритъма на Дейкстра с алгоритъма на Белман-Форд и приложението им. |