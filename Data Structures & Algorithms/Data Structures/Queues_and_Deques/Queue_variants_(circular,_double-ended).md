# Queue_variants_(circular,_double-ended)

## 1. Activate Prior Knowledge
- Какво представлява структурата от данни опашка (queue) и какви са нейните основни операции?
- Какви са предимствата и ограниченията на линейната опашка при управление на ресурси в софтуерни системи?
- Как бихте използвали опашка в контекста на обработка на задачи в AI система, например при управление на събития или състояния?

## 2. Overview
Опашките са фундаментални структури от данни, които поддържат ред на обработка чрез принципа FIFO (First In, First Out). Въпреки това, класическата линейна опашка има ограничения, свързани с ефективното използване на паметта и гъвкавостта при добавяне и премахване на елементи. Това води до развитието на варианти като кръгова (circular) и двупосочна (double-ended) опашка.

Кръговата опашка е оптимизация, която позволява използване на фиксиран масив, като индекси се въртят циклично, елиминирайки нуждата от преместване на елементи. Това я прави особено подходяща за системи с ограничени ресурси и високи изисквания за производителност.

Двупосочната опашка (deque) разширява функционалността, позволявайки добавяне и премахване на елементи както от началото, така и от края. Тази гъвкавост е ценна в много алгоритми и системи, включително AI, където динамичното управление на задачи или състояния изисква двупосочен достъп.

## 3. Key Concepts
- **Queue (Опашка)** – структура от данни, която поддържа ред на елементи по принципа FIFO. Представете си опашка на каса в супермаркет.
- **Circular Queue (Кръгова опашка)** – опашка, реализирана върху фиксиран масив, където индексите на началото и края се въртят циклично, за да използват паметта ефективно.
- **Double-ended Queue (Deque)** – структура, която позволява добавяне и премахване на елементи както от началото, така и от края, подобно на двупосочен влак.
- **Front и Rear Pointers (Индекси на начало и край)** – указатели, които следят позициите за добавяне и премахване на елементи в опашката.
- **Overflow и Underflow** – състояния, при които опашката е пълна (overflow) или празна (underflow), и не могат да се извършват съответните операции.

## 4. Step-by-step Learning Path
1. **Разберете основите на линейната опашка**  
   - Фокус: Прегледайте класическата опашка и нейните операции (enqueue, dequeue).  
   - Задача: Имплементирайте линейна опашка с масив.  
   - Въпроси: Какво се случва, когато опашката се напълни? Как се премахва елемент?

2. **Изучете концепцията за кръгова опашка**  
   - Фокус: Разберете как се използват цикличните индекси за ефективно управление на паметта.  
   - Задача: Модифицирайте линейната опашка, за да стане кръгова.  
   - Въпроси: Как се разпознава пълна или празна кръгова опашка? Как се обновяват индексите?

3. **Запознайте се с двупосочната опашка (deque)**  
   - Фокус: Научете операциите за добавяне и премахване от двата края.  
   - Задача: Имплементирайте deque с масив или свързан списък.  
   - Въпроси: Какви са предимствата на deque пред стандартната опашка? В какви ситуации е полезна?

4. **Приложете знанията в реален контекст**  
   - Фокус: Използвайте кръгова опашка или deque в симулация на управление на задачи.  
   - Задача: Напишете програма, която управлява задачи с приоритет, използвайки deque.  
   - Въпроси: Как deque улеснява управлението на приоритети? Как се справя с динамични промени?

## 5. Examples

### Пример 1: Кръгова опашка на C++
```cpp
class CircularQueue {
    int *arr;
    int front, rear, size, capacity;
public:
    CircularQueue(int k) {
        capacity = k;
        arr = new int[capacity];
        front = -1;
        rear = -1;
        size = 0;
    }
    bool enqueue(int value) {
        if (size == capacity) return false; // overflow
        rear = (rear + 1) % capacity;
        arr[rear] = value;
        if (front == -1) front = rear;
        size++;
        return true;
    }
    bool dequeue() {
        if (size == 0) return false; // underflow
        if (front == rear) {
            front = rear = -1;
        } else {
            front = (front + 1) % capacity;
        }
        size--;
        return true;
    }
};
```

### Пример 2: Двупосочна опашка (deque) на Python
```python
from collections import deque

dq = deque()
dq.append(10)       # добавяне в края
dq.appendleft(5)    # добавяне в началото
print(dq)           # deque([5, 10])
dq.pop()            # премахване от края
dq.popleft()        # премахване от началото
```

### Пример 3: Използване на deque за управление на задачи с приоритет
```python
from collections import deque

tasks = deque()
tasks.append('task_low_priority')
tasks.appendleft('task_high_priority')  # по-важна задача се добавя отпред

while tasks:
    current = tasks.popleft()
    print(f'Обработвам: {current}')
```

## 6. Common Pitfalls
- **Неправилно управление на индекси в кръгова опашка** – често се бърка кога опашката е пълна или празна, защото front == rear може да означава и двете. Решението е да се следи отделен брояч или да се оставя една празна клетка.
- **Пренебрегване на гранични случаи при deque** – добавяне и премахване от празна опашка трябва да се обработва внимателно, за да не се получат грешки.
- **Използване на линейна опашка при ограничена памет** – води до излишно преместване на елементи и загуба на производителност.
- **Неоптимално използване на памет при динамични структури** – при deque с масив трябва да се предвиди разширяване или циклично използване.

## 7. Short Retrieval Quiz
1. Каква е основната разлика между линейна и кръгова опашка?
2. Как се разпознава, че кръговата опашка е пълна?
3. Какви операции поддържа двупосочната опашка (deque)?
4. Защо кръговата опашка е по-ефективна при ограничена памет?
5. Какво означава underflow при опашка?
6. Как deque може да се използва за управление на приоритети?
7. Какви са основните предимства на deque пред стандартната опашка?

## 8. Quick Recap
- Опашките са структури, които поддържат ред на обработка по FIFO принцип.
- Кръговата опашка използва циклични индекси, за да оптимизира използването на паметта.
- Двупосочната опашка (deque) позволява добавяне и премахване от двата края, осигурявайки гъвкавост.
- Правилното управление на индекси и гранични случаи е ключово за коректна имплементация.
- В AI и софтуерни системи тези структури подпомагат ефективното управление на задачи и състояния.
- Използването на deque улеснява динамичното управление на приоритети и двупосочен достъп.
- Избягвайте типични грешки като неправилно разпознаване на пълна или празна опашка.

## 9. Spaced Review Plan

| Време след учене | Промпт за преговор                                  |
|------------------|----------------------------------------------------|
| 1 ден            | Обяснете разликите между линейна, кръгова и двупосочна опашка. |
| 3 дни            | Имплементирайте основните операции на кръгова опашка.          |
| 1 седмица        | Опишете случаи на използване на deque в реални системи.         |
| 1 месец          | Прегледайте и сравнете предимствата и недостатъците на различните варианти на опашки. |