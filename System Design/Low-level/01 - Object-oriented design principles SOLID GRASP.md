# 01 - Object-oriented design principles SOLID GRASP

## 1. Activate Prior Knowledge

- Какви са основните предимства на обектно-ориентираното програмиране (ООП) при изграждане на мащабируеми и поддържани софтуерни системи?
- Можете ли да дадете пример от реален проект, където лошият дизайн е довел до трудна поддръжка или промяна на кода?
- Как мислите, че добрите принципи на дизайн влияят върху качеството на AI системи или сложни софтуерни архитектури?

## 2. Overview

Обектно-ориентираният дизайн (ООД) е сърцевината на съвременната софтуерна инженерия. Той позволява създаването на гъвкави, разширяеми и лесни за поддръжка системи чрез използване на абстракция, капсулация, наследяване и полиморфизъм. В този контекст, SOLID и GRASP са два комплекта от принципи, които насочват инженерите към вземане на по-добри архитектурни решения.

SOLID е акроним за пет основни принципа, които помагат за изграждане на устойчив и модулен код. Те са особено важни при работа в екип и при системи, които се развиват с времето, като например AI платформи или големи бизнес приложения.

GRASP (General Responsibility Assignment Software Patterns) предоставя шаблони за разпределяне на отговорности между класове и обекти. Те помагат да се избегнат често срещани грешки като "God Object" или прекомерно обвързване между компонентите.

Тези принципи са фундаментални за всеки, който иска да създава софтуер, който е лесен за разбиране, разширяване и тестване – качества, които са критични в динамични области като изкуствения интелект и мащабируемите системи.

## 3. Key Concepts

- SOLID – Петте основни принципа за добър обектно-ориентиран дизайн: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion.
- GRASP – Колекция от шаблони за разпределяне на отговорности между обекти, като Controller, Creator, Information Expert и др.
- Single Responsibility Principle (SRP) – Всеки клас трябва да има само една причина за промяна; аналогия: един служител с една длъжност.
- Open/Closed Principle (OCP) – Софтуерните компоненти трябва да са отворени за разширение, но затворени за промяна; като електрически контакт, към който може да добавиш адаптер без да го разглобяваш.
- Liskov Substitution Principle (LSP) – Обектите на подкласа трябва да могат да заместят обектите на суперкласа без да нарушават функционалността.
- Interface Segregation Principle (ISP) – По-добре много малки, специфични интерфейси, отколкото един голям; като меню в ресторант – по-удобно е да имаш отделни менюта за напитки и храна.
- Dependency Inversion Principle (DIP) – Високо ниво модули не трябва да зависят от ниско ниво модули, а и двете трябва да зависят от абстракции.
- Controller (GRASP) – Клас, който координира действията между други обекти; като диригент в оркестър.
- Information Expert (GRASP) – Класът, който притежава най-много информация, необходима за изпълнение на дадена задача, трябва да я реализира.
- Low Coupling & High Cohesion – Минимална зависимост между класове и максимално фокусирани класове.

## 4. Step-by-step Learning Path

1. **Запознайте се с основите на ООП**  
   - Фокус: Абстракция, капсулация, наследяване, полиморфизъм  
   - Задача: Напишете прост клас "Car" с няколко свойства и методи.  
   - Въпроси: Какво е наследяване? Как капсулацията помага за сигурността на данните?

2. **Изучете SOLID принципите**  
   - Фокус: Разберете всяко от петте SOLID правила  
   - Задача: Преработете клас "Car", така че да спазва SRP и OCP.  
   - Въпроси: Какво означава "една причина за промяна"? Как бихте разширили функционалността без да променяте съществуващия код?

3. **Приложете GRASP шаблоните**  
   - Фокус: Controller, Information Expert, Creator  
   - Задача: Разделете логиката за управление на "Car" в отделен Controller клас.  
   - Въпроси: Кой клас трябва да създава нови обекти? Кой е експертът по информация за състоянието на автомобила?

4. **Анализирайте реални сценарии**  
   - Фокус: Откриване на нарушения на SOLID/GRASP в съществуващ код  
   - Задача: Прегледайте малък проект и идентифицирайте примери за лош дизайн.  
   - Въпроси: Къде има твърде много отговорности? Как бихте намалили обвързаността?

5. **Рефакторирайте и тествайте**  
   - Фокус: Подобряване на кода чрез прилагане на принципите  
   - Задача: Рефакторирайте избран клас, така че да спазва SOLID и GRASP.  
   - Въпроси: Какви са резултатите? По-лесно ли е да добавяте нови функции?

## 5. Examples

### Пример 1: Single Responsibility Principle (SRP)
```csharp
// Лош пример: Класът има твърде много отговорности
class Report {
    void Generate() { ... }
    void Print() { ... }
    void SaveToFile() { ... }
}

// Добър пример: Разделяне на отговорностите
class ReportGenerator {
    void Generate() { ... }
}
class ReportPrinter {
    void Print(Report report) { ... }
}
class ReportSaver {
    void SaveToFile(Report report) { ... }
}
```

### Пример 2: Dependency Inversion Principle (DIP)
```java
// Лош пример: Високо ниво модул зависи от ниско ниво модул
class LightBulb {
    void turnOn() { ... }
}

class Switch {
    private LightBulb bulb;
    void operate() { bulb.turnOn(); }
}

// Добър пример: Използване на абстракция
interface Switchable {
    void turnOn();
}

class LightBulb implements Switchable {
    public void turnOn() { ... }
}

class Switch {
    private Switchable device;
    void operate() { device.turnOn(); }
}
```

### Пример 3: GRASP Controller
```python
class OrderController:
    def submit_order(self, order_data):
        order = Order.create(order_data)
        order.process()
        return order
```

## 6. Common Pitfalls

- Смесване на отговорности в един клас (нарушение на SRP) – Разделяйте логиката по роли.
- Прекалено големи интерфейси (нарушение на ISP) – Дефинирайте малки, специфични интерфейси.
- Твърда зависимост между класове (нарушение на DIP) – Използвайте абстракции и dependency injection.
- Прекомерно използване на наследяване вместо композиция – Предпочитайте композиция, когато е възможно.
- Липса на ясно разпределение на отговорностите (нарушение на GRASP) – Използвайте шаблоните за разпределяне на роли.

## 7. Short Retrieval Quiz

1. Какво означава Single Responsibility Principle?
2. Какви са предимствата на Open/Closed Principle?
3. Какво е основната идея на Liskov Substitution Principle?
4. Защо е важно да използваме малки интерфейси (ISP)?
5. Какво представлява Controller в GRASP?
6. Как Dependency Inversion Principle улеснява тестването?
7. Какво е основното предимство на Low Coupling?

## 8. Quick Recap

- SOLID и GRASP са основни принципи за добър обектно-ориентиран дизайн.
- SOLID включва пет правила за модулност, разширяемост и поддръжка.
- GRASP предоставя шаблони за разпределяне на отговорности между обекти.
- Single Responsibility Principle намалява сложността на класовете.
- Open/Closed Principle позволява разширяване без промяна на съществуващ код.
- Dependency Inversion Principle насърчава използването на абстракции.
- Добрата архитектура улеснява промяната, тестването и повторното използване на кода.

## 9. Spaced Review Plan

| Review Interval | Prompt                                                                 |
|-----------------|-----------------------------------------------------------------------|
| 1 day           | Назовете и обяснете накратко всеки от SOLID принципите.              |
| 3 days          | Дайте пример за нарушение на SRP и как бихте го коригирали.           |
| 1 week          | Обяснете разликата между Controller и Information Expert (GRASP).     |
| 1 month         | Приложете SOLID и GRASP в малък проект и анализирайте резултатите.    |