# 05 - Indexing and query optimization

## 1. Activate Prior Knowledge

- Какви са основните предизвикателства при търсенето на информация в големи бази данни или AI системи?
- Какви техники познавате за ускоряване на достъпа до данни в софтуерното инженерство?
- Можете ли да дадете пример кога бавна заявка би повлияла негативно на цялостната производителност на една система?

## 2. Overview

Indexing и query optimization са ключови техники за подобряване на производителността при работа с големи обеми от данни. Индексирането позволява на системите бързо да намират и извличат необходимата информация, като създават допълнителни структури, които ускоряват търсенето. Оптимизацията на заявки (query optimization) се грижи заявките към базата данни да се изпълняват по възможно най-ефективния начин, като избира най-добрия план за изпълнение.

В съвременните AI системи и софтуерни приложения, където обработката на данни е критична, правилното използване на индекси и оптимизацията на заявки може да доведе до драстично намаляване на времето за отговор и по-добро използване на ресурсите. Това е особено важно при системи с голям брой потребители или при обработка на реалновремеви данни.

Тези техники са в основата на всеки мащабируем бекенд, независимо дали става дума за класически релационни бази данни, NoSQL решения или специализирани AI data stores. Без тях дори най-мощният хардуер може да се окаже недостатъчен.

## 3. Key Concepts

- **Index (Индекс)** – Специална структура от данни, която ускорява търсенето на записи в база данни. Може да се сравни с азбучен указател в книга.
- **Primary Index (Първичен индекс)** – Индекс, базиран на основния ключ на таблицата; гарантира уникалност и бърз достъп.
- **Secondary Index (Вторичен индекс)** – Индекс, създаден върху други колони за ускоряване на заявки, които не използват основния ключ.
- **Query Optimization (Оптимизация на заявки)** – Процесът на избор на най-ефективния начин за изпълнение на дадена заявка.
- **Execution Plan (План за изпълнение)** – Последователност от операции, които базата данни ще използва, за да изпълни заявката.
- **Full Table Scan (Пълно сканиране на таблица)** – Преглеждане на всички редове в таблицата; често е неефективно при големи обеми.
- **Cost-based Optimization (Оптимизация на база разходи)** – Оценка на различни планове за изпълнение според очакваните разходи (CPU, IO и др.).
- **Clustered vs. Non-clustered Index (Клъстериран и неклъстериран индекс)** – Клъстерираният индекс определя физическия ред на данните, докато неклъстерираният е отделна структура.

## 4. Step-by-step Learning Path

1. **Разберете основите на индексирането**
   - Фокус: Какво е индекс и защо се използва.
   - Практическа задача: Създайте проста таблица и добавете индекс върху една колона.
   - Въпроси: Какво се случва при заявка без индекс? Как индексът ускорява търсенето?

2. **Изследвайте различни типове индекси**
   - Фокус: Primary, secondary, clustered, non-clustered индекси.
   - Практическа задача: Създайте вторичен и неклъстериран индекс върху друга колона.
   - Въпроси: Кога бихте използвали вторичен индекс? Как клъстериран индекс влияе на физическото съхранение?

3. **Анализирайте плановете за изпълнение на заявки**
   - Фокус: Как базата данни избира план за изпълнение.
   - Практическа задача: Използвайте EXPLAIN (или еквивалент) за анализ на SQL заявка.
   - Въпроси: Какви операции виждате в execution plan-а? Какво означава full table scan?

4. **Оптимизирайте заявки с помощта на индекси**
   - Фокус: Как да промените заявка или структурата на индекса за по-добра производителност.
   - Практическа задача: Променете заявка така, че да използва съществуващ индекс.
   - Въпроси: Какво се промени в плана за изпълнение? Защо?

5. **Измерете и сравнете производителността**
   - Фокус: Как да измервате времето за изпълнение и ресурсите.
   - Практическа задача: Измерете времето за изпълнение на заявка с и без индекс.
   - Въпроси: Колко по-бърза е заявката с индекс? Има ли случаи, когато индексът не помага?

## 5. Examples

### Пример 1: Създаване на индекс в SQL

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50),
    email VARCHAR(100)
);

-- Създаване на индекс върху колоната email
CREATE INDEX idx_email ON users(email);
```

### Пример 2: Анализ на план за изпълнение

```sql
EXPLAIN SELECT * FROM users WHERE email = 'ivan@example.com';
```
*Изходът ще покаже дали се използва индекс или се прави пълно сканиране на таблицата.*

### Пример 3: Оптимизация на заявка

Първоначална заявка:
```sql
SELECT * FROM users WHERE LOWER(username) = 'petar';
```
*Тази заявка не използва индекс, ако индексът е върху username (без LOWER).*

Оптимизирана заявка:
```sql
SELECT * FROM users WHERE username = 'Petar';
```
*Тук индексът върху username ще бъде използван.*

## 6. Common Pitfalls

- **Създаване на твърде много индекси** – Всеки индекс забавя операциите по запис и заема място. Използвайте индекси само там, където наистина са нужни.
- **Използване на функции върху индексирани колони в WHERE** – Функции като LOWER или CAST могат да попречат на използването на индекс.
- **Пренебрегване на анализа на execution plan** – Не разчитайте само на интуиция; винаги проверявайте как реално се изпълнява заявката.
- **Липса на поддръжка (rebuild/reindex)** – Индексите се фрагментират с времето и трябва да се поддържат.
- **Неподходящ избор на колони за индексиране** – Индексирайте често използвани в WHERE или JOIN колони, а не всяка колона.

## 7. Short Retrieval Quiz

1. Какво е основното предназначение на индексите в базите данни?
2. Каква е разликата между primary и secondary индекс?
3. Какво представлява execution plan?
4. Какво е full table scan и кога се случва?
5. Защо не трябва да се използват функции върху индексирани колони в WHERE?
6. Какви са недостатъците на твърде много индекси?
7. Как можете да разберете дали дадена заявка използва индекс?

## 8. Quick Recap

- Индексите ускоряват търсенето и достъпа до данни.
- Primary и secondary индекси имат различни приложения.
- Query optimization избира най-ефективния план за изпълнение на заявка.
- Анализът на execution plan е критичен за разбирането на производителността.
- Индексирането има цена – повече индекси не винаги означава по-добра производителност.
- Функции върху индексирани колони могат да обезсмислят индексите.
- Редовната поддръжка на индексите е важна за дългосрочната ефективност.

## 9. Spaced Review Plan

| Време      | Преговори/Подсказки                                      |
|------------|----------------------------------------------------------|
| 1 ден      | Обяснете с примери какво е индекс и как ускорява заявки. |
| 3 дни      | Прегледайте разликите между primary и secondary индекси. |
| 1 седмица  | Анализирайте execution plan на примерна заявка.          |
| 1 месец    | Оптимизирайте реална заявка и измерете ефекта от индекс. |