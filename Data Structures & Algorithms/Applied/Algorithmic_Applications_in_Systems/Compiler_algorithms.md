# Compiler_algorithms

## 1. Activate Prior Knowledge
- Какво представлява компилаторът и каква е неговата роля в съвременните софтуерни системи?
- Как компилаторните алгоритми могат да подобрят ефективността на изпълнението на програми, особено в контекста на AI системи?
- Кои са основните стъпки в превода на изходен код към машинен код и как алгоритмите подпомагат всяка от тях?

## 2. Overview
Компилаторните алгоритми са сърцето на процеса, чрез който изходният код на програма се превръща в изпълним машинен код. Те осигуряват систематичен и ефективен начин за анализ, трансформация и оптимизация на кода. В контекста на AI системи и софтуерното инженерство, доброто разбиране на тези алгоритми е ключово за създаване на бързи, надеждни и адаптивни приложения.

Компилаторът се състои от няколко основни фази: лексикален анализ, синтактичен анализ, семантичен анализ, оптимизация и генериране на код. Всяка фаза използва специфични алгоритми, които гарантират правилното разбиране и обработка на програмния код. Разбирането на тези алгоритми позволява на инженерите да диагностицират проблеми, да създават по-добри инструменти и да оптимизират изпълнението на софтуера.

Освен това, компилаторните алгоритми са фундаментални за разработката на нови езици за програмиране, инструменти за статичен анализ и среди за разработка, които са широко използвани в AI и други области. Те също така подпомагат автоматизирането на трансформации и оптимизации, които са критични за производителността на съвременните системи.

## 3. Key Concepts
- **Лексикален анализ (Lexical Analysis)** – процесът на преобразуване на последователността от символи в програмния код в токени (лексеми). Можем да го сравним с разпознаване на думи в изречение.
- **Синтактичен анализ (Parsing)** – изграждане на дървовидна структура (parse tree) от токените, която отразява граматичната структура на програмата. Аналогично на разчленяване на изречение на подчинени части.
- **Семантичен анализ (Semantic Analysis)** – проверка на смисъла на програмата, например типова проверка и валидност на операциите. Подобно на проверка дали изречението има логичен смисъл.
- **Оптимизация на кода (Code Optimization)** – трансформация на междинния код с цел подобряване на ефективността без промяна на поведението. Представете си редактор, който прави текста по-кратък и по-ясен.
- **Генериране на код (Code Generation)** – превръщане на оптимизирания междинен код в машинен код, разбираем за хардуера.
- **Таблица на символите (Symbol Table)** – структура за съхранение на информация за идентификаторите в програмата, като имена, типове и обхвати.
- **Граматика (Grammar)** – формални правила, които описват синтаксиса на езика за програмиране.
- **Детерминиран краен автомат (DFA)** – математически модел, използван в лексикалния анализ за разпознаване на токени.

## 4. Step-by-step Learning Path
1. **Фокус:** Лексикален анализ и токенизация  
   **Задача:** Напишете прост лексикален анализатор за език с прости идентификатори и числа.  
   **Въпроси:** Какво е токен? Защо е важно да се раздели кода на токени?

2. **Фокус:** Синтактичен анализ и дърво на разбиране  
   **Задача:** Създайте парсер за изрази с оператори + и * с помощта на рекурсивен низходящ парсинг.  
   **Въпроси:** Какво е parse tree? Как парсерът използва граматиката?

3. **Фокус:** Семантичен анализ и типова проверка  
   **Задача:** Имплементирайте семантичен анализатор, който проверява съвместимостта на типовете в изразите.  
   **Въпроси:** Какво е семантичен анализ? Какво се случва при типова грешка?

4. **Фокус:** Оптимизация на междинен код  
   **Задача:** Направете проста оптимизация, като премахнете излишни операции (например премахване на умножение по 1).  
   **Въпроси:** Защо оптимизацията е важна? Какви видове оптимизации познавате?

5. **Фокус:** Генериране на машинен код  
   **Задача:** Превърнете прост израз в асемблерен код за избрана архитектура (например x86).  
   **Въпроси:** Какво е машинен код? Как компилаторът съпоставя изразите с инструкции?

## 5. Examples
### Пример 1: Лексикален анализ на израз
```python
import re

def lexer(code):
    token_specification = [
        ('NUMBER',   r'\d+'),
        ('PLUS',     r'\+'),
        ('MULT',     r'\*'),
        ('ID',       r'[A-Za-z]+'),
        ('SKIP',     r'[ \t]+'),
        ('MISMATCH', r'.'),
    ]
    tok_regex = '|'.join('(?P<%s>%s)' % pair for pair in token_specification)
    for mo in re.finditer(tok_regex, code):
        kind = mo.lastgroup
        value = mo.group()
        if kind == 'SKIP':
            continue
        elif kind == 'MISMATCH':
            raise RuntimeError(f'Unexpected character {value}')
        else:
            yield (kind, value)

code = "x + 42 * y"
print(list(lexer(code)))
```

### Пример 2: Рекурсивен низходящ парсер за изрази
```python
# Grammar: Expr -> Term { + Term }
# Term -> Factor { * Factor }
# Factor -> NUMBER | ID

class Parser:
    def __init__(self, tokens):
        self.tokens = tokens
        self.pos = 0

    def peek(self):
        return self.tokens[self.pos] if self.pos < len(self.tokens) else None

    def consume(self, expected_type):
        token = self.peek()
        if token and token[0] == expected_type:
            self.pos += 1
            return token
        else:
            raise SyntaxError(f'Expected {expected_type}')

    def factor(self):
        token = self.peek()
        if token[0] in ('NUMBER', 'ID'):
            self.consume(token[0])
            return token
        else:
            raise SyntaxError('Expected NUMBER or ID')

    def term(self):
        node = self.factor()
        while self.peek() and self.peek()[0] == 'MULT':
            self.consume('MULT')
            node = ('*', node, self.factor())
        return node

    def expr(self):
        node = self.term()
        while self.peek() and self.peek()[0] == 'PLUS':
            self.consume('PLUS')
            node = ('+', node, self.term())
        return node

tokens = [('ID', 'x'), ('PLUS', '+'), ('NUMBER', '42'), ('MULT', '*'), ('ID', 'y')]
parser = Parser(tokens)
ast = parser.expr()
print(ast)
```

## 6. Common Pitfalls
- **Пренебрегване на грешки в лексикалния анализ** – неоткриването на невалидни символи води до неочаквани грешки по-късно. Винаги валидирайте входа.
- **Неправилна граматика или рекурсия** – граматиката трябва да е без лява рекурсия за рекурсивен низходящ парсинг, иначе парсерът влиза в безкраен цикъл.
- **Пропускане на семантични проверки** – липсата на типова проверка може да доведе до генериране на некоректен код.
- **Оптимизации, които променят семантиката** – всяка оптимизация трябва да запази поведението на програмата.
- **Генериране на код без съобразяване с архитектурата** – машинният код трябва да отговаря на инструкциите и ограниченията на целевата платформа.

## 7. Short Retrieval Quiz
1. Каква е ролята на лексикалния анализатор в компилатора?  
2. Какво представлява parse tree?  
3. Защо е необходим семантичен анализ?  
4. Каква е целта на оптимизацията на кода?  
5. Как компилаторът използва таблицата на символите?  
6. Какво е детерминиран краен автомат и къде се използва?  
7. Какви са основните фази на компилация?

## 8. Quick Recap
- Компилаторните алгоритми превръщат изходен код в машинен код чрез няколко последователни фази.  
- Лексикалният анализ разделя кода на токени, а синтактичният анализ изгражда граматичната структура.  
- Семантичният анализ проверява смисъла и типовете в програмата.  
- Оптимизацията подобрява ефективността без да променя поведението.  
- Генерирането на код създава изпълним машинен код, съобразен с хардуера.  
- Всяка фаза използва специфични алгоритми и структури от данни като DFA и таблици на символите.  
- Разбирането и правилната имплементация на тези алгоритми е ключово за създаване на надеждни и ефективни компилатори.

## 9. Spaced Review Plan

| Време     | Промпт за преглед                                      |
|-----------|--------------------------------------------------------|
| 1 ден     | Опишете основните фази на компилация и тяхната роля.  |
| 3 дни     | Какво е лексикален анализ и как се реализира?          |
| 1 седмица | Обяснете как работи рекурсивният низходящ парсер.      |
| 1 месец   | Прегледайте типовете оптимизации и тяхното значение.   |