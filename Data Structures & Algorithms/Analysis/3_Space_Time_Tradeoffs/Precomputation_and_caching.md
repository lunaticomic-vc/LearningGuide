# Precomputation_and_caching

## 1. Activate Prior Knowledge
- Какво разбирате под термина „кеширане“ в контекста на софтуерни системи?
- Можете ли да дадете пример, когато предварителното изчисление (precomputation) може да ускори изпълнението на програма?
- Как мислите, как предварителното изчисление и кеширането могат да подобрят производителността на AI системи?

## 2. Overview
Precomputation и caching са техники за оптимизация, които целят да намалят времето за изпълнение на често повтарящи се изчисления или заявки. Precomputation означава изчисляване на резултати предварително, преди те да са необходими, докато caching съхранява вече изчислени резултати, за да бъдат използвани повторно.

Тези техники са особено важни в сложни системи, като AI модели и големи софтуерни приложения, където изчисленията могат да бъдат скъпи по време и ресурси. Те се интегрират в архитектурата на системата, за да подобрят отзивчивостта и ефективността.

В контекста на AI, precomputation може да включва предварително изчисляване на вектори или вероятности, а caching – съхранение на междинни резултати от модели или заявки към база данни. Това намалява повторното изчисление и ускорява обработката.

## 3. Key Concepts
- **Precomputation** – Изчисляване на резултати предварително, преди да са необходими, за да се спести време при изпълнение. Може да се сравни с подготовката на съставки преди готвене.
- **Caching** – Съхранение на вече изчислени резултати или данни, които могат да се използват повторно, за да се избегне повторно изчисление. Аналогично на запомняне на отговори на често задавани въпроси.
- **Cache hit** – Случай, когато търсената информация е намерена в кеша, което води до бърз достъп.
- **Cache miss** – Случай, когато търсената информация не е в кеша и трябва да се изчисли или извлече наново.
- **Memoization** – Специален вид кеширане, при който резултатите от функции се запаметяват, за да се избегне повторно изчисление при същите входни данни.
- **Latency** – Времето, необходимо за получаване на резултат, което precomputation и caching целят да намалят.
- **Trade-off между памет и време** – Използването на кеш и предварително изчисление изисква повече памет, но спестява време.

## 4. Step-by-step Learning Path
1. **Разберете основите на кеширането и precomputation**
   - Фокус: Какво представляват и защо са важни.
   - Задача: Напишете кратко резюме на разликите между precomputation и caching.
   - Въпроси: Как precomputation се различава от caching? Кога е по-подходящо да използваме едното или другото?

2. **Изучете техники за имплементация на кеширане**
   - Фокус: Различни видове кешове (памет, диск, разпределени).
   - Задача: Имплементирайте прост кеш в Python с речник (dictionary).
   - Въпроси: Какво е cache hit и cache miss? Какво се случва при cache miss?

3. **Прилагане на memoization в рекурсивни функции**
   - Фокус: Оптимизация на рекурсивни изчисления чрез кеширане.
   - Задача: Оптимизирайте рекурсивна функция за изчисляване на числата на Фибоначи с memoization.
   - Въпроси: Как memoization подобрява производителността? Как се различава от обикновено кеширане?

4. **Изследвайте precomputation в AI системи**
   - Фокус: Примери за предварително изчисляване в машинно обучение.
   - Задача: Използвайте предварително изчислени вектори за бързо търсене на сходство.
   - Въпроси: Как precomputation намалява латентността в AI приложения? Кои са ограниченията на този подход?

5. **Оптимизиране на кеша и управление на паметта**
   - Фокус: Стратегии за изчистване на кеша (LRU, TTL).
   - Задача: Добавете политика за изчистване на кеша към имплементацията си.
   - Въпроси: Какво е LRU? Защо е важно да се управлява размерът на кеша?

## 5. Examples

### Пример 1: Memoization на Фибоначи в Python
```python
def fib(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 2:
        return 1
    memo[n] = fib(n-1, memo) + fib(n-2, memo)
    return memo[n]

print(fib(50))  # Изчислява бързо, благодарение на кеширането
```

### Пример 2: Кеширане на резултати от API заявки
```python
cache = {}

def get_data_from_api(param):
    if param in cache:
        return cache[param]  # Cache hit
    result = expensive_api_call(param)
    cache[param] = result  # Cache miss - съхраняваме резултата
    return result
```

### Пример 3: Precomputation на матрица за бързи заявки
```python
# Предварително изчисляване на суми в двумерна матрица за бързи заявки
def precompute_sum_matrix(matrix):
    rows, cols = len(matrix), len(matrix[0])
    sum_matrix = [[0]*(cols+1) for _ in range(rows+1)]
    for i in range(1, rows+1):
        for j in range(1, cols+1):
            sum_matrix[i][j] = matrix[i-1][j-1] + sum_matrix[i-1][j] + sum_matrix[i][j-1] - sum_matrix[i-1][j-1]
    return sum_matrix

# Използване на sum_matrix за бързо изчисляване на сума в подматрица
```

## 6. Common Pitfalls
- **Прекомерно кеширане без контрол на размера** – води до изчерпване на паметта. Решение: използвайте политики за изчистване като LRU.
- **Кеширане на резултати, които бързо остаряват** – може да доведе до използване на неактуални данни. Решение: задайте TTL (time-to-live) или валидирайте кеша.
- **Игнориране на trade-off между памет и време** – кеширането не винаги е подходящо, ако паметта е ограничена.
- **Precomputation на твърде много данни** – може да отнеме прекалено много време и ресурси предварително.
- **Липса на синхронизация в многопоточни среди** – кешът може да се повреди без подходящи механизми за заключване.

## 7. Short Retrieval Quiz
1. Каква е основната разлика между precomputation и caching?
2. Какво означава cache hit и cache miss?
3. Как memoization подобрява производителността на рекурсивни функции?
4. Кои са рисковете при прекомерно кеширане?
5. Как precomputation може да бъде полезно в AI системи?
6. Какви политики за изчистване на кеша познавате?
7. Какво е trade-off между памет и време в контекста на кеширане?

## 8. Quick Recap
- Precomputation означава предварително изчисляване на резултати, за да се спести време по-късно.
- Caching съхранява вече изчислени резултати за повторна употреба.
- Memoization е специален вид кеширане, използван главно при функции.
- Кеширането подобрява производителността, но изисква управление на паметта.
- В AI системи precomputation и caching намаляват латентността и натоварването.
- Важно е да се избягват често срещани грешки като прекомерно кеширане и липса на валидиране.
- Управлението на кеша включва стратегии като LRU и TTL.

## 9. Spaced Review Plan

| Време след учене | Промпт за преглед                                      |
|------------------|-------------------------------------------------------|
| 1 ден            | Обяснете с прости думи какво е precomputation и caching. |
| 3 дни            | Дайте пример за memoization и обяснете защо е полезна.   |
| 1 седмица        | Опишете рисковете при кеширане и как да ги избегнем.     |
| 1 месец          | Как precomputation и caching могат да подобрят AI системи? |