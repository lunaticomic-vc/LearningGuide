# 18 - Storage engines InnoDB RocksDB etc

## 1. Activate Prior Knowledge

- Какви са основните разлики между релационни и нерелационни бази данни, които сте използвали досега?
- Кога за последно сте избирали между различни типове бази данни или конфигурирали тяхното поведение за дадено приложение?
- Как мислите, че изборът на storage engine може да повлияе на производителността на AI система или уеб приложение?

## 2. Overview

Storage engine-ите са сърцето на всяка база данни – те определят как се съхраняват, четат и модифицират данните на физическо ниво. В MySQL, MariaDB и други системи, storage engine-ът е компонентът, който реализира таблиците, индексите, транзакциите и механизмите за заключване.

Изборът на подходящ storage engine е критичен за постигане на желаната производителност, надеждност и функционалност. Например, InnoDB е стандартният engine за транзакционни операции, докато RocksDB е оптимизиран за големи обеми данни и специфични модели на достъп.

В контекста на AI системи и мащабируеми уеб приложения, правилната конфигурация на storage engine може да бъде разликата между бърза обработка на данни и сериозни забавяния или загуба на информация. Разбирането на принципите на работа на различните storage engines ви позволява да вземате информирани решения при проектиране и оптимизация на софтуерни системи.

## 3. Key Concepts

- Storage engine – Софтуерен компонент, който управлява физическото съхранение и достъп до данните в база данни. Може да се сравни с различни видове файлови системи за твърдия диск.
- InnoDB – Най-широко използваният storage engine в MySQL, поддържащ транзакции, външни ключове и ACID свойства.
- RocksDB – Storage engine, базиран на LSM-дерета (Log-Structured Merge Trees), оптимизиран за големи обеми данни и висока скорост на запис.
- ACID – Група свойства (Atomicity, Consistency, Isolation, Durability), гарантиращи надеждност на транзакциите.
- Index – Структура от данни, ускоряваща търсенето и достъпа до редове в таблица.
- Locking – Механизъм за контрол на конкурентния достъп до данни, предотвратяващ конфликти и загуба на информация.
- Row-based vs. Column-based storage – Два основни подхода за съхранение на данни: по редове (row) или по колони (column), всеки с различни предимства.

## 4. Step-by-step Learning Path

1. **Разберете ролята на storage engine-ите**
   - Фокус: Какво е storage engine и защо има различни видове.
   - Задача: Прочетете официалната документация на MySQL за storage engines.
   - Въпроси: Какво прави storage engine-ът? Може ли една база данни да използва няколко storage engines?

2. **Сравнете InnoDB и RocksDB**
   - Фокус: Основни разлики в архитектурата и поведението.
   - Задача: Направете таблица с плюсове и минуси на InnoDB и RocksDB.
   - Въпроси: Кой engine е по-подходящ за транзакционни операции? Кой е по-добър за големи обеми данни?

3. **Експериментирайте с избор на storage engine**
   - Фокус: Създаване на таблици с различни storage engines.
   - Задача: Създайте две таблици в MySQL – едната с InnoDB, другата с RocksDB (ако е наличен).
   - Въпроси: Как се задава storage engine при създаване на таблица? Как да проверите кой engine използва дадена таблица?

4. **Измерете производителността**
   - Фокус: Влияние на storage engine върху скоростта на запис и четене.
   - Задача: Напишете скрипт, който вмъква и чете 10,000 реда от двете таблици, и измерете времето.
   - Въпроси: Кой engine беше по-бърз при запис? А при четене?

5. **Изследвайте транзакционните възможности**
   - Фокус: Поддръжка на транзакции и заключвания.
   - Задача: Изпробвайте BEGIN, COMMIT и ROLLBACK върху таблица с InnoDB.
   - Въпроси: Какво се случва при грешка в транзакция? Какво става с данните при използване на non-transactional engine?

## 5. Examples

**Пример 1: Създаване на таблица с InnoDB**
```sql
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(100)
) ENGINE=InnoDB;
```

**Пример 2: Създаване на таблица с RocksDB (ако е наличен)**
```sql
CREATE TABLE logs (
    log_id BIGINT PRIMARY KEY,
    message TEXT
) ENGINE=ROCKSDB;
```

**Пример 3: Проверка на storage engine за таблица**
```sql
SHOW TABLE STATUS LIKE 'users';
```

## 6. Common Pitfalls

- Използване на non-transactional storage engine (например MyISAM) за критични данни – води до риск от загуба на информация при срив.
- Пренебрегване на специфичните настройки за всеки engine – неправилна конфигурация може да доведе до лоша производителност.
- Липса на индекси при големи таблици – независимо от storage engine, това води до бавни заявки.
- Смесване на storage engines в една и съща база без ясна причина – усложнява поддръжката и може да доведе до неочаквани проблеми.

## 7. Short Retrieval Quiz

1. Какво е storage engine и каква е неговата роля?
2. Кои са основните предимства на InnoDB?
3. За какъв тип натоварване е оптимизиран RocksDB?
4. Как се задава storage engine при създаване на таблица в MySQL?
5. Какви са рисковете при използване на non-transactional storage engine?
6. Какво означава ACID в контекста на storage engines?
7. Как може да проверите кой storage engine използва дадена таблица?

## 8. Quick Recap

- Storage engine-ите управляват начина, по който се съхраняват и обработват данните в база данни.
- InnoDB е стандартният engine за транзакционни операции и поддържа ACID свойства.
- RocksDB е подходящ за големи обеми данни и висока скорост на запис.
- Изборът на storage engine влияе директно върху производителността и надеждността на системата.
- Важно е да се конфигурират правилно параметрите на избрания engine.
- Транзакциите и заключванията се поддържат само от някои storage engines.
- Проверявайте и оптимизирайте индексите според нуждите на приложението.

## 9. Spaced Review Plan

| Review Time | Prompt                                               |
|-------------|-----------------------------------------------------|
| 1 day       | Обяснете разликата между InnoDB и RocksDB с примери.|
| 3 days      | Опишете какво е ACID и защо е важно за storage engine.|
| 1 week      | Дайте пример за проблем, причинен от неправилен избор на storage engine.|
| 1 month     | Обобщете кога бихте използвали RocksDB вместо InnoDB и обратно.|
