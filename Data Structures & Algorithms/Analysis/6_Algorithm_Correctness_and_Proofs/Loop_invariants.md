# Loop_invariants

## 1. Activate Prior Knowledge

- Какво представлява цикълът в програмирането и защо го използваме в софтуерните системи?
- Как мислите, че можем да гарантираме, че даден цикъл работи правилно във всяка итерация?
- В контекста на AI системи, как бихте проверили, че алгоритъмът за обучение или оптимизация не нарушава някакво важно условие по време на изпълнение?

## 2. Overview

Loop invariant (инвариант на цикъл) е условие или свойство, което остава вярно преди и след всяка итерация на цикъл. Той служи като формален инструмент за доказване на коректността на алгоритми, особено при сложни циклични структури. В софтуерното инженерство и разработката на AI системи, разбирането и използването на loop invariants помага да се гарантира, че алгоритмите не само завършват, но и постигат правилния резултат.

Loop invariants са ключови при формалната верификация на код, където се изисква математическа сигурност, че даден цикъл няма да наруши логиката на програмата. Те също така са полезни при оптимизация и дебъгване, защото позволяват на разработчика да разбере как се променят данните по време на изпълнение.

В по-широк контекст, loop invariants са част от техниките за доказване на коректност на алгоритми, които са фундаментални за надеждността на AI системи, където грешки в логиката могат да доведат до неправилни изводи или нежелано поведение.

## 3. Key Concepts

- **Loop Invariant** – Условие, което е вярно преди началото на цикъла, остава вярно след всяка итерация и помага да се докаже коректността на цикъла. Може да се мисли като „правило, което цикълът никога не нарушава“.
- **Initialization** – Проверка, че инвариантът е верен преди първата итерация на цикъла. Това гарантира, че основата на доказателството е стабилна.
- **Maintenance** – Демонстриране, че ако инвариантът е верен преди една итерация, той остава верен и след нея. Това е сърцето на доказателството.
- **Termination** – Условие, което показва кога цикълът спира, и как инвариантът заедно с това условие гарантират правилния краен резултат.
- **Formal Verification** – Процесът на използване на математически доказателства, включително loop invariants, за гарантиране на коректността на софтуер.

## 4. Step-by-step Learning Path

1. **Фокус:** Разберете какво е loop invariant и защо е важен.  
   **Задача:** Прочетете и анализирайте прост цикъл с числов сумиране. Определете какво би могъл да бъде инвариантът.  
   **Въпроси:** Какво трябва да е вярно преди и след всяка итерация? Защо това е важно?

2. **Фокус:** Научете се да формулирате loop invariants за различни видове цикли.  
   **Задача:** Изберете цикъл за намиране на максимален елемент в масив и формулирайте инварианта.  
   **Въпроси:** Какво свойство на частично обработените данни остава вярно? Как това помага за доказване на коректност?

3. **Фокус:** Практикувайте доказване на коректност чрез loop invariants.  
   **Задача:** Напишете кратък код с цикъл и формално докажете, че инвариантът се поддържа.  
   **Въпроси:** Как доказвате инициализацията и поддръжката? Какво означава това за крайния резултат?

4. **Фокус:** Прилагане на loop invariants в реални AI алгоритми (напр. итеративна оптимизация).  
   **Задача:** Анализирайте част от алгоритъм за градиентен спуск и идентифицирайте потенциален инвариант.  
   **Въпроси:** Какво условие трябва да остане вярно, за да се гарантира напредък? Какво би означавало нарушаването му?

5. **Фокус:** Използване на loop invariants за дебъгване и оптимизация.  
   **Задача:** Намерете грешка в цикъл, като проверите дали инвариантът се нарушава по време на изпълнение.  
   **Въпроси:** Какви симптоми показват нарушение на инварианта? Как бихте коригирали кода?

## 5. Examples

**Пример 1: Сумиране на елементи в масив**

```python
def sum_array(arr):
    total = 0
    i = 0
    # Loop invariant: total == sum(arr[0:i])
    while i < len(arr):
        total += arr[i]
        i += 1
    return total
```

Тук инвариантът гарантира, че променливата `total` винаги съдържа сумата на елементите до текущия индекс `i-1`.

**Пример 2: Намиране на максимален елемент**

```python
def find_max(arr):
    max_val = arr[0]
    i = 1
    # Loop invariant: max_val == max(arr[0:i])
    while i < len(arr):
        if arr[i] > max_val:
            max_val = arr[i]
        i += 1
    return max_val
```

Инвариантът показва, че `max_val` винаги е най-голямото число сред първите `i` елементи.

**Пример 3: Итеративен градиентен спуск (псевдокод)**

```
initialize weights w
# Loop invariant: loss(w) не се увеличава спрямо предишната итерация
while not converged:
    w = w - learning_rate * gradient(loss, w)
```

Тук инвариантът гарантира, че всяка итерация намалява или поне не увеличава функцията на загуба.

## 6. Common Pitfalls

- **Неправилна формулировка на инварианта** – ако инвариантът не е вярно формулиран, доказателството за коректност се проваля. Винаги проверявайте дали инвариантът е валиден преди и след итерация.
- **Пропускане на инициализацията** – много студенти забравят да докажат, че инвариантът е верен преди първата итерация.
- **Игнориране на терминалното условие** – инвариантът трябва да бъде свързан с условието за спиране, за да гарантира правилния краен резултат.
- **Смесване на инварианта с постусловие** – инвариантът е условие, което е вярно по време на цикъла, докато постусловието описва състоянието след приключване.
- **Пренебрегване на променливите, които влияят на инварианта** – уверете се, че всички променливи, участващи в инварианта, се актуализират правилно.

## 7. Short Retrieval Quiz

1. Какво е loop invariant и защо е важен?
2. Кои са трите основни стъпки при доказване на коректност с loop invariant?
3. Какво означава инициализация в контекста на loop invariant?
4. Как loop invariant помага при дебъгване на цикли?
5. Дайте пример за loop invariant в цикъл, който намира максимален елемент.
6. Какво е разликата между loop invariant и постусловие?
7. Защо е важно да свържем loop invariant с условието за спиране на цикъла?

## 8. Quick Recap

- Loop invariant е условие, което остава вярно преди и след всяка итерация на цикъл.
- Той служи за доказване на коректността на алгоритми и гарантира правилното им поведение.
- Основните стъпки са инициализация, поддръжка (maintenance) и терминaция.
- Loop invariants са полезни както за формална верификация, така и за практическо дебъгване.
- В AI системи те гарантират надеждност на итеративни алгоритми като градиентен спуск.
- Неправилната формулировка или пренебрегване на инварианта води до грешки и некоректен код.
- Свързването на инварианта с условието за спиране осигурява правилния краен резултат.

## 9. Spaced Review Plan

| Време след учене | Промпт за преглед                                      |
|-------------------|-------------------------------------------------------|
| 1 ден             | Опишете с прости думи какво е loop invariant.         |
| 3 дни             | Дайте пример за loop invariant в цикъл за сумиране.   |
| 1 седмица         | Обяснете трите стъпки на доказване с loop invariant.  |
| 1 месец           | Анализирайте как loop invariants помагат в AI алгоритми. |