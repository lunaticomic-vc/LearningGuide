# Approximation_and_probabilistic_structures

## 1. Activate Prior Knowledge
- Какво разбирате под термина "приближение" в контекста на алгоритми и изчисления?
- Как вероятностните модели могат да помогнат при обработката на големи данни или при вземане на решения в несигурна среда?
- Можете ли да дадете пример за ситуация в софтуерното инженерство, където точният резултат е труден или невъзможен за постигане, и приближение би било полезно?

## 2. Overview
Приближението и вероятностните структури са ключови инструменти в съвременните изчислителни системи, особено когато работим с големи обеми данни или при задачи, където точните решения са прекалено скъпи или невъзможни за изчисляване. Те позволяват да се получат "добри достатъчно" решения с по-малко ресурси, като време и памет.

В контекста на изкуствения интелект и софтуерното инженерство, тези методи се използват за ефективно моделиране на несигурност, компресиране на данни, бързо търсене и анализ. Например, вероятностните структури като Bloom филтри и Count-Min Sketch позволяват бързо проверяване на принадлежност или честота на елементи в потоци от данни, без да се съхраняват всички детайли.

Тези техники са основа за много системи за препоръки, обработка на естествен език, анализ на мрежов трафик и други области, където точността може да бъде балансирана с ефективността. Разбирането им е критично за създаване на мащабируеми и устойчиви решения.

## 3. Key Concepts
- **Approximation Algorithms** – Алгоритми, които намират решения близки до оптималното, но с по-ниска изчислителна сложност. Мислете за тях като за "бързи пътища" към добри решения, когато точният път е твърде дълъг.
- **Probabilistic Data Structures** – Структури от данни, които използват вероятностни методи за компресиране и бързо отговаряне на въпроси, като позволяват малка грешка. Пример: Bloom филтър, който казва дали елемент вероятно е в множество.
- **Bloom Filter** – Прост вероятностен филтър за проверка на принадлежност, който може да върне фалшиво положителен резултат, но никога фалшиво отрицателен. Аналогия: списък с "възможни членове", който не пропуска никого, но понякога включва и непознати.
- **Count-Min Sketch** – Структура, която приближено брои честотата на елементи в поток от данни с ограничена памет. Мислете за нея като за "бърз брояч" с компромис в точността.
- **Monte Carlo Methods** – Статистически техники, използващи случайни проби за приближено решаване на сложни задачи. Представете си ги като "експерименти", които ви дават добри оценки, без да изчисляват всичко точно.
- **Hash Functions** – Функции, които преобразуват данни в фиксиран размер, използвани в вероятностните структури за разпределяне и индексиране.

## 4. Step-by-step Learning Path
1. **Запознайте се с основите на приближаващите алгоритми**
   - Фокус: Разберете защо и кога се използват приближения.
   - Задача: Прочетете и анализирайте пример на приближаващ алгоритъм за проблема на раницата (Knapsack).
   - Въпроси: Какво е компромисът между точност и време? Кога приближението е по-добро от точния алгоритъм?

2. **Изучете Bloom филтри**
   - Фокус: Разберете структурата и работата на Bloom филтъра.
   - Задача: Имплементирайте прост Bloom филтър на Python или Java.
   - Въпроси: Какво означава фалшиво положителен резултат? Как се избира размерът на филтъра?

3. **Разгледайте Count-Min Sketch**
   - Фокус: Научете как се броят честоти приближено.
   - Задача: Създайте Count-Min Sketch и го използвайте за преброяване на елементи в поток.
   - Въпроси: Какви са ограниченията на Count-Min Sketch? Как влияят параметрите на точността?

4. **Практикувайте Monte Carlo методи**
   - Фокус: Разберете как случайността помага при приближения.
   - Задача: Напишете програма, която използва Monte Carlo метод за оценка на числото π.
   - Въпроси: Как се увеличава точността на оценката? Каква е ролята на броя проби?

5. **Интегрирайте знанията в реален проект**
   - Фокус: Изберете проблем, където точният подход е скъп, и приложете вероятностна структура.
   - Задача: Изградете система за проверка на дублирани записи с Bloom филтър.
   - Въпроси: Какви са предимствата и недостатъците на използвания подход? Как бихте подобрили системата?

## 5. Examples
### Пример 1: Bloom филтър за проверка на потребители
```python
from bitarray import bitarray
import mmh3

class BloomFilter:
    def __init__(self, size, hash_count):
        self.size = size
        self.hash_count = hash_count
        self.bit_array = bitarray(size)
        self.bit_array.setall(0)
    
    def add(self, item):
        for i in range(self.hash_count):
            digest = mmh3.hash(item, i) % self.size
            self.bit_array[digest] = 1
    
    def check(self, item):
        for i in range(self.hash_count):
            digest = mmh3.hash(item, i) % self.size
            if self.bit_array[digest] == 0:
                return False
        return True

bf = BloomFilter(5000, 7)
bf.add("student@example.com")
print(bf.check("student@example.com"))  # True
print(bf.check("other@example.com"))    # False или True (фалшиво положително)
```

### Пример 2: Monte Carlo оценка на π
```python
import random

def estimate_pi(num_samples):
    inside_circle = 0
    for _ in range(num_samples):
        x, y = random.uniform(-1,1), random.uniform(-1,1)
        if x*x + y*y <= 1:
            inside_circle += 1
    return 4 * inside_circle / num_samples

print(estimate_pi(100000))
```

### Пример 3: Count-Min Sketch за честота на думи
```python
import mmh3

class CountMinSketch:
    def __init__(self, width, depth):
        self.width = width
        self.depth = depth
        self.table = [[0]*width for _ in range(depth)]
    
    def add(self, item):
        for i in range(self.depth):
            index = mmh3.hash(item, i) % self.width
            self.table[i][index] += 1
    
    def count(self, item):
        min_count = float('inf')
        for i in range(self.depth):
            index = mmh3.hash(item, i) % self.width
            min_count = min(min_count, self.table[i][index])
        return min_count

cms = CountMinSketch(1000, 5)
cms.add("data")
cms.add("data")
cms.add("science")
print(cms.count("data"))    # Приблизително 2
print(cms.count("science")) # Приблизително 1
```

## 6. Common Pitfalls
- **Пренебрегване на параметрите на вероятностните структури** – Неправилно избрани размери и брой хеш функции водят до висока грешка или излишна памет.
- **Неразбиране на фалшивите положителни резултати** – Bloom филтър може да върне "да" за елемент, който не съществува, което трябва да се има предвид при критични приложения.
- **Опит за точни резултати с приближаващи методи** – Приближенията не гарантират точност, затова не трябва да се използват там, където грешката е неприемлива.
- **Игнориране на влиянието на случайността** – При Monte Carlo методите броят на пробите трябва да е достатъчно голям за надеждни резултати.
- **Липса на тестове и валидация** – Винаги валидирайте приближенията с реални данни и сравнете с точни методи, когато е възможно.

## 7. Short Retrieval Quiz
1. Какво представлява Bloom филтърът и каква грешка допуска?
2. Как Count-Min Sketch приближава честотата на елементи?
3. Защо приближаващите алгоритми са полезни в големи системи?
4. Как Monte Carlo методите използват случайността?
5. Какви са основните параметри, които влияят на точността на Bloom филтър?
6. Кога не трябва да използваме приближения?
7. Какво е фалшиво положително и фалшиво отрицателно в контекста на вероятностните структури?

## 8. Quick Recap
- Приближаващите алгоритми и вероятностните структури балансират точност и ефективност.
- Bloom филтърът е бърз и паметно ефективен за проверка на принадлежност с възможност за фалшиви положителни.
- Count-Min Sketch приближава честоти в потоци от данни с ограничена памет.
- Monte Carlo методите използват случайни проби за приближени изчисления.
- Изборът на параметри е критичен за точността и ресурсната ефективност.
- Приближенията не са подходящи за задачи, изискващи абсолютна точност.
- Винаги валидирайте и тествайте приближенията спрямо реални данни.

## 9. Spaced Review Plan

| Време след учене | Промпт за преглед                                      |
|-------------------|--------------------------------------------------------|
| 1 ден             | Обяснете как работи Bloom филтър и какви грешки допуска. |
| 3 дни             | Опишете основните предимства и ограничения на Count-Min Sketch. |
| 1 седмица         | Дайте пример за приложение на Monte Carlo метод в инженерна задача. |
| 1 месец           | Сравнете приближаващите алгоритми с точните и обсъдете кога да се използват. |