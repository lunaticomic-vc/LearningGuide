# Binary_Search_and_variants

## 1. Activate Prior Knowledge
- Какво представлява алгоритъмът за търсене и какви са неговите основни приложения в софтуерното инженерство и изкуствения интелект?
- Какви са предимствата и недостатъците на линейното търсене спрямо двоичното търсене?
- В кои ситуации двоичното търсене може да бъде приложено и какви предпоставки трябва да са изпълнени?

## 2. Overview
Двоичното търсене (Binary Search) е фундаментален алгоритъм за ефективно намиране на елемент в сортиран списък. Той използва стратегия „разделяй и владей“, като при всяка стъпка намалява обхвата на търсене наполовина, което води до логаритмична сложност – O(log n). Това го прави изключително подходящ за големи обеми данни, често срещани в системи за търсене, бази данни и AI модели, които изискват бърз достъп до информация.

В по-широк контекст двоичното търсене е основен инструмент в оптимизационни задачи, сортиране и при решаване на проблеми, където се търси граница или специфична стойност в подредени структури. Разбирането му и неговите варианти е ключово за разработването на ефективни алгоритми и системи, които работят с големи и структурирани данни.

В допълнение към класическото двоично търсене, съществуват различни негови варианти, като търсене на най-малък по-голям елемент, търсене в безкрайни масиви или адаптирани версии за специфични структури от данни. Тези варианти разширяват приложимостта на алгоритъма и позволяват решаването на по-сложни задачи.

## 3. Key Concepts
- **Sorted Array (Сортиран масив)** – Масив, в който елементите са подредени по нарастващ или намаляващ ред. Двоичното търсене изисква сортиран вход, за да работи правилно.
- **Divide and Conquer (Разделяй и владей)** – Методология, при която проблемът се разбива на по-малки подпроблеми, решават се поотделно и след това се комбинират. Двоичното търсене използва този подход, като намалява търсенето наполовина.
- **Midpoint (Средна точка)** – Индексът, който разделя текущия интервал на две части. В двоичното търсене се използва за сравнение с търсения елемент.
- **Logarithmic Time Complexity (Логаритмична времева сложност)** – Означава, че времето за изпълнение расте много бавно спрямо размера на входа, което прави двоичното търсене много ефективно.
- **Variants (Варианти)** – Модификации на класическото двоично търсене, които решават специфични задачи, например намиране на първото или последното срещане на елемент, търсене в ротационен масив и др.

## 4. Step-by-step Learning Path
1. **Разбиране на класическото двоично търсене**
   - Фокус: Принцип на работа и изисквания (сортиран масив).
   - Задача: Имплементирайте двоично търсене за намиране на елемент в сортиран масив.
   - Въпроси: Какво се случва, ако масивът не е сортиран? Как се определя средната точка?

2. **Изучаване на границите на търсене**
   - Фокус: Намиране на първото или последното срещане на даден елемент.
   - Задача: Модифицирайте алгоритъма да връща индекса на първото срещане на елемент.
   - Въпроси: Как се променя логиката при търсене на граница? Защо е важно да не спираме при първото намерено съвпадение?

3. **Варианти на двоично търсене**
   - Фокус: Търсене в ротационен масив, търсене на най-малък по-голям елемент.
   - Задача: Имплементирайте двоично търсене в ротационен масив.
   - Въпроси: Какво е ротационен масив? Как се адаптира алгоритъмът?

4. **Приложения в реални системи**
   - Фокус: Използване на двоично търсене в бази данни, AI и сортиране.
   - Задача: Анализирайте как двоичното търсене подобрява производителността на конкретна система.
   - Въпроси: Защо двоичното търсене е предпочитано в големи бази данни? Как се използва в AI?

## 5. Examples

### Пример 1: Класическо двоично търсене
```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

### Пример 2: Намиране на първото срещане на елемент
```python
def first_occurrence(arr, target):
    left, right = 0, len(arr) - 1
    result = -1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            result = mid
            right = mid - 1  # търсим по-ляво
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return result
```

### Пример 3: Търсене в ротационен масив
```python
def search_rotated(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        if arr[left] <= arr[mid]:
            if arr[left] <= target < arr[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if arr[mid] < target <= arr[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
```

## 6. Common Pitfalls
- **Несортиран входен масив** – Двоичното търсене изисква сортиран масив, в противен случай резултатите са некоректни.
- **Грешно изчисляване на средната точка** – Използването на `(left + right) // 2` може да доведе до препълване при много големи индекси; по-безопасно е `left + (right - left) // 2`.
- **Пропускане на границите при търсене на първо/последно срещане** – Ако не се актуализират правилно границите, алгоритъмът може да не намери точната позиция.
- **Забравяне за крайния случай** – Уверете се, че условието за прекратяване на цикъла е коректно, за да избегнете безкрайни цикли.
- **Неправилна работа с ротационни масиви** – Логиката за определяне коя част е сортирана трябва да е ясна и коректна.

## 7. Short Retrieval Quiz
1. Какво е основното изискване за входните данни при двоично търсене?
2. Каква е времевата сложност на двоичното търсене?
3. Как се променя алгоритъмът, ако искаме да намерим първото срещане на елемент?
4. Какво представлява ротационен масив?
5. Защо е важно да използваме безопасно изчисляване на средната точка?
6. Как двоичното търсене подобрява производителността в големи бази данни?
7. Какво се случва, ако приложим двоично търсене върху несортиран масив?

## 8. Quick Recap
- Двоичното търсене е ефективен алгоритъм за намиране на елемент в сортиран масив с времева сложност O(log n).
- Основният принцип е разделяне на търсения интервал наполовина чрез средна точка.
- Вариантите на алгоритъма позволяват намиране на първо/последно срещане и работа с ротационни масиви.
- Важно е да се гарантира, че входните данни са сортирани и да се използва безопасно изчисляване на средната точка.
- Двоичното търсене е широко използвано в бази данни, AI системи и оптимизационни задачи.

## 9. Spaced Review Plan

| Време       | Промпт за преглед                                      |
|-------------|--------------------------------------------------------|
| 1 ден       | Обяснете принципа на двоичното търсене и защо изисква сортиран масив. |
| 3 дни       | Имплементирайте двоично търсене и модифицирайте за първо срещане.     |
| 1 седмица   | Опишете как се адаптира двоичното търсене за ротационен масив.         |
| 1 месец     | Приложете двоично търсене в реален проект или задача, свързана с големи данни. |