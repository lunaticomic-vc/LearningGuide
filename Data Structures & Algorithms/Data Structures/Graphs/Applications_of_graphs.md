# Applications_of_graphs

## 1. Activate Prior Knowledge
- Какви видове данни или проблеми могат да бъдат представени чрез връзки между обекти?
- В кои ситуации в софтуерното инженерство сте срещали структури, които наподобяват мрежи или мрежови връзки?
- Как графите могат да помогнат при моделиране и решаване на задачи в изкуствения интелект, например при препоръчителни системи или оптимизация?

## 2. Overview
Графите са фундаментални структури за моделиране на взаимовръзки между обекти. Те се състоят от върхове (nodes) и ребра (edges), които свързват тези върхове. В контекста на софтуерното инженерство и изкуствения интелект, графите позволяват представяне на сложни системи като социални мрежи, пътища за навигация, зависимости между модули и много други.

Приложенията на графите са изключително широки – от анализ на данни и оптимизация до моделиране на знания и препоръчителни системи. Те са ключови за разбиране на структурите в данните и за разработване на алгоритми, които могат да извличат скрити зависимости и да намират оптимални решения.

В по-широката система графите често служат като основа за изграждане на по-сложни модели и алгоритми, като например графови невронни мрежи (Graph Neural Networks) в AI, които разширяват възможностите за анализ на структурирани данни.

## 3. Key Concepts
- **Graph (Граф)** – структура, съставена от върхове и ребра, която моделира връзки между обекти. Може да се представи като карта на пътища между градове.
- **Vertex (Връх)** – основен елемент на графа, който представлява обект или състояние.
- **Edge (Ребро)** – връзка между два върха, която може да бъде насочена или ненасочена, подобно на път, свързващ два града.
- **Directed Graph (Насочен граф)** – граф, в който ребрата имат посока, например връзка „следва“ в последователност от действия.
- **Weighted Graph (Тежък граф)** – граф, в който ребрата имат тегло, което може да представлява разстояние, време или разход.
- **Adjacency List (Списък на съседство)** – ефективен начин за съхранение на граф, където всеки връх пази списък с върхове, към които е свързан.
- **Path (Път)** – последователност от върхове, свързани чрез ребра, подобно на маршрут през градове.
- **Cycle (Цикъл)** – път, който започва и завършва в един и същ връх.
- **Graph Traversal (Обхождане на граф)** – процес на посещение на върхове по определен ред (DFS, BFS).

## 4. Step-by-step Learning Path
1. **Запознаване с основните структури на графа**  
   - Фокус: Разбиране на върхове, ребра, насочени и ненасочени графи.  
   - Задача: Нарисувайте граф, който моделира социална мрежа с поне 5 върха и различни типове връзки.  
   - Въпроси: Какво е разликата между насочен и ненасочен граф? Какво представлява реброто?

2. **Имплементиране на граф с adjacency list**  
   - Фокус: Създаване на ефективна структура за съхранение на граф.  
   - Задача: Напишете код, който създава граф и добавя върхове и ребра.  
   - Въпроси: Как adjacency list подобрява паметната ефективност спрямо adjacency matrix?

3. **Обхождане на граф (DFS и BFS)**  
   - Фокус: Разбиране на алгоритмите за обхождане и тяхното приложение.  
   - Задача: Имплементирайте DFS и BFS и ги използвайте за намиране на път между два върха.  
   - Въпроси: Кога е по-подходящ DFS, а кога BFS? Какво представлява рекурсията в DFS?

4. **Приложение на графи в реални задачи**  
   - Фокус: Използване на графи за моделиране на препоръчителни системи или навигация.  
   - Задача: Моделирайте малка препоръчителна система, базирана на сходство между потребители.  
   - Въпроси: Как графите помагат за откриване на скрити връзки? Какво е значение на тежестите в ребрата?

5. **Изучаване на алгоритми за оптимизация върху графи**  
   - Фокус: Алгоритми като Dijkstra, A*, минимално покриващо дърво.  
   - Задача: Имплементирайте алгоритъм за намиране на най-кратък път в тежък граф.  
   - Въпроси: Какво е хевристика в A*? Защо Dijkstra работи само с неотрицателни тегла?

## 5. Examples
### Пример 1: Социална мрежа
```python
graph = {
    'Alice': ['Bob', 'Claire'],
    'Bob': ['Alice', 'Dan'],
    'Claire': ['Alice', 'Erin'],
    'Dan': ['Bob'],
    'Erin': ['Claire']
}
```
Тук върховете са хора, а ребрата – приятелски връзки.

### Пример 2: Намиране на най-кратък път (Dijkstra)
```python
import heapq

def dijkstra(graph, start):
    queue = [(0, start)]
    distances = {vertex: float('inf') for vertex in graph}
    distances[start] = 0

    while queue:
        current_distance, current_vertex = heapq.heappop(queue)
        if current_distance > distances[current_vertex]:
            continue
        for neighbor, weight in graph[current_vertex].items():
            distance = current_distance + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(queue, (distance, neighbor))
    return distances

graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'A': 1, 'C': 2, 'D': 5},
    'C': {'A': 4, 'B': 2, 'D': 1},
    'D': {'B': 5, 'C': 1}
}

print(dijkstra(graph, 'A'))
```

### Пример 3: Препоръчителна система с граф
Потребителите са върхове, ребрата – сходство между тях. Търсим най-близките съседи, за да препоръчаме продукти.

## 6. Common Pitfalls
- **Бъркане между насочени и ненасочени графи** – важно е да се знае дали връзките имат посока, тъй като това влияе на алгоритмите.
- **Използване на adjacency matrix при големи и разредени графи** – води до излишна паметна консумация.
- **Пропускане на цикли при обхождане** – без проверка за вече посетени върхове може да се получи безкраен цикъл.
- **Неправилно третиране на тежести в алгоритми** – например Dijkstra не работи с отрицателни тегла.
- **Недооценяване на сложността на алгоритмите** – някои алгоритми не са подходящи за много големи графи.

## 7. Short Retrieval Quiz
1. Какво представлява реброто в граф?
2. Каква е разликата между насочен и ненасочен граф?
3. Какво е adjacency list и защо е полезен?
4. Кога използваме BFS вместо DFS?
5. Защо Dijkstra не може да се използва с отрицателни тегла?
6. Какво е цикъл в граф?
7. Как графите се използват в препоръчителни системи?

## 8. Quick Recap
- Графите моделират обекти и връзките между тях чрез върхове и ребра.
- Могат да бъдат насочени или ненасочени, тежки или нетежки.
- Адекватното съхранение (adjacency list) и обхождане (DFS, BFS) са основни умения.
- Графите са основа за множество алгоритми за оптимизация и анализ.
- Приложенията им включват социални мрежи, навигация, препоръчителни системи и AI.
- Важно е да се избягват често срещани грешки като неправилна обработка на цикли и тежести.
- Разбирането на графите е ключово за решаване на комплексни инженерни задачи.

## 9. Spaced Review Plan

| Време след изучаване | Промпт за преговор                                  |
|----------------------|----------------------------------------------------|
| 1 ден                | Опишете основните компоненти на граф и техните роли. |
| 3 дни                | Обяснете разликата между насочен и ненасочен граф. |
| 1 седмица            | Имплементирайте прост алгоритъм за обхождане на граф. |
| 1 месец              | Приложете граф за решаване на реален проблем (напр. препоръчителна система). |