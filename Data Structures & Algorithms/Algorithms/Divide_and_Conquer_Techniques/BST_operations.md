# BST_operations

## 1. Activate Prior Knowledge

- Какво представлява двоичното дърво и какви са основните му свойства?
- Какви са предимствата на подреждането на данни в структури като двоично дърво в контекста на търсене и сортиране?
- Как бихте използвали двоично дърво за ефективно съхранение и извличане на данни в софтуерна система, например в AI алгоритъм за бързо търсене?

## 2. Overview

Двоичното дърво за търсене (Binary Search Tree, BST) е фундаментална структура от данни, която позволява ефективно съхранение, търсене, добавяне и премахване на елементи. Всяка възлова точка (възел) в BST съдържа ключ, като всички ключове в лявото поддърво са по-малки, а в дясното – по-големи от ключа на възела. Тази подредба осигурява логика за бързо локализиране на елементи.

В контекста на софтуерното инженерство и AI системите, BST се използва за реализиране на структури като речници, индекси и приоритетни опашки. Той служи като основа за по-сложни структури като AVL дървета и червено-черни дървета, които гарантират балансираност и оптимална производителност.

Разбирането на основните операции върху BST – търсене, вмъкване, изтриване и обхождане – е ключово за изграждането на ефективни алгоритми и системи, които работят с големи обеми данни. Тези операции са не само теоретично важни, но и практически приложими в реални проекти.

## 3. Key Concepts

- **Binary Search Tree (BST)** – Дървовидна структура, където всеки възел има максимум два наследника, а ключовете в лявото поддърво са по-малки, а в дясното – по-големи от ключа на възела. Мислете за BST като за сортиран списък, организиран дървовидно за бърз достъп.

- **Node (Възел)** – Елемент от дървото, съдържащ ключ и препратки към ляв и десен наследник. Аналогия: възел е като страница в книга, която съдържа информация и указатели към други страници.

- **Insertion (Вмъкване)** – Процес на добавяне на нов ключ в дървото, запазвайки свойството на BST. Представете си, че поставяте нова книга на правилното място в библиотека, сортирана по азбучен ред.

- **Search (Търсене)** – Операция за намиране на възел с определен ключ, използвайки свойството на BST за бързо прескачане към ляво или дясно поддърво.

- **Deletion (Изтриване)** – Премахване на възел от дървото, като се запазва структурата и свойството на BST. Това е по-сложна операция, защото трябва да се реорганизират връзките между възлите.

- **Traversal (Обхождане)** – Последователно посещение на всички възли в дървото. Основните видове са in-order (симетрично), pre-order (предварително) и post-order (следобходно). In-order обхождането връща ключовете в сортиран ред.

## 4. Step-by-step Learning Path

1. **Фокус:** Разбиране на структурата на BST и свойството на подредба.  
   **Задача:** Нарисувайте ръчно BST с 7 различни ключа и проверете дали свойството е спазено.  
   **Въпроси:** Какво гарантира, че търсенето е по-бързо от линейното? Какво се случва, ако ключовете не са уникални?

2. **Фокус:** Имплементация на търсене в BST.  
   **Задача:** Напишете функция, която приема ключ и връща дали съществува в дървото.  
   **Въпроси:** Какво е времето за изпълнение на търсенето в най-добрия и най-лошия случай?

3. **Фокус:** Вмъкване на нови възли.  
   **Задача:** Добавете функция за вмъкване на нов ключ в BST, като запазите свойството на дървото.  
   **Въпроси:** Какво се случва, ако вмъкнете ключ, който вече съществува? Как да се справите с това?

4. **Фокус:** Изтриване на възел с различни случаи (лист, възел с един наследник, възел с два наследника).  
   **Задача:** Имплементирайте функция за изтриване на възел и тествайте с различни случаи.  
   **Въпроси:** Как се избира заместител при изтриване на възел с два наследника? Защо?

5. **Фокус:** Обхождане на дървото.  
   **Задача:** Реализирайте in-order, pre-order и post-order обхождания и изведете ключовете.  
   **Въпроси:** Кое обхождане връща ключовете в сортиран ред? Защо е полезно това?

## 5. Examples

### Пример 1: Търсене в BST (Python)

```python
class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None

def search(root, key):
    if root is None or root.key == key:
        return root
    if key < root.key:
        return search(root.left, key)
    else:
        return search(root.right, key)

# Примерна употреба
root = Node(10)
root.left = Node(5)
root.right = Node(15)

result = search(root, 15)
print("Found" if result else "Not found")
```

### Пример 2: Вмъкване в BST (Python)

```python
def insert(root, key):
    if root is None:
        return Node(key)
    if key < root.key:
        root.left = insert(root.left, key)
    elif key > root.key:
        root.right = insert(root.right, key)
    return root

# Добавяне на ключ 12
root = insert(root, 12)
```

### Пример 3: Изтриване на възел с два наследника (Python)

```python
def minValueNode(node):
    current = node
    while current.left is not None:
        current = current.left
    return current

def deleteNode(root, key):
    if root is None:
        return root
    if key < root.key:
        root.left = deleteNode(root.left, key)
    elif key > root.key:
        root.right = deleteNode(root.right, key)
    else:
        # Възел с един или без наследници
        if root.left is None:
            return root.right
        elif root.right is None:
            return root.left
        # Възел с два наследника
        temp = minValueNode(root.right)
        root.key = temp.key
        root.right = deleteNode(root.right, temp.key)
    return root
```

## 6. Common Pitfalls

- **Неспазване на BST свойството при вмъкване или изтриване** – Винаги проверявайте дали новите връзки запазват правилото за подредба, за да избегнете загуба на данни или неправилна структура.

- **Изтриване на възел с два наследника без правилен заместител** – Използвайте най-малкия ключ в дясното поддърво (in-order successor) или най-големия в лявото (in-order predecessor), за да запазите BST свойството.

- **Игнориране на балансиране** – BST може да деградира до линейна структура (като свързан списък), ако данните са в сортиран ред. За критични системи използвайте балансирани дървета (AVL, Red-Black).

- **Пропускане на базовите случаи в рекурсията** – Винаги проверявайте за `None` възли, за да избегнете runtime грешки.

## 7. Short Retrieval Quiz

1. Какво е основното свойство, което дефинира BST?
2. Каква е разликата между in-order и pre-order обхождане?
3. Как се намира заместител при изтриване на възел с два наследника?
4. Какво е времето за търсене в BST в най-добрия случай?
5. Какво се случва, ако вмъкнете вече съществуващ ключ?
6. Защо е важно да се балансира BST?
7. Какво представлява възел в контекста на BST?

## 8. Quick Recap

- BST е двоично дърво, където лявото поддърво съдържа по-малки, а дясното – по-големи ключове.
- Основните операции са търсене, вмъкване, изтриване и обхождане.
- Изтриването на възел с два наследника изисква намиране на in-order successor или predecessor.
- Обхождането in-order връща ключовете в сортиран ред.
- BST може да деградира до линейна структура без балансиране.
- Правилната имплементация изисква внимание към базовите случаи и запазване на свойствата на дървото.
- BST е основа за по-сложни структури и широко приложение в софтуерното инженерство и AI.

## 9. Spaced Review Plan

| Време след учене | Промпт за преглед                                  |
|-------------------|---------------------------------------------------|
| 1 ден             | Опишете свойството на BST и основните операции.  |
| 3 дни             | Напишете псевдокод за търсене и вмъкване в BST.  |
| 1 седмица         | Обяснете как се изтрива възел с два наследника.  |
| 1 месец           | Сравнете BST с балансирани дървета и приложението им.|