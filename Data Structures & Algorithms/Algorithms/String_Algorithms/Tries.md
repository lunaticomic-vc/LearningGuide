# Tries

## 1. Activate Prior Knowledge
- Какви структури от данни използвате за бързо търсене на текст или низове в софтуерни системи?
- Как бихте организирали речник с хиляди думи, за да проверявате дали дадена дума съществува, без да търсите линейно?
- В контекста на AI, как може структура като trie да ускори обработката на естествен език или автодовършване?

## 2. Overview
Trie (произнася се "трай", от "retrieval") е специализирана дървовидна структура от данни, оптимизирана за съхранение и търсене на низове, като думи или префикси. Тя позволява много бързо търсене, добавяне и изтриване на низове с времева сложност, зависеща главно от дължината на низа, а не от броя на елементите в структурата.

В по-широк контекст, trie се използва в системи за обработка на естествен език, автодовършване, речници, компресия на данни и други приложения, където е важно бързото намиране на префикси или пълни низове. Тази структура е особено полезна при големи набори от данни, където традиционните хеш таблици или сортирани масиви могат да бъдат по-бавни или по-скъпи по отношение на паметта.

Разбирането и прилагането на trie е ключово за софтуерни инженери и специалисти по AI, тъй като тя осигурява ефективен начин за индексиране и търсене, което е основа за много алгоритми и системи, включително системи за препоръки и анализ на текст.

## 3. Key Concepts
- **Trie (Prefix Tree)** – Дървовидна структура, в която всеки възел представлява символ от низ. Пътят от корена до даден възел формира префикс на съхранените низове. Мислете за trie като за дърво на думите, където всеки клон добавя буква.
- **Node (Възел)** – Основна единица в trie, съдържаща препратки към деца (следващи символи) и често флаг дали пътят до този възел е пълна дума.
- **Prefix (Префикс)** – Начална част от дума. Trie е оптимизиран за търсене на префикси, което го прави полезен за автодовършване.
- **End of Word Marker** – Специален индикатор във възел, който показва, че пътят до този възел съставя валидна дума.
- **Space-Time Tradeoff** – Trie използва повече памет в сравнение с хеш таблици, но предлага по-бързо търсене на префикси и по-ефективно сортиране.
- **Sparse vs Dense Trie** – Sparse trie използва по-малко памет, но може да е по-бавен; dense trie използва масиви за деца, което ускорява достъпа, но увеличава паметта.

## 4. Step-by-step Learning Path
1. **Запознайте се с базовата структура на trie**
   - Фокус: Разберете как възлите са свързани и как се съхраняват символите.
   - Задача: Нарисувайте trie за думите "cat", "car", "dog".
   - Въпроси: Какво представлява пътят от корена до възел? Как се отбелязва край на дума?

2. **Имплементирайте добавяне на дума в trie**
   - Фокус: Научете как да добавяте низове символ по символ.
   - Задача: Напишете функция за добавяне на дума на избран език.
   - Въпроси: Какво се случва, ако част от думата вече съществува в trie?

3. **Реализирайте търсене на дума и префикс**
   - Фокус: Разберете разликата между пълно търсене и търсене на префикс.
   - Задача: Напишете функции за проверка дали дума или префикс съществуват.
   - Въпроси: Как trie ускорява търсенето на префикси спрямо линейно търсене?

4. **Добавете функция за изтриване на дума**
   - Фокус: Управление на паметта и коректно премахване на възли.
   - Задача: Имплементирайте изтриване на дума, като премахвате ненужни възли.
   - Въпроси: Кога трябва да се изтрие възел? Как да избегнете изтриване на общи префикси?

5. **Оптимизирайте trie за памет и скорост**
   - Фокус: Изследвайте техники като компресирани trie (radix tree).
   - Задача: Сравнете паметната консумация на обикновен trie и компресиран trie.
   - Въпроси: Как компресираните trie намаляват дълбочината на дървото?

## 5. Examples

### Пример 1: Създаване на trie и добавяне на думи (Python)
```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end_of_word = True

    def search(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end_of_word

# Използване
trie = Trie()
trie.insert("cat")
trie.insert("car")
print(trie.search("cat"))  # True
print(trie.search("cap"))  # False
```

### Пример 2: Търсене на префикс
```python
def starts_with(self, prefix):
    node = self.root
    for char in prefix:
        if char not in node.children:
            return False
        node = node.children[char]
    return True

# Добавете метода към класа Trie и тествайте:
print(trie.starts_with("ca"))  # True
print(trie.starts_with("do"))  # False
```

### Пример 3: Автодовършване на думи с даден префикс
```python
def autocomplete(self, prefix):
    def dfs(node, path, results):
        if node.is_end_of_word:
            results.append(path)
        for char, child in node.children.items():
            dfs(child, path + char, results)

    node = self.root
    for char in prefix:
        if char not in node.children:
            return []
        node = node.children[char]

    results = []
    dfs(node, prefix, results)
    return results

# Тествайте автодовършване:
trie.insert("carpet")
trie.insert("carbon")
print(trie.autocomplete("car"))  # ['car', 'carpet', 'carbon']
```

## 6. Common Pitfalls
- **Пренебрегване на край на дума** – Забравяне да се отбележи, че даден възел е край на дума, води до грешки при търсене.
- **Използване на неподходящи структури за деца** – Например, използване на списък вместо речник или масив може да забави достъпа.
- **Неоптимално управление на паметта при изтриване** – Изтриване на възли, които са част от други думи, може да повреди trie.
- **Игнориране на Unicode и различни символни множества** – Трябва да се предвиди поддръжка на различни азбуки и символи.
- **Прекомерна дълбочина на дървото** – При много дълги низове trie може да стане много дълбок, което забавя операциите.

## 7. Short Retrieval Quiz
1. Какво представлява trie и за какво се използва?
2. Как trie съхранява думите и техните префикси?
3. Как се отбелязва край на дума в trie?
4. Каква е основната разлика между търсене на дума и търсене на префикс в trie?
5. Какви са предимствата на trie спрямо хеш таблици при търсене на префикси?
6. Какво трябва да се внимава при изтриване на дума от trie?
7. Как trie може да бъде използван в системи за автодовършване?

## 8. Quick Recap
- Trie е дървовидна структура, оптимизирана за съхранение и търсене на низове.
- Всеки възел съответства на символ, а пътят от корена до възел формира префикс.
- Край на дума се отбелязва с флаг във възела.
- Trie осигурява бързо търсене на думи и префикси с времева сложност O(m), където m е дължината на низа.
- Използва се широко в AI и софтуер за обработка на текст, автодовършване и речници.
- Внимание при управление на паметта и правилно отбелязване на край на дума.
- Оптимизации като компресирани trie намаляват паметната консумация и подобряват производителността.

## 9. Spaced Review Plan

| Време след учене | Промпт за преговор                                      |
|-------------------|--------------------------------------------------------|
| 1 ден             | Обяснете какво е trie и защо е полезен за търсене.     |
| 3 дни             | Опишете процеса на добавяне и търсене на дума в trie.  |
| 1 седмица         | Имплементирайте функция за автодовършване с trie.      |
| 1 месец           | Сравнете trie с други структури за търсене на низове.  |