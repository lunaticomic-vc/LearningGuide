# Skip_Lists

## 1. Activate Prior Knowledge
- Какви са основните структури от данни за бързо търсене и сортиране, които познавате (например дървета, хеш таблици)?
- Как бихте оптимизирали търсенето в голямо сортирано множество данни при ограничени ресурси?
- В контекста на AI системи, какви структури от данни могат да подпомогнат бързото индексиране и извличане на информация?

## 2. Overview
Skip Lists са вероятностна структура от данни, която поддържа сортиран списък с множество нива на препратки, позволяващи бързо търсене, вмъкване и изтриване. Те са алтернатива на балансираните дървета, като предлагат опростена имплементация и ефективност, близка до O(log n) за основните операции.

В по-широк контекст, Skip Lists се използват в бази данни, кеширащи системи и други софтуерни системи, където е необходима динамична и бърза обработка на сортирани данни. Те са особено полезни в разпределени системи и AI приложения, където бързото индексиране и достъп до данни е критично.

Тяхната вероятностна природа означава, че структурата се адаптира динамично, без нужда от сложни ребалансирания, което ги прави практични за реални инженерни задачи.

## 3. Key Concepts
- **Level (Ниво)** – Всяка нода в Skip List има няколко нива на препратки, като по-високите нива "прескачат" множество елементи, подобно на експресни спирки в метрото.
- **Tower (Кула)** – Представете си всяка нода като кула от елементи, където всяко ниво е един етаж с препратка към следващата нода на това ниво.
- **Probability p (Вероятност p)** – Вероятността, с която се решава колко нива ще има една нода, обикновено 0.5, което осигурява балансирана структура в дългосрочен план.
- **Search Path (Път на търсене)** – Пътят, по който алгоритъмът преминава през нивата, за да намери или вмъкне елемент, започвайки от най-високото ниво и спускайки се надолу.
- **Expected Time Complexity (Очаквана времева сложност)** – Благодарение на вероятностната структура, операциите се изпълняват средно за O(log n), където n е броят на елементите.

## 4. Step-by-step Learning Path
1. **Разберете основната структура на свързан списък**
   - Фокус: Прегледайте как работи еднопосочен свързан списък.
   - Задача: Имплементирайте прост свързан списък на избран език.
   - Въпроси: Как се осъществява търсене в свързан списък? Каква е времевата му сложност?

2. **Запознайте се с концепцията за множество нива в списъка**
   - Фокус: Разберете как се добавят "прескачания" (skip pointers) на различни нива.
   - Задача: Добавете второ ниво на препратки към вашия списък.
   - Въпроси: Какво е предимството на второто ниво? Как се променя времето за търсене?

3. **Изучете вероятностното разпределение за нивата**
   - Фокус: Разберете как се определя броят на нивата за всяка нода.
   - Задача: Имплементирайте функция, която случайно определя нивото на нова нода според вероятност p.
   - Въпроси: Защо се използва вероятност? Как влияе p на структурата?

4. **Имплементирайте основните операции: търсене, вмъкване, изтриване**
   - Фокус: Научете алгоритмите за тези операции в Skip List.
   - Задача: Имплементирайте търсене, вмъкване и изтриване.
   - Въпроси: Как се поддържа структурата след вмъкване? Как се намира позицията за вмъкване?

5. **Тествайте и анализирайте производителността**
   - Фокус: Измерете времето за операции при различен брой елементи.
   - Задача: Създайте тестови случаи с големи списъци и анализирайте резултатите.
   - Въпроси: Как се държи времето за търсене при растеж на n? Какво се случва при различни стойности на p?

## 5. Examples

### Пример 1: Търсене в Skip List
```python
def search(skiplist, target):
    current = skiplist.head
    for level in reversed(range(skiplist.max_level)):
        while current.forward[level] and current.forward[level].value < target:
            current = current.forward[level]
    current = current.forward[0]
    if current and current.value == target:
        return True
    return False
```

### Пример 2: Вмъкване на елемент
```python
def insert(skiplist, value):
    update = [None] * skiplist.max_level
    current = skiplist.head
    for level in reversed(range(skiplist.max_level)):
        while current.forward[level] and current.forward[level].value < value:
            current = current.forward[level]
        update[level] = current
    level = random_level()
    new_node = Node(value, level)
    for i in range(level):
        new_node.forward[i] = update[i].forward[i]
        update[i].forward[i] = new_node
```

### Пример 3: Изтриване на елемент
```python
def delete(skiplist, value):
    update = [None] * skiplist.max_level
    current = skiplist.head
    for level in reversed(range(skiplist.max_level)):
        while current.forward[level] and current.forward[level].value < value:
            current = current.forward[level]
        update[level] = current
    current = current.forward[0]
    if current and current.value == value:
        for i in range(len(current.forward)):
            update[i].forward[i] = current.forward[i]
```

## 6. Common Pitfalls
- **Неправилно определяне на нивото на нова нода** – Ако не се използва правилна вероятностна функция, структурата може да се изкриви и да загуби ефективността си.
- **Пропускане на актуализацията на всички нива при вмъкване или изтриване** – Водещо до счупване на препратките и грешки при търсене.
- **Използване на фиксиран брой нива без адаптация към размера на списъка** – Това може да доведе до лоша производителност при големи данни.
- **Необработване на гранични случаи (например вмъкване в празен списък)** – Винаги тествайте начални и крайни случаи.
- **Пренебрегване на вероятностната природа при анализ на сложността** – Времето е очаквано, а не в най-лошия случай.

## 7. Short Retrieval Quiz
1. Каква е основната идея зад структурата Skip List?
2. Как се определя нивото на нова нода?
3. Каква е очакваната времева сложност за търсене в Skip List?
4. Какво представлява "tower" в контекста на Skip List?
5. Защо Skip Lists са предпочитани пред балансирани дървета в някои приложения?
6. Как се актуализират препратките при вмъкване на нов елемент?
7. Какво може да се случи, ако не обновим всички нива при изтриване?

## 8. Quick Recap
- Skip Lists са вероятностна структура от данни за бързо търсене, вмъкване и изтриване.
- Те използват множество нива на препратки, които "прескачат" елементи, подобно на експресни спирки.
- Нивото на всяка нода се определя случайно според вероятност p, което осигурява баланс.
- Основните операции имат очаквана времева сложност O(log n).
- Skip Lists са по-прости за имплементация от балансирани дървета и са подходящи за динамични и разпределени системи.
- Важно е да се поддържат всички нива при вмъкване и изтриване, за да се запази коректността.
- Вероятностният подход позволява адаптивност и ефективност без сложни ребалансирания.

## 9. Spaced Review Plan

| Време след учене | Промпт за преглед                                    |
|-------------------|-----------------------------------------------------|
| 1 ден             | Обяснете какво представлява Skip List и как работи.|
| 3 дни             | Опишете процеса на вмъкване на елемент в Skip List.|
| 1 седмица         | Как се определя нивото на нова нода и защо?         |
| 1 месец           | Сравнете Skip Lists с балансирани дървета по сложност и практичност. |