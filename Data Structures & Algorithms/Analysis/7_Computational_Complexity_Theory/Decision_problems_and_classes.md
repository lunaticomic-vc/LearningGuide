# Decision_problems_and_classes

## 1. Activate Prior Knowledge

- Какво представлява проблемът в контекста на алгоритмите и софтуерните системи?
- Как бихте дефинирали решаемост на дадена задача и защо е важно да знаем дали даден проблем е решим?
- Как мислите, че класифицирането на проблеми може да помогне при проектиране на ефективни алгоритми в изкуствения интелект?

## 2. Overview

Решаващите проблеми (decision problems) са въпроси, на които отговорът е двоичен: „да“ или „не“. Те са фундаментални в теорията на изчислимостта и сложността, защото позволяват формализиране на задачи, които компютърните системи трябва да решават. В контекста на изкуствения интелект и софтуерното инженерство, разбирането на решаващите проблеми помага да се определи дали дадена задача е алгоритмично решима и с каква ефективност.

Класовете на решаващите проблеми групират задачи според техните изчислителни характеристики, като например времева или пространствена сложност. Това позволява на инженери и изследователи да оценят ресурсите, необходими за решаване на дадена задача, и да изберат подходящи алгоритми или техники. Например, класът P съдържа проблеми, които могат да се решат за полиномиално време, докато NP включва проблеми, за които решенията могат да се проверят бързо.

Разбирането на тези концепции е ключово за проектиране на ефективни AI системи, където често се сблъскваме с големи и сложни проблеми, които изискват оптимизация и компромиси между точност и време за изпълнение.

## 3. Key Concepts

- **Decision Problem** – Задача, която изисква отговор „да“ или „не“. Например: „Съществува ли път между две върхове в граф?“ Аналогия: въпрос с двоичен отговор, като „Да ли е числото просто?“
- **Class P** – Множество от решаващи проблеми, които могат да се решат за полиномиално време от детерминиран алгоритъм. Мислете за тях като за „бързо решими“ задачи.
- **Class NP** – Множество от решаващи проблеми, за които дадено решение може да се провери за полиномиално време от детерминиран алгоритъм. Аналогия: „лесно е да провериш дали отговорът е верен, но не винаги е лесно да го намериш“.
- **NP-complete** – Подклас на NP, който съдържа най-трудните проблеми в NP. Ако някой NP-complete проблем се реши за полиномиално време, тогава всички NP проблеми могат да се решат бързо.
- **Reducibility (Редуциране)** – Процесът на преобразуване на един проблем в друг, за да се докаже сложността или решаемостта на първия чрез втория.
- **Decidability (Решаемост)** – Свойството на проблем да има алгоритъм, който винаги дава отговор „да“ или „не“ за всяка входна стойност.

## 4. Step-by-step Learning Path

1. **Фокус:** Разберете какво е решаващ проблем.  
   **Задача:** Опишете 3 примера за решаващи проблеми от ежедневието или AI.  
   **Въпроси:** Какво отличава решаващите проблеми от други типове задачи? Защо отговорът е винаги „да“ или „не“?

2. **Фокус:** Изучете класовете P и NP.  
   **Задача:** Намерете и анализирайте алгоритъм за проблем в клас P (например проверка за простота на число).  
   **Въпроси:** Какво означава полиномиално време? Какво е разликата между решаване и проверка на решение?

3. **Фокус:** Разберете концепцията за NP-complete проблеми.  
   **Задача:** Изследвайте класически NP-complete проблем (например SAT) и опитайте да формулирате неговия решаващ въпрос.  
   **Въпроси:** Защо NP-complete проблемите са важни? Какво би означавало, ако намерим бърз алгоритъм за някой от тях?

4. **Фокус:** Практикувайте редуциране между проблеми.  
   **Задача:** Опитайте да редуцирате един прост проблем към друг (например от 3-SAT към CLIQUE).  
   **Въпроси:** Какво е целта на редуцирането? Как помага то при доказване на сложността?

5. **Фокус:** Изследвайте решаемостта и неразрешимите проблеми.  
   **Задача:** Прочетете за проблема на спиране (Halting Problem) и обяснете защо е неразрешим.  
   **Въпроси:** Какво означава, че проблем е неразрешим? Как това влияе на проектирането на софтуер?

## 5. Examples

- **Пример 1: Проверка за свързаност в граф**  
Въпрос: „Има ли път между върхове A и B?“  
Това е решаващ проблем, който може да се реши с алгоритъм за обхождане на граф (DFS или BFS) за полиномиално време, т.е. принадлежи към клас P.

```python
def is_connected(graph, start, end):
    visited = set()
    stack = [start]
    while stack:
        node = stack.pop()
        if node == end:
            return True
        if node not in visited:
            visited.add(node)
            stack.extend(graph[node] - visited)
    return False
```

- **Пример 2: SAT (Boolean satisfiability problem)**  
Въпрос: „Съществува ли присвояване на променливите, което прави булевата формула вярна?“  
SAT е класически NP-complete проблем.

- **Пример 3: Проблем на спиране**  
Въпрос: „Ще спре ли дадена програма при даден вход?“  
Това е неразрешим проблем, доказан от Алан Тюринг.

## 6. Common Pitfalls

- **Смесване на решаване и проверка на решение** – Много студенти бъркат, че ако решение може да се провери бързо, то автоматично може и да се намери бързо (NP ≠ P е отворен въпрос).
- **Пренебрегване на времевата сложност** – Да се счита, че всеки алгоритъм, който работи, е „добър“. Важно е да се разбере как расте времето с размера на входа.
- **Неправилно прилагане на редуциране** – Редуцирането трябва да бъде полиномиално и коректно, иначе доказателството за сложност е невалидно.
- **Игнориране на неразрешимите проблеми** – Не всички задачи могат да се решат алгоритмично; това трябва да се има предвид при проектиране на системи.

## 7. Short Retrieval Quiz

1. Какво е решаващ проблем?
2. Какво означава, че проблем принадлежи към клас P?
3. Какво е NP-complete?
4. Какво представлява редуцирането между два проблема?
5. Защо проблемът на спиране е важен в теорията на изчислимостта?
6. Каква е разликата между решаване и проверка на решение?
7. Какво означава, че проблем е неразрешим?

## 8. Quick Recap

- Решаващите проблеми са въпроси с отговор „да“ или „не“.
- Класовете P и NP описват времевата сложност на решаване и проверка на решения.
- NP-complete проблемите са най-трудните в NP и служат като ключови точки за изследване на сложността.
- Редуцирането е инструмент за доказване на сложността и свързаността между проблеми.
- Не всички проблеми са решими; някои са фундаментално неразрешими.
- Разбирането на тези концепции е критично за проектиране на ефективни алгоритми и AI системи.
- Внимателното разграничаване между решаване и проверка предотвратява логически грешки.

## 9. Spaced Review Plan

| Време след изучаване | Промпт за преговор                                      |
|----------------------|--------------------------------------------------------|
| 1 ден                | Опишете с прости думи какво е решаващ проблем.         |
| 3 дни                | Обяснете разликата между класовете P и NP.             |
| 1 седмица            | Дайте пример за NP-complete проблем и защо е важен.    |
| 1 месец              | Прегледайте концепцията за редуциране и неразрешимост. |