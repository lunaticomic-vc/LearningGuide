# Balanced_trees_(AVL,_Red-Black,_Splay,_Treap)

## 1. Activate Prior Knowledge

- Какво представлява двоичното дърво за търсене (BST) и защо балансът му е важен за ефективността?
- Какви проблеми могат да възникнат при използването на небалансирани дървета в системи за търсене и индексиране?
- Как бихте използвали балансирани дървета в контекста на бази данни или AI системи за бързо търсене и актуализация на данни?

## 2. Overview

Балансните дървета са специални структури от данни, които поддържат височината на дървото минимална, за да осигурят бърз достъп, вмъкване и изтриване на елементи. Те са усъвършенствани версии на двоичните дървета за търсене (BST), които предотвратяват деградацията на дървото в линейна структура, което би довело до лоша производителност.

В софтуерното инженерство и AI системите, където обработката на големи обеми данни и бързото търсене са критични, балансните дървета осигуряват гарантирана логаритмична сложност за основните операции. Това ги прави незаменими при изграждането на индекси, кеширащи механизми и динамични множества.

Четири популярни вида балансни дървета са AVL, Red-Black, Splay и Treap. Всеки от тях използва различни техники за поддържане на баланс и има специфични предимства и компромиси, които ги правят подходящи за различни приложения.

## 3. Key Concepts

- **AVL Tree** – Дърво, което поддържа баланс чрез ограничаване на разликата във височината на лявото и дясното поддърво до максимум 1. Представете си го като строго балансиран стълб, който никога не се накланя твърде много на една страна.
- **Red-Black Tree** – Дърво, което използва цветове (червено и черно) за маркиране на възлите и поддържа баланс чрез правила за оцветяване. Може да се сравни с регулирането на трафика, където цветовете контролират движението, за да се избегнат задръствания.
- **Splay Tree** – Самобалансиращо се дърво, което при всяка операция премествa наскоро използвания възел към корена чрез серия от ротации. Мислете за него като за адаптивна структура, която оптимизира достъпа до често използвани елементи.
- **Treap** – Комбинация от двоично дърво за търсене и куп (heap), където всеки възел има ключ и приоритет. Представлява случайна структура, която балансира дървото чрез приоритети, подобно на игра на карти, където редът се определя и от стойностите, и от случайността.

## 4. Step-by-step Learning Path

1. **Разберете основите на двоичното дърво за търсене (BST)**
   - Фокус: Прегледайте структурата и операциите на BST.
   - Задача: Имплементирайте базова BST с операции за търсене, вмъкване и изтриване.
   - Въпроси: Каква е времевата сложност на операциите в BST? Какво се случва при небалансирано дърво?

2. **Изучете AVL дърветата**
   - Фокус: Разберете как се поддържа баланс чрез височинни разлики и ротации.
   - Задача: Добавете балансиращи ротации към вашата BST имплементация.
   - Въпроси: Какви са видовете ротации в AVL? Как се изчислява баланс факторът?

3. **Запознайте се с Red-Black дърветата**
   - Фокус: Научете правилата за оцветяване и как те поддържат баланс.
   - Задача: Имплементирайте вмъкване в Red-Black дърво с корекции на цветовете.
   - Въпроси: Какви са основните свойства на Red-Black дървото? Какво гарантира логаритмичната височина?

4. **Изследвайте Splay дърветата**
   - Фокус: Разберете механизма на splay операцията и нейните амортизирани свойства.
   - Задача: Имплементирайте splay операцията и наблюдавайте поведението при последователни търсения.
   - Въпроси: Какво е амортизирана сложност? Защо splay дърветата са полезни при локална повторяемост?

5. **Научете за Treap структурата**
   - Фокус: Разберете как приоритетите се използват за баланс и как се комбинират BST и heap свойства.
   - Задача: Имплементирайте Treap с произволно генерирани приоритети.
   - Въпроси: Как Treap гарантира баланс? Как се извършват ротациите?

6. **Сравнете и анализирайте различните балансни дървета**
   - Фокус: Разгледайте предимствата и недостатъците на всяка структура.
   - Задача: Направете кратък анализ на производителността и приложимостта в различни сценарии.
   - Въпроси: Кога бихте избрали Splay пред Red-Black? Какъв е trade-off между строгостта на баланса и сложността на операциите?

## 5. Examples

### Пример 1: Вмъкване в AVL дърво (Python)

```python
class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.height = 1

def get_height(node):
    return node.height if node else 0

def right_rotate(y):
    x = y.left
    T2 = x.right
    x.right = y
    y.left = T2
    y.height = max(get_height(y.left), get_height(y.right)) + 1
    x.height = max(get_height(x.left), get_height(x.right)) + 1
    return x

def left_rotate(x):
    y = x.right
    T2 = y.left
    y.left = x
    x.right = T2
    x.height = max(get_height(x.left), get_height(x.right)) + 1
    y.height = max(get_height(y.left), get_height(y.right)) + 1
    return y

def get_balance(node):
    return get_height(node.left) - get_height(node.right) if node else 0

def insert(node, key):
    if not node:
        return Node(key)
    if key < node.key:
        node.left = insert(node.left, key)
    else:
        node.right = insert(node.right, key)

    node.height = 1 + max(get_height(node.left), get_height(node.right))
    balance = get_balance(node)

    # Left Left
    if balance > 1 and key < node.left.key:
        return right_rotate(node)
    # Right Right
    if balance < -1 and key > node.right.key:
        return left_rotate(node)
    # Left Right
    if balance > 1 and key > node.left.key:
        node.left = left_rotate(node.left)
        return right_rotate(node)
    # Right Left
    if balance < -1 and key < node.right.key:
        node.right = right_rotate(node.right)
        return left_rotate(node)

    return node
```

### Пример 2: Основни операции в Red-Black дърво (псевдокод)

```plaintext
Insert(node):
    1. Вмъкни node като в обикновено BST и оцвети node в червено.
    2. Ако родителят на node е черен, приключи.
    3. Ако родителят е червен, направи корекции чрез пренасочване на цветове и ротации, за да се запазят свойствата на Red-Black дървото.
```

### Пример 3: Splay операция (псевдокод)

```plaintext
Splay(node):
    while node is not root:
        if node.parent is root:
            Rotate(node)
        else if node and parent are both left or both right children:
            Rotate(parent)
            Rotate(node)
        else:
            Rotate(node)
            Rotate(node)
```

## 6. Common Pitfalls

- **Пренебрегване на баланс фактори или цветови правила** – В AVL и Red-Black дърветата пропускането на правилата води до нарушаване на баланса и деградация на производителността.
- **Неправилна имплементация на ротации** – Грешки при ротациите могат да разрушат структурата на дървото и да доведат до загуба на данни.
- **Игнориране на амортизирана сложност при Splay дърветата** – Много студенти очакват винаги бързи операции, но амортизираното време означава, че някои операции могат да са по-бавни.
- **Неправилно генериране или използване на приоритети в Treap** – Ако приоритетите не са случайни или уникални, балансът не се гарантира.
- **Липса на тестване с гранични случаи** – Например, вмъкване на вече съществуващи ключове или изтриване на невалидни възли.

## 7. Short Retrieval Quiz

1. Какво е баланс фактор в AVL дърво?
2. Кои са основните свойства на Red-Black дървото?
3. Какво представлява splay операцията и каква е нейната цел?
4. Как Treap комбинира двоично дърво за търсене и heap?
5. Кога е подходящо да използваме Splay дърво вместо Red-Black?
6. Какви са основните видове ротации в балансните дървета?
7. Какъв е основният недостатък на небалансираните BST?

## 8. Quick Recap

- Балансните дървета поддържат височина, близка до логаритмична, за бързи операции.
- AVL дърветата са строго балансирани чрез височинни разлики и ротации.
- Red-Black дърветата използват цветове и правила за баланс с по-лека строгост.
- Splay дърветата адаптират структурата си според честотата на достъп.
- Treap комбинира BST и heap свойства чрез случайни приоритети.
- Правилната имплементация на ротации и баланс е критична за коректност.
- Изборът на подходящ тип балансно дърво зависи от конкретните изисквания и модели на достъп.

## 9. Spaced Review Plan

| Време след изучаване | Промпт за преговор                                      |
|----------------------|--------------------------------------------------------|
| 1 ден                | Обяснете основните разлики между AVL и Red-Black дърветата. |
| 3 дни                | Опишете как работи splay операцията и кога е полезна.  |
| 1 седмица            | Имплементирайте проста версия на Treap и обяснете баланса. |
| 1 месец              | Сравнете всички четири вида балансни дървета и приложението им в реални системи. |