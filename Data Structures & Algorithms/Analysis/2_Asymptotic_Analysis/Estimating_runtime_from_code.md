# Estimating_runtime_from_code

## 1. Activate Prior Knowledge

- Какво представлява времето за изпълнение (runtime) на една програма и защо е важно да го оценяваме?
- Как смятате, че сложността на алгоритмите влияе върху производителността на софтуерните системи, особено в AI приложения?
- Можете ли да дадете пример за ситуация, в която неправилната оценка на времето за изпълнение може да доведе до сериозни проблеми?

## 2. Overview

Оценяването на времето за изпълнение на код е ключов процес в разработката на софтуер и системи за изкуствен интелект. Той позволява на инженерите да предвидят колко време ще отнеме дадена задача или алгоритъм, което е критично за оптимизация, планиране на ресурси и подобряване на потребителското изживяване.

В контекста на AI системите, където обработката на големи обеми данни и сложни изчисления е често срещана, правилната оценка на runtime-а помага да се избегнат забавяния и да се гарантира, че системата работи ефективно. Този процес включва анализ на кода, разбиране на алгоритмичната сложност и измерване на реалното време за изпълнение.

Освен това, оценката на runtime-а е част от по-широкия процес на профилиране и оптимизация на софтуера, който подпомага идентифицирането на „тесни места“ и подобряването на цялостната производителност на системата.

## 3. Key Concepts

- **Runtime (Време за изпълнение)** – Количеството време, необходимо на дадена програма или алгоритъм да завърши изпълнението си. Може да се измерва в секунди, милисекунди или други времеви единици.
- **Algorithmic Complexity (Алгоритмична сложност)** – Мярка за това как времето за изпълнение на алгоритъм се увеличава спрямо размера на входните данни, често изразена чрез нотация Big O.
- **Profiling (Профилиране)** – Процес на измерване на изпълнението на програмата, за да се идентифицират части от кода, които отнемат най-много време.
- **Big O Notation (Нотация Big O)** – Абстрактен начин за описване на горната граница на времето за изпълнение на алгоритъм, помагащ да се предскаже поведението при големи входни данни.
- **Empirical Measurement (Емпирично измерване)** – Практическо измерване на времето за изпълнение чрез изпълнение на кода и записване на резултатите, за разлика от теоретичния анализ.
- **Bottleneck (Тесно място)** – Част от кода или алгоритъма, която ограничава цялостната производителност на системата, подобна на най-тясната част на бутилка, която ограничава потока.

## 4. Step-by-step Learning Path

1. **Фокус:** Разберете основите на времето за изпълнение и алгоритмичната сложност.  
   **Задача:** Изследвайте времето за изпълнение на прост алгоритъм за сортиране (напр. bubble sort) с различни размери на входа.  
   **Въпроси:** Как времето за изпълнение се променя с увеличаване на размера на входа? Какво означава Big O за този алгоритъм?

2. **Фокус:** Научете как да използвате инструменти за профилиране.  
   **Задача:** Профилирайте малка Python програма с `cProfile` или друг профайлър и идентифицирайте най-бавните функции.  
   **Въпроси:** Коя част от кода отнема най-много време? Как бихте оптимизирали тази част?

3. **Фокус:** Практикувайте емпирично измерване на runtime.  
   **Задача:** Измерете времето за изпълнение на функция с помощта на `time` модула в Python за различни входни данни.  
   **Въпроси:** Какви са предимствата и недостатъците на емпиричното измерване спрямо теоретичния анализ?

4. **Фокус:** Анализирайте и оптимизирайте код въз основа на runtime оценки.  
   **Задача:** Оптимизирайте даден код, като промените алгоритъма или структурата на данните и измерете разликата във времето за изпълнение.  
   **Въпроси:** Какви промени доведоха до най-голямо подобрение? Какви компромиси направихте?

## 5. Examples

### Пример 1: Оценка на runtime на сортиране

```python
import time

def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]

arr = [64, 34, 25, 12, 22, 11, 90]
start = time.time()
bubble_sort(arr)
end = time.time()
print(f"Bubble sort runtime: {end - start:.6f} seconds")
```

### Пример 2: Профилиране на Python код

```python
import cProfile

def compute():
    total = 0
    for i in range(10000):
        for j in range(100):
            total += i * j
    return total

cProfile.run('compute()')
```

### Пример 3: Оптимизация чрез избор на по-бърз алгоритъм

```python
import time

def bubble_sort(arr):
    # същият код като по-горе

def python_sort(arr):
    return sorted(arr)

arr = [64, 34, 25, 12, 22, 11, 90] * 1000

start = time.time()
bubble_sort(arr.copy())
end = time.time()
print(f"Bubble sort runtime: {end - start:.6f} seconds")

start = time.time()
python_sort(arr.copy())
end = time.time()
print(f"Python built-in sort runtime: {end - start:.6f} seconds")
```

## 6. Common Pitfalls

- **Игнориране на входните данни:** Оценката на runtime без да се вземе предвид размера и характера на входа може да доведе до погрешни изводи. Винаги тествайте с различни входни размери.
- **Фокусиране само върху теоретичната сложност:** Теоретичният анализ не винаги отразява реалното време за изпълнение, което зависи и от хардуера, езика за програмиране и други фактори.
- **Преждевременна оптимизация:** Оптимизиране без измерване и профилиране може да усложни кода без реална полза.
- **Пренебрегване на профилирането:** Без инструменти за профилиране е трудно да се идентифицират истинските тесни места.
- **Измерване на време без повторения:** Еднократни измервания могат да бъдат подвеждащи поради случайни фактори като натоварване на системата.

## 7. Short Retrieval Quiz

1. Какво означава runtime на една програма?  
2. Какво представлява алгоритмичната сложност и защо е важна?  
3. Какво е профилиране и как помага при оптимизацията?  
4. Какво представлява нотацията Big O?  
5. Защо е важно да се измерва runtime с различни размери на входа?  
6. Какво е „тесно място“ в контекста на изпълнението на код?  
7. Какви са рисковете от преждевременна оптимизация?

## 8. Quick Recap

- Runtime е времето, необходимо за изпълнение на код и е критично за ефективността на системите.  
- Алгоритмичната сложност описва как времето за изпълнение расте с размера на входните данни.  
- Профилирането позволява да се идентифицират най-бавните части на кода за целенасочена оптимизация.  
- Емпиричното измерване на runtime допълва теоретичния анализ и дава реални данни.  
- Оптимизацията трябва да бъде базирана на данни от измервания и профилиране, а не на предположения.  
- Тесните места ограничават цялостната производителност и трябва да се адресират при оптимизация.  
- Измерванията трябва да се правят многократно и с различни входни данни за надеждни резултати.

## 9. Spaced Review Plan

| Време след учене | Промпт за преглед                                      |
|-------------------|-------------------------------------------------------|
| 1 ден             | Обяснете какво е runtime и защо е важно да се оценява.|
| 3 дни             | Опишете разликата между теоретичен анализ и емпирично измерване на runtime.|
| 1 седмица         | Дайте пример за използване на профилиране при оптимизация на код.|
| 1 месец           | Прегледайте основните грешки при оценка на runtime и как да ги избегнете.|