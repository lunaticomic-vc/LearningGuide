# Abstract_Data_Types_(ADTs)

## 1. Activate Prior Knowledge
- Какво представлява структурата на данни и как тя подпомага организацията на информацията в софтуерните системи?
- Какви са основните разлики между конкретна имплементация на структура от данни и абстрактен модел?
- В какъв контекст при изграждането на AI системи бихме използвали абстрактни типове данни за по-ефективна обработка на информация?

## 2. Overview
Абстрактните типове данни (ADT) са концептуални модели, които дефинират поведение и операции върху данни, без да специфицират конкретната им имплементация. Те служат като мост между логическото разбиране на структурата и нейното физическо реализиране в паметта на компютъра.

В по-широк контекст на софтуерното инженерство и изкуствения интелект, ADT позволяват модулност и капсулация, което улеснява повторната употреба, тестването и поддръжката на кода. Те осигуряват начин да се мисли за данните и операциите върху тях като за единна абстракция, която може да бъде реализирана по различни начини според нуждите на конкретното приложение.

Значението на ADT се проявява най-вече при сложни системи, където ясното разделение между интерфейс и имплементация намалява сложността и повишава надеждността. В AI системи, например, използването на ADT като стекове, опашки или графи позволява ефективна организация на алгоритми за търсене, планиране и обработка на данни.

## 3. Key Concepts
- **Абстракция** – Процесът на отделяне на съществените характеристики на данните от детайлите на тяхната реализация. Мислете за това като за чертеж на сграда, без да се показват всички строителни материали.
- **Интерфейс** – Набор от операции, които ADT предоставя, без да разкрива как са реализирани. Аналогия: дистанционно управление на телевизор – знаем как да го използваме, без да разбираме вътрешната електроника.
- **Имплементация** – Конкретният начин, по който интерфейсът е реализиран, например чрез масиви, свързани списъци или дървета.
- **Капсулация** – Скриване на вътрешните детайли на имплементацията, така че потребителят да взаимодейства само с интерфейса.
- **Сложност на операциите** – Времето и ресурсите, необходими за изпълнение на операции върху ADT, важни за оптимизацията на софтуер.
- **Модулност** – Разделяне на системата на независими компоненти, което ADT подпомагат чрез ясни интерфейси.

## 4. Step-by-step Learning Path
1. **Разберете концепцията за абстракция и интерфейс**
   - Фокус: Какво е абстракция и как интерфейсът дефинира ADT.
   - Задача: Опишете интерфейса на стек (stack) с основните операции.
   - Въпроси: Какво означава да скрием имплементацията? Защо е важно?

2. **Изучете основните ADT: стек, опашка, списък**
   - Фокус: Операции и поведение на тези структури.
   - Задача: Имплементирайте стек с масив и извършете push/pop операции.
   - Въпроси: Какви са времевите сложности на push и pop? Какво се случва при препълване?

3. **Сравнете различни имплементации**
   - Фокус: Разлики между масив и свързан списък за един ADT.
   - Задача: Имплементирайте опашка с двусвързан списък.
   - Въпроси: Какви са предимствата и недостатъците на всяка имплементация?

4. **Изследвайте капсулацията и модулността**
   - Фокус: Как да скриете детайлите и да създадете модулен код.
   - Задача: Създайте модул за стек с публичен интерфейс и скрити данни.
   - Въпроси: Как капсулацията подобрява поддръжката на кода?

5. **Прилагайте ADT в AI алгоритми**
   - Фокус: Използване на графи и опашки в търсене и планиране.
   - Задача: Имплементирайте опашка с приоритет за алгоритъм A*.
   - Въпроси: Как ADT улесняват проектирането на алгоритми?

## 5. Examples

### Пример 1: Стек с масив (Python)
```python
class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        if not self.is_empty():
            return self.items.pop()
        raise IndexError("Pop from empty stack")

    def is_empty(self):
        return len(self.items) == 0
```

### Пример 2: Опашка с двусвързан списък (Python)
```python
class Node:
    def __init__(self, value):
        self.value = value
        self.next = None
        self.prev = None

class Deque:
    def __init__(self):
        self.head = None
        self.tail = None

    def enqueue(self, value):
        new_node = Node(value)
        if not self.tail:
            self.head = self.tail = new_node
        else:
            self.tail.next = new_node
            new_node.prev = self.tail
            self.tail = new_node

    def dequeue(self):
        if not self.head:
            raise IndexError("Dequeue from empty deque")
        value = self.head.value
        self.head = self.head.next
        if self.head:
            self.head.prev = None
        else:
            self.tail = None
        return value
```

### Пример 3: Използване на опашка с приоритет в алгоритъм за търсене
```python
import heapq

class PriorityQueue:
    def __init__(self):
        self.elements = []

    def put(self, item, priority):
        heapq.heappush(self.elements, (priority, item))

    def get(self):
        return heapq.heappop(self.elements)[1]

    def empty(self):
        return len(self.elements) == 0
```

## 6. Common Pitfalls
- **Смесване на интерфейс и имплементация** – Опасно е да се разчита на конкретни детайли от имплементацията, което води до трудна поддръжка и промени.
- **Пренебрегване на капсулацията** – Излагане на вътрешни структури прави кода уязвим към грешки и усложнява отстраняването на проблеми.
- **Неправилно управление на гранични случаи** – Например, опит за pop от празен стек без проверка.
- **Избор на неподходяща имплементация** – Например, използване на масив при динамично променящ се размер, което води до неефективност.
- **Игнориране на времевата сложност** – Непознаването на сложността на операциите може да доведе до бавни и неефективни алгоритми.

## 7. Short Retrieval Quiz
1. Какво е основната разлика между интерфейс и имплементация в ADT?
2. Кои са основните операции на стек?
3. Какво означава капсулация в контекста на ADT?
4. Каква е времевата сложност на операцията push в стек, реализиран с масив?
5. Защо е важно да се избира подходяща имплементация на ADT?
6. Как ADT подпомагат модулността на софтуерните системи?
7. Дайте пример за ADT, който е полезен в AI алгоритми.

## 8. Quick Recap
- Абстрактните типове данни дефинират поведение, а не конкретна реализация.
- Интерфейсът на ADT предоставя набор от операции, които могат да се използват без да се знаят детайлите на имплементацията.
- Капсулацията скрива вътрешните детайли и подобрява поддръжката и сигурността на кода.
- Изборът на подходяща имплементация влияе на ефективността и сложността на операциите.
- Често използвани ADT са стек, опашка, списък и граф.
- ADT са ключови за модулност и повторна употреба в сложни софтуерни и AI системи.
- Практическото разбиране на ADT включва както теоретични знания, така и реални имплементации.

## 9. Spaced Review Plan

| Време след изучаване | Промпт за преговор                                  |
|----------------------|----------------------------------------------------|
| 1 ден                | Опишете интерфейса и основните операции на стек.  |
| 3 дни                | Сравнете имплементациите на опашка с масив и списък. |
| 1 седмица            | Обяснете как капсулацията подобрява модулността.   |
| 1 месец              | Дайте пример за използване на ADT в AI алгоритъм. |