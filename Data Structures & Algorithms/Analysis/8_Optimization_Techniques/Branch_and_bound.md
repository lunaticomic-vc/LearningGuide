# Branch_and_bound

## 1. Activate Prior Knowledge
- Какво знаете за алгоритмите за търсене и оптимизация в изкуствения интелект и софтуерното инженерство?
- Как бихте подходили към решаването на задача за намиране на оптимално решение в голямо пространство от възможности?
- Можете ли да си представите как да ограничите търсенето, за да избегнете излишна работа при намиране на най-доброто решение?

## 2. Overview
Branch and bound (B&B) е мощен алгоритмичен подход за решаване на комбинаторни оптимизационни задачи, при които търсенето на оптимално решение в голямо пространство от възможности е изключително скъпо или невъзможно чрез изчерпателно претърсване. Той комбинира разделянето на проблема на по-малки подпроблеми (branching) с интелигентно отхвърляне на подпространства, които не могат да съдържат по-добро решение (bounding).

Този метод е широко използван в задачи като целочислено програмиране, задачи за разпределение, маршрутизация и други области, където е необходимо да се намери оптимално или близко до оптимално решение. Branch and bound е част от по-широкия клас алгоритми за оптимизация и играе ключова роля в системите за вземане на решения и планиране.

Значението на B&B идва от способността му да намалява експоненциалната сложност на някои задачи чрез интелигентно изрязване на неефективни пътища, което го прави практически приложим в реални инженерни проблеми, където ресурсите са ограничени.

## 3. Key Concepts
- **Branching (Разклоняване)** – Разделяне на текущия проблем на по-малки подпроблеми, които могат да се разглеждат поотделно. Мислете за това като за дърво на решения, където всяка клонка представлява избор или ограничение.
- **Bounding (Ограничаване)** – Изчисляване на горна или долна граница за оптималността на подпроблемите, за да се прецени дали си струва да се разглеждат по-нататък. Това е като да имате предварителна оценка дали даден път може да доведе до по-добро решение.
- **Pruning (Отрязване)** – Отхвърляне на подпроблеми, чиито граници показват, че не могат да подобрят текущото най-добро решение. Аналогично на изрязване на ненужни клони в дърво, за да се спести време.
- **Incumbent (Текущо най-добро решение)** – Най-доброто намерено решение до момента, което служи като референтна точка за bounding и pruning.
- **Search Tree (Дърво на търсене)** – Структура, която представя всички възможни решения и подпроблеми, организирани по начин, който позволява систематично изследване.

## 4. Step-by-step Learning Path
1. **Фокус:** Разберете основната идея на разделяне на проблеми (branching).  
   **Задача:** Нарисувайте дърво на търсене за малка задача, например намиране на най-кратък път в граф с 4 върха.  
   **Въпроси:** Какво представлява клон в дървото на търсене? Защо е важно да разделяме проблема?

2. **Фокус:** Научете как се изчисляват граници (bounding) за подпроблеми.  
   **Задача:** Изберете задача за целочислено програмиране и изчислете горна/долна граница за даден подпроблем.  
   **Въпроси:** Каква е ролята на границите в алгоритъма? Какви методи може да се използват за bounding?

3. **Фокус:** Разберете кога и как се отрязват (pruning) подпроблеми.  
   **Задача:** Имплементирайте прост branch and bound алгоритъм за задача за раница (knapsack) и добавете отрязване на клонове.  
   **Въпроси:** Кога един клон се отрязва? Как отрязването подобрява ефективността?

4. **Фокус:** Изследвайте стратегии за избор на следващия подпроблем (например, best-first, depth-first).  
   **Задача:** Сравнете две стратегии за търсене в имплементацията си и измерете времето за изпълнение.  
   **Въпроси:** Как изборът на стратегия влияе на производителността? Кога е по-добре да използваме best-first?

5. **Фокус:** Прилагане на branch and bound в реален софтуерен проект.  
   **Задача:** Използвайте библиотека или напишете код за решаване на задача за разпределение на ресурси с branch and bound.  
   **Въпроси:** Какви са предизвикателствата при интегриране на B&B в големи системи? Как се управляват ресурсите?

## 5. Examples

### Пример 1: Задача за раница (0/1 Knapsack)
```python
def knapsack_branch_and_bound(weights, values, capacity):
    from queue import PriorityQueue
    
    class Node:
        def __init__(self, level, value, weight, bound):
            self.level = level
            self.value = value
            self.weight = weight
            self.bound = bound
        def __lt__(self, other):
            return self.bound > other.bound  # max-heap behavior
    
    def bound(node):
        if node.weight >= capacity:
            return 0
        profit_bound = node.value
        j = node.level + 1
        totweight = node.weight
        while j < len(weights) and totweight + weights[j] <= capacity:
            totweight += weights[j]
            profit_bound += values[j]
            j += 1
        if j < len(weights):
            profit_bound += (capacity - totweight) * values[j] / weights[j]
        return profit_bound
    
    pq = PriorityQueue()
    v = Node(-1, 0, 0, 0)
    max_value = 0
    v.bound = bound(v)
    pq.put(v)
    
    while not pq.empty():
        v = pq.get()
        if v.bound > max_value:
            u = Node(v.level + 1, v.value + values[v.level + 1], v.weight + weights[v.level + 1], 0)
            if u.weight <= capacity and u.value > max_value:
                max_value = u.value
            u.bound = bound(u)
            if u.bound > max_value:
                pq.put(u)
            u2 = Node(v.level + 1, v.value, v.weight, 0)
            u2.bound = bound(u2)
            if u2.bound > max_value:
                pq.put(u2)
    return max_value

weights = [2, 3, 4, 5]
values = [3, 4, 5, 6]
capacity = 5
print(knapsack_branch_and_bound(weights, values, capacity))  # Output: 7
```

### Пример 2: Целочислено линейно програмиране
Използване на branch and bound за решаване на ILP чрез библиотека като `PuLP` или `Google OR-Tools` с вграден B&B.

```python
from pulp import LpProblem, LpVariable, LpMaximize, LpInteger, value

prob = LpProblem("ILP_example", LpMaximize)
x = LpVariable('x', lowBound=0, cat=LpInteger)
y = LpVariable('y', lowBound=0, cat=LpInteger)

prob += 3*x + 4*y
prob += 2*x + y <= 14
prob += x + 2*y <= 11

prob.solve()
print(f"x = {value(x)}, y = {value(y)}, objective = {value(prob.objective)}")
```

## 6. Common Pitfalls
- **Липса на ефективно bounding** – Ако границите са слаби, алгоритъмът ще разглежда много излишни подпроблеми. Решение: използвайте по-точни оценки или релаксации.
- **Неправилно отрязване на клони** – Отрязване на клон, който може да съдържа оптимално решение, води до грешки. Винаги проверявайте условията за pruning внимателно.
- **Прекалено дълбоко търсене без приоритет** – Използване само на depth-first може да забави намирането на добро решение. Комбинирайте с best-first или други стратегии.
- **Лошо управление на паметта** – При големи дървета на търсене може да се изчерпи паметта. Използвайте подходящи структури и стратегии за ограничаване.
- **Игнориране на текущото най-добро решение (incumbent)** – Без актуализиране на incumbent, bounding няма да е ефективен.

## 7. Short Retrieval Quiz
1. Какво представлява "branching" в branch and bound?
2. Защо bounding е важен за ефективността на алгоритъма?
3. Какво означава "pruning" и кога се прилага?
4. Какво е incumbent и каква е ролята му?
5. Коя структура данни често се използва за реализиране на branch and bound?
6. Как изборът на стратегия за търсене влияе на производителността?
7. Какви са основните приложения на branch and bound?

## 8. Quick Recap
- Branch and bound е алгоритмичен метод за оптимизация чрез разделяне и интелигентно отрязване.
- Branching създава подпроблеми, bounding оценява техния потенциал.
- Pruning елиминира подпроблеми, които не могат да подобрят текущото решение.
- Incumbent е най-доброто намерено решение до момента и служи за bounding.
- Изборът на стратегия за търсене влияе значително на ефективността.
- B&B е широко приложим в задачи като целочислено програмиране и комбинаторни оптимизации.
- Внимателната имплементация и точните граници са ключови за успеха на алгоритъма.

## 9. Spaced Review Plan

| Време след учене | Промпт за преговор                                      |
|------------------|---------------------------------------------------------|
| 1 ден            | Обяснете с прости думи как работи branch and bound.     |
| 3 дни            | Опишете ролята на bounding и pruning в алгоритъма.      |
| 1 седмица        | Напишете кратък псевдокод за branch and bound.          |
| 1 месец          | Приложете branch and bound на нова задача от оптимизация. |