# Applications_of_stacks

## 1. Activate Prior Knowledge
- Какво представлява структурата от данни стек и как се различава от опашката?
- Можете ли да си представите ситуации в софтуерното инженерство, където последният въведен елемент трябва да бъде първият, който се обработва?
- Как мислите, че стековете могат да подпомогнат управлението на задачи в изкуствения интелект, например при обработка на рекурсивни функции или анализ на изрази?

## 2. Overview
Стекът е фундаментална структура от данни, която работи по принципа "Last In, First Out" (LIFO). Това означава, че последният добавен елемент е първият, който се премахва. Тази характеристика го прави изключително полезен в множество области на компютърните науки и инженерството, особено там, където е необходимо да се проследява последователността на операции или състояния.

В по-широк контекст на софтуерните системи, стековете често се използват за управление на изпълнението на функции, обработка на изрази, навигация в уеб браузъри и дори в алгоритми за търсене и оптимизация. В изкуствения интелект стековете могат да подпомогнат при реализирането на алгоритми за търсене в дървета и графи, както и при обработка на рекурсивни задачи.

Разбирането на приложенията на стековете е ключово за изграждането на ефективни и надеждни системи, тъй като те осигуряват прост, но мощен механизъм за управление на данни и контрол на потока на изпълнение.

## 3. Key Concepts
- **Stack (Стек)** – структура от данни, която позволява добавяне (push) и премахване (pop) на елементи само от върха. Можете да си го представите като купчина чинии, където винаги взимате последната поставена чиния.
- **LIFO (Last In, First Out)** – принцип, по който последният добавен елемент е първият, който се премахва. Това е основният механизъм, който определя поведението на стека.
- **Push** – операция за добавяне на елемент върху върха на стека.
- **Pop** – операция за премахване на елемент от върха на стека.
- **Stack Frame** – контекстът на изпълнение на функция в паметта, който се съхранява в стека при рекурсивни или вложени извиквания.
- **Backtracking (Отмятане назад)** – техника, при която стекът се използва за връщане към предишно състояние, например при търсене на решения в AI.
- **Expression Evaluation (Оценка на изрази)** – използване на стекове за преобразуване и изчисляване на математически изрази, например чрез алгоритъма на обратна полска нотация.

## 4. Step-by-step Learning Path
1. **Разберете основите на стековете**
   - Фокус: Принципи на LIFO, операции push и pop.
   - Задача: Имплементирайте стек с масив или свързан списък.
   - Въпроси: Какво се случва, ако опитате да pop-нете от празен стек? Какви са предимствата на стек пред опашка?

2. **Изучете стековете в контекста на рекурсията**
   - Фокус: Как стекът управлява изпълнението на функции.
   - Задача: Напишете рекурсивна функция и проследете стековите кадри ръчно.
   - Въпроси: Как стекът помага при вложени извиквания? Какво се случва при прекалено дълбока рекурсия?

3. **Прилагане на стекове за обработка на изрази**
   - Фокус: Алгоритми за преобразуване на инфиксен към постфиксен израз и обратно.
   - Задача: Имплементирайте алгоритъм за оценка на аритметичен израз с помощта на стек.
   - Въпроси: Защо стекът е подходящ за тази задача? Как се обработват скобите?

4. **Използване на стекове в AI алгоритми**
   - Фокус: Backtracking и търсене в дървета/графи.
   - Задача: Имплементирайте алгоритъм за дълбочинно търсене (DFS) с помощта на стек.
   - Въпроси: Как стекът замества рекурсията в DFS? Как стекът помага при отмятане назад?

5. **Практическо приложение и оптимизация**
   - Фокус: Управление на памет и избягване на стек overflow.
   - Задача: Анализирайте стековата употреба на дадена програма и оптимизирайте рекурсивни функции.
   - Въпроси: Какво е стек overflow и как може да се предотврати? Кога е по-добре да използваме итеративен подход?

## 5. Examples
### Пример 1: Имплементация на стек на Python
```python
class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        if not self.is_empty():
            return self.items.pop()
        raise IndexError("pop from empty stack")

    def is_empty(self):
        return len(self.items) == 0

# Използване
stack = Stack()
stack.push(10)
stack.push(20)
print(stack.pop())  # Изход: 20
```

### Пример 2: Оценка на аритметичен израз с обратна полска нотация
```python
def evaluate_postfix(expression):
    stack = []
    for token in expression.split():
        if token.isdigit():
            stack.append(int(token))
        else:
            b = stack.pop()
            a = stack.pop()
            if token == '+':
                stack.append(a + b)
            elif token == '-':
                stack.append(a - b)
            elif token == '*':
                stack.append(a * b)
            elif token == '/':
                stack.append(a / b)
    return stack.pop()

expr = "3 4 + 2 * 7 /"
print(evaluate_postfix(expr))  # Изход: 2.0
```

### Пример 3: Дълбочинно търсене (DFS) с използване на стек
```python
def dfs(graph, start):
    visited = set()
    stack = [start]

    while stack:
        vertex = stack.pop()
        if vertex not in visited:
            visited.add(vertex)
            stack.extend([n for n in graph[vertex] if n not in visited])
    return visited

graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}
print(dfs(graph, 'A'))  # Изход: {'A', 'B', 'C', 'D', 'E', 'F'}
```

## 6. Common Pitfalls
- **Опит за pop от празен стек** – води до грешки или изключения. Винаги проверявайте дали стекът не е празен преди операцията.
- **Пренебрегване на стек overflow** – при дълбока рекурсия или големи обеми данни стекът може да се препълни. Използвайте итеративни решения или увеличете размера на стека.
- **Неправилно управление на скобите при обработка на изрази** – води до грешки в оценката. Винаги следете баланса на скобите.
- **Забравяне за уникалност при посещение на върхове в граф** – при DFS без проверка може да се получи безкраен цикъл.
- **Използване на стек за задачи, където е по-подходяща опашка** – например при първо влязъл, първо излязъл (FIFO) поведение.

## 7. Short Retrieval Quiz
1. Какъв е основният принцип на работа на стек?
2. Кои операции са основни за стек?
3. Как стекът подпомага изпълнението на рекурсивни функции?
4. Защо стекът е подходящ за оценка на аритметични изрази?
5. Как стекът се използва в алгоритъма за дълбочинно търсене (DFS)?
6. Какво представлява стек overflow и как може да се избегне?
7. Кога е по-добре да използваме опашка вместо стек?

## 8. Quick Recap
- Стекът е LIFO структура, която управлява данни чрез push и pop операции.
- Използва се широко за управление на изпълнението на функции и рекурсия.
- Помага при оценка на изрази и преобразуване между различни нотации.
- Ключов инструмент в AI алгоритми като backtracking и DFS.
- Винаги проверявайте за празен стек преди pop и избягвайте стек overflow.
- Разбирането на стековете е фундаментално за ефективно програмиране и системен дизайн.
- Изборът между стек и опашка зависи от конкретния проблем и изискванията за ред на обработка.

## 9. Spaced Review Plan

| Време след първоначално учене | Промпт за преглед                                      |
|-------------------------------|-------------------------------------------------------|
| 1 ден                         | Обяснете принципа LIFO и основните операции на стек.  |
| 3 дни                         | Дайте пример за използване на стек при рекурсия.      |
| 1 седмица                     | Имплементирайте алгоритъм за оценка на израз с помощта на стек. |
| 1 месец                      | Опишете как стекът се използва в алгоритъма DFS и какво е стек overflow. |