# Kruskal_and_Prim

## 1. Activate Prior Knowledge
- Какво представлява минималното остовно дърво (Minimum Spanning Tree, MST) и защо е важно в графовите структури?
- Как бихте приложили MST алгоритъм в системи за изкуствен интелект, например при оптимизация на мрежи или маршрутизация?
- Какви алгоритми знаете за намиране на MST и как се различават те по подход и ефективност?

## 2. Overview
Алгоритмите на Крускал и Прим са класически методи за намиране на минимално остовно дърво (MST) в свързан, претеглен граф. MST е подмножество от ребрата на графа, което свързва всички върхове без цикли и с минимална сумарна тежест. Тези алгоритми са фундаментални в компютърните науки и инженерството, особено в оптимизацията на мрежи, маршрутизация, клъстеризация и други приложения в изкуствения интелект.

Алгоритъмът на Крускал работи чрез сортиране на ребрата по тежест и добавяне на най-леките ребра, които не образуват цикъл, докато свърже всички върхове. Той е особено ефективен при разредени графи. От друга страна, алгоритъмът на Прим започва от произволен връх и постепенно разширява MST, като добавя най-лекото ребро, свързващо дървото с нов връх. Той е по-подходящ за плътни графи.

Разбирането на тези алгоритми е ключово за проектиране на ефективни системи, които изискват оптимално свързване, като например мрежови протоколи, разпределени системи и AI модели, които работят с графови данни.

## 3. Key Concepts
- **Minimum Spanning Tree (MST)** – Подмножество от ребрата на графа, което свързва всички върхове без цикли и с минимална обща тежест. Можем да си го представим като най-евтиния начин да свържем всички точки в мрежа.
- **Edge Weight (Тежест на ребро)** – Числова стойност, която показва "цена" или "разстояние" между два върха. Аналогично на разстоянието между градове на карта.
- **Cycle (Цикъл)** – Последователност от ребра, които започват и завършват в един и същи връх, без да повтарят ребра. В MST цикли не са позволени, защото създават излишни връзки.
- **Disjoint Set Union (DSU) / Union-Find** – Структура от данни, използвана в алгоритъма на Крускал за ефективно следене на свързаността и избягване на цикли. Представете си я като система за групиране на елементи в отделни множества.
- **Priority Queue (Опашка с приоритет)** – Данна структура, използвана в алгоритъма на Прим за избор на реброто с най-малка тежест. Можем да я сравним с опашка, в която винаги обслужваме най-важния клиент първо.

## 4. Step-by-step Learning Path
1. **Разберете концепцията за MST**
   - Фокус: Какво е MST и защо е важно.
   - Задача: Нарисувайте малък граф и ръчно намерете MST.
   - Въпроси: Какво означава "минимална обща тежест"? Защо MST не съдържа цикли?

2. **Изучете алгоритъма на Крускал**
   - Фокус: Сортиране на ребрата и използване на DSU.
   - Задача: Имплементирайте алгоритъма на Крускал на език по избор.
   - Въпроси: Как DSU помага за избягване на цикли? Какво се случва, ако ребрата не са сортирани?

3. **Изучете алгоритъма на Прим**
   - Фокус: Разширяване на MST чрез приоритетна опашка.
   - Задача: Имплементирайте алгоритъма на Прим и го сравнете с Крускал по време на изпълнение.
   - Въпроси: Как се избира следващото ребро? Защо Прим е по-ефективен при плътни графи?

4. **Приложение в реални системи**
   - Фокус: Използване на MST в мрежова оптимизация и AI.
   - Задача: Моделирайте малка мрежа и използвайте MST за оптимизиране на връзките.
   - Въпроси: Как MST може да подобри маршрутизацията? Къде MST не е подходящ?

## 5. Examples

### Пример 1: Крускал на малък граф
```python
# Python пример за Крускал
class DSU:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0]*n

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        rx, ry = self.find(x), self.find(y)
        if rx == ry:
            return False
        if self.rank[rx] < self.rank[ry]:
            self.parent[rx] = ry
        else:
            self.parent[ry] = rx
            if self.rank[rx] == self.rank[ry]:
                self.rank[rx] += 1
        return True

def kruskal(n, edges):
    edges.sort(key=lambda x: x[2])
    dsu = DSU(n)
    mst = []
    for u, v, w in edges:
        if dsu.union(u, v):
            mst.append((u, v, w))
    return mst

# Примерни ребра: (връх1, връх2, тежест)
edges = [(0,1,10), (0,2,6), (0,3,5), (1,3,15), (2,3,4)]
print(kruskal(4, edges))
```

### Пример 2: Прим с приоритетна опашка
```python
import heapq

def prim(n, graph):
    visited = [False]*n
    min_heap = [(0, 0)]  # (тежест, връх)
    mst = []
    total_weight = 0

    while min_heap:
        w, u = heapq.heappop(min_heap)
        if visited[u]:
            continue
        visited[u] = True
        total_weight += w
        for v, weight in graph[u]:
            if not visited[v]:
                heapq.heappush(min_heap, (weight, v))
        if w != 0:
            mst.append((u, w))
    return mst, total_weight

# Граф като списък със съседство: връх -> [(съсед, тежест), ...]
graph = {
    0: [(1, 10), (2, 6), (3, 5)],
    1: [(0, 10), (3, 15)],
    2: [(0, 6), (3, 4)],
    3: [(0, 5), (1, 15), (2, 4)]
}
print(prim(4, graph))
```

## 6. Common Pitfalls
- **Игнориране на цикли при Крускал** – Ако не използвате DSU или подобна структура, може да добавите ребра, които образуват цикли.
- **Неправилно сортиране на ребрата** – Крускал изисква ребрата да са сортирани по тежест; пропускът води до неправилен MST.
- **Пропускане на маркиране на посетени върхове в Прим** – Това може да доведе до добавяне на ребра, които вече са част от MST.
- **Неправилна инициализация на графа** – Особено при Прим, ако графът не е правилно представен, алгоритъмът няма да работи коректно.
- **Използване на неподходящ алгоритъм за типа граф** – Крускал е по-добър за разредени графи, Прим – за плътни. Неправилният избор води до неефективност.

## 7. Short Retrieval Quiz
1. Какво е минимално остовно дърво?
2. Как алгоритъмът на Крускал избягва образуването на цикли?
3. Какъв тип структура от данни се използва в алгоритъма на Крускал за следене на свързаността?
4. Как алгоритъмът на Прим избира следващото ребро за добавяне?
5. При какъв тип граф е по-ефективен алгоритъмът на Прим?
6. Защо MST не съдържа цикли?
7. Какво е основното различие между подходите на Крускал и Прим?

## 8. Quick Recap
- MST свързва всички върхове с минимална обща тежест без цикли.
- Крускал сортира ребрата и добавя най-леките, избягвайки цикли чрез DSU.
- Прим започва от произволен връх и разширява MST чрез приоритетна опашка.
- Крускал е подходящ за разредени графи, Прим – за плътни.
- Правилната структура на данни е ключова за ефективна имплементация.
- MST алгоритмите са основа за оптимизация в мрежи и AI системи.
- Избягването на цикли е критично за коректността на MST.

## 9. Spaced Review Plan

| Време       | Прегледна задача                                    |
|-------------|----------------------------------------------------|
| 1 ден       | Обяснете с прости думи какво е MST и защо е важен.|
| 3 дни       | Имплементирайте алгоритъма на Крускал на хартия.  |
| 1 седмица   | Сравнете алгоритмите на Крускал и Прим по време и памет. |
| 1 месец     | Приложете MST за оптимизация на малка мрежа и анализирайте резултатите. |