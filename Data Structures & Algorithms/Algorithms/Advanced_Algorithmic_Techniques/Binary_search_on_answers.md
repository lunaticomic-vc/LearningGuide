# Binary_search_on_answers

## 1. Activate Prior Knowledge

- Какво представлява класическото двоично търсене (binary search) и в какви ситуации го използваме?
- Как бихте подходили към оптимизация на параметър, когато търсите минимална или максимална стойност, която удовлетворява дадено условие?
- В кои случаи в софтуерното инженерство или AI системите може да се наложи да търсим решение чрез проверка на отговори, а не директно върху входни данни?

## 2. Overview

Binary search on answers е техника, при която вместо да търсим конкретна стойност в сортиран масив, търсим оптимална или валидна стойност в диапазон от възможни отговори. Тази техника е особено полезна, когато директното изчисляване на отговора е трудно или скъпо, но можем да проверим дали даден кандидат-отговор е валиден.

Тази стратегия се използва често в алгоритмични задачи, оптимизации и инженерни проблеми, където търсим минимална или максимална стойност, удовлетворяваща някакво условие. Например, при разпределяне на ресурси, планиране или настройка на параметри в AI системи.

Значението на binary search on answers идва от това, че позволява ефективно намиране на решения в големи пространства от възможности, като намалява сложността от линейна към логаритмична по отношение на диапазона на отговорите.

## 3. Key Concepts

- **Candidate answer (Кандидат-отговор)** – Стойност, която предполагаме, че може да е решение на задачата. Тя се проверява дали удовлетворява условието.
- **Feasibility check (Проверка на валидност)** – Функция или процедура, която казва дали даденият кандидат-отговор е валиден (например, дали може да се постигне с този параметър).
- **Search space (Пространство на търсене)** – Интервалът от възможни отговори, върху който прилагаме двоично търсене.
- **Monotonicity (Монотонност)** – Свойство, че ако даден кандидат-отговор е валиден, то всички по-големи (или по-малки) също са валидни или невалидни, което позволява двоичното търсене.
- **Optimization problem (Оптимизационен проблем)** – Задача, при която търсим минимална или максимална стойност, удовлетворяваща определени условия.

## 4. Step-by-step Learning Path

1. **Разберете класическото двоично търсене**
   - Фокус: Прегледайте алгоритъма за двоично търсене върху сортиран масив.
   - Задача: Имплементирайте двоично търсене за намиране на елемент в сортиран списък.
   - Въпроси: Какво е времевата сложност на двоичното търсене? Защо е необходимо сортиране?

2. **Запознайте се с концепцията за търсене върху отговори**
   - Фокус: Разберете как да дефинирате пространство на отговори и проверка на валидност.
   - Задача: Формулирайте проблем, в който трябва да намерите минимален параметър, използвайки проверка на валидност.
   - Въпроси: Какво означава монотонност в контекста на проверката на валидност? Защо е важна?

3. **Имплементирайте binary search on answers**
   - Фокус: Напишете код, който прилага двоично търсене върху диапазон от стойности с функция за проверка.
   - Задача: Решете задача за намиране на минимална максимална тежест при разпределяне на задачи.
   - Въпроси: Как се определя началният и крайният диапазон? Какво се случва, ако проверката върне false?

4. **Оптимизирайте и анализирайте**
   - Фокус: Анализирайте времевата сложност и възможни подобрения.
   - Задача: Измерете времето за изпълнение при различни размери на входа.
   - Въпроси: Как влияе размерът на пространството на отговорите върху производителността? Какво може да се направи при големи диапазони?

## 5. Examples

### Пример 1: Намиране на минимална максимална тежест при разпределяне на задачи

```python
def can_distribute(tasks, max_load, workers):
    current_load = 0
    needed_workers = 1
    for task in tasks:
        if task > max_load:
            return False
        if current_load + task <= max_load:
            current_load += task
        else:
            needed_workers += 1
            current_load = task
            if needed_workers > workers:
                return False
    return True

def binary_search_on_answers(tasks, workers):
    left, right = max(tasks), sum(tasks)
    result = right
    while left <= right:
        mid = (left + right) // 2
        if can_distribute(tasks, mid, workers):
            result = mid
            right = mid - 1
        else:
            left = mid + 1
    return result

tasks = [10, 20, 30, 40, 50]
workers = 3
print(binary_search_on_answers(tasks, workers))  # Output: 60
```

### Пример 2: Намиране на минимална скорост за доставка в даден срок

```python
def can_deliver(piles, speed, hours):
    time = 0
    for pile in piles:
        time += (pile + speed - 1) // speed
    return time <= hours

def min_speed(piles, hours):
    left, right = 1, max(piles)
    while left < right:
        mid = (left + right) // 2
        if can_deliver(piles, mid, hours):
            right = mid
        else:
            left = mid + 1
    return left

piles = [30, 11, 23, 4, 20]
hours = 6
print(min_speed(piles, hours))  # Output: 23
```

## 6. Common Pitfalls

- **Неправилно дефиниране на диапазона на търсене** – Ако началната или крайната стойност не обхващат всички възможни отговори, алгоритъмът може да пропусне решение.
- **Липса на монотонност** – Ако функцията за проверка не е монотонна, двоичното търсене няма да работи правилно.
- **Грешки при обновяване на границите** – Забравяне да се коригира `left` или `right` правилно води до безкрайни цикли или пропуснати решения.
- **Неоптимална проверка на валидност** – Ако проверката е скъпа, цялата процедура може да стане неефективна.
- **Използване на двоично търсене върху несортирани данни** – Търсенето трябва да е върху подредено или монотонно пространство.

## 7. Short Retrieval Quiz

1. Какво представлява binary search on answers и как се различава от класическото двоично търсене?
2. Защо е важно да има монотонност във функцията за проверка на валидност?
3. Как се определя началният диапазон за двоично търсене върху отговори?
4. Какво правим, ако даден кандидат-отговор не е валиден?
5. Каква е типичната времева сложност на binary search on answers?
6. Кога не е подходящо да използваме binary search on answers?
7. Какво представлява функцията за проверка на валидност (feasibility check)?

## 8. Quick Recap

- Binary search on answers търси оптимален отговор в диапазон, използвайки проверка на валидност.
- Изисква се монотонна функция за проверка, за да работи правилно.
- Началният и крайният диапазон трябва да покриват всички възможни решения.
- Често се използва при оптимизационни задачи и инженерни проблеми.
- Позволява значително намаляване на времевата сложност спрямо брутално търсене.
- Важно е правилно да се обновяват границите на търсене.
- Проверка на валидност трябва да е ефективна, за да не забавя алгоритъма.

## 9. Spaced Review Plan

| Време след учене | Промпт за преговор                                    |
|-------------------|------------------------------------------------------|
| 1 ден             | Обяснете с прости думи как работи binary search on answers. |
| 3 дни             | Дайте пример за задача, където използвате binary search on answers. |
| 1 седмица         | Опишете какво е монотонност и защо е важна за този метод. |
| 1 месец           | Имплементирайте и оптимизирайте binary search on answers за нов проблем. |