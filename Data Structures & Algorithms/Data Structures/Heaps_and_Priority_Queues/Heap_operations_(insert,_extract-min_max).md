# Heap_operations_(insert,_extract-min_max)

## 1. Activate Prior Knowledge

- Какво представлява структурата данни "heap" и каква е нейната основна цел?
- Какви са предимствата на използването на heap в алгоритми за приоритетни опашки или сортиране?
- Как бихте използвали операции като insert и extract-min/max в контекста на оптимизация или обработка на големи данни?

## 2. Overview

Heap е специализирана дървовидна структура данни, която поддържа частичен ред между елементите си, позволявайки бърз достъп до най-големия или най-малкия елемент. Тя се използва широко в алгоритми за приоритетни опашки, сортиране (HeapSort), както и в системи за управление на ресурси и AI, където е необходима ефективна обработка на приоритети.

Основните операции върху heap са insert (вмъкване на нов елемент) и extract-min или extract-max (извличане на минималния или максималния елемент). Тези операции поддържат свойството на heap, като гарантират, че коренът винаги съдържа най-малкия или най-големия елемент, в зависимост от типа на heap.

Разбирането и правилната имплементация на тези операции е ключово за създаването на ефективни алгоритми и системи, които изискват динамично управление на приоритети. Това е особено важно в AI, където бързото вземане на решения и оптимизацията на ресурси са критични.

## 3. Key Concepts

- **Heap property** – В min-heap всеки родителски възел е по-малък или равен на своите деца; в max-heap е обратното. Това гарантира бърз достъп до минималния или максималния елемент.
- **Complete binary tree** – Heap се представя като пълно двоично дърво, което означава, че всички нива са напълно запълнени, с изключение на последното, което се запълва отляво надясно.
- **Insert operation** – Добавяне на нов елемент в края на дървото, последвано от "bubble-up" или "heapify-up" за възстановяване на heap свойството.
- **Extract-min/max operation** – Премахване на коренния елемент (минимален или максимален), заместването му с последния елемент и "bubble-down" или "heapify-down" за възстановяване на heap свойството.
- **Heapify** – Процесът на коригиране на структурата, за да се възстанови heap свойството след промяна.

## 4. Step-by-step Learning Path

1. **Разберете структурата на heap**
   - Фокус: Концепцията за пълно двоично дърво и heap property.
   - Задача: Нарисувайте min-heap с 7 елемента и отбележете родител-дете връзките.
   - Въпрос: Защо heap трябва да е пълно двоично дърво?

2. **Имплементирайте insert операция**
   - Фокус: Добавяне на елемент и bubble-up.
   - Задача: Напишете функция за insert в min-heap.
   - Въпрос: Как bubble-up гарантира възстановяване на heap свойството?

3. **Разберете extract-min/max операция**
   - Фокус: Премахване на корена и bubble-down.
   - Задача: Имплементирайте extract-min в min-heap.
   - Въпрос: Какво се случва с дървото след премахване на корена?

4. **Тествайте и оптимизирайте**
   - Фокус: Проверка на коректност и ефективност.
   - Задача: Тествайте insert и extract-min с различни входни данни.
   - Въпрос: Какъв е времевият комплекс на тези операции?

5. **Приложение в реални системи**
   - Фокус: Използване на heap в приоритетни опашки.
   - Задача: Създайте приоритетна опашка, базирана на heap.
   - Въпрос: Как heap подобрява производителността на приоритетни опашки?

## 5. Examples

### Пример 1: Insert в min-heap (Python)

```python
def bubble_up(heap, index):
    parent = (index - 1) // 2
    while index > 0 and heap[index] < heap[parent]:
        heap[index], heap[parent] = heap[parent], heap[index]
        index = parent
        parent = (index - 1) // 2

def insert(heap, value):
    heap.append(value)
    bubble_up(heap, len(heap) - 1)

heap = [2, 4, 5, 7, 8]
insert(heap, 1)
print(heap)  # Output: [1, 4, 2, 7, 8, 5]
```

### Пример 2: Extract-min в min-heap (Python)

```python
def bubble_down(heap, index):
    length = len(heap)
    smallest = index
    left = 2 * index + 1
    right = 2 * index + 2

    if left < length and heap[left] < heap[smallest]:
        smallest = left
    if right < length and heap[right] < heap[smallest]:
        smallest = right
    if smallest != index:
        heap[index], heap[smallest] = heap[smallest], heap[index]
        bubble_down(heap, smallest)

def extract_min(heap):
    if len(heap) == 0:
        return None
    min_val = heap[0]
    heap[0] = heap[-1]
    heap.pop()
    bubble_down(heap, 0)
    return min_val

heap = [1, 4, 2, 7, 8, 5]
print(extract_min(heap))  # Output: 1
print(heap)               # Output: [2, 4, 5, 7, 8]
```

### Пример 3: Max-heap insert и extract-max (концептуално)

- При max-heap insert добавяте елемент и "bubble-up", сравнявайки с родителя, за да се издигне по-големият елемент.
- При extract-max премахвате корена (максимума), замествате с последния елемент и "bubble-down", за да възстановите свойството.

## 6. Common Pitfalls

- **Неспазване на пълното двоично дърво** – Вмъкването на елементи не на последната позиция нарушава структурата и ефективността.
- **Грешки в bubble-up или bubble-down** – Неправилно сравняване или размяна на елементи може да доведе до загуба на heap свойството.
- **Забравяне да актуализирате индекси** – При bubble-up/down трябва внимателно да се следят индексите на родители и деца.
- **Извличане от празен heap** – Необработване на празен heap води до runtime грешки.
- **Смесване на min-heap и max-heap логика** – Важно е да се следва правилната логика за сравнение според типа на heap.

## 7. Short Retrieval Quiz

1. Какво гарантира heap свойството в min-heap?
2. Каква е ролята на операцията bubble-up при insert?
3. Как се извършва extract-min в min-heap?
4. Защо heap трябва да е пълно двоично дърво?
5. Каква е времевата сложност на insert и extract-min?
6. Каква е разликата между min-heap и max-heap?
7. Какво се случва с последния елемент при extract-min?

## 8. Quick Recap

- Heap е пълно двоично дърво с частичен ред (min-heap или max-heap).
- Insert добавя елемент и използва bubble-up за възстановяване на свойството.
- Extract-min/max премахва корена и използва bubble-down за корекция.
- Heap позволява бърз достъп до минималния или максималния елемент.
- Правилната имплементация изисква внимание към индекси и структура.
- Heap е основа за приоритетни опашки и ефективни алгоритми.
- Времевата сложност на основните операции е O(log n).

## 9. Spaced Review Plan

| Време след учене | Промпт за преглед                                    |
|------------------|-----------------------------------------------------|
| 1 ден            | Обяснете с прости думи как работи insert в min-heap.|
| 3 дни            | Опишете стъпките при extract-min и защо са необходими.|
| 1 седмица        | Имплементирайте insert и extract-min без помощ.     |
| 1 месец          | Свържете heap операциите с реален проблем в AI или софтуер. |