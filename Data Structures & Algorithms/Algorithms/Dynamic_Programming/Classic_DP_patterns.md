# Classic_DP_patterns

## 1. Activate Prior Knowledge
- Какво представлява динамичното програмиране (DP) и кога е полезно в софтуерното инженерство?
- Можете ли да си спомните проблем, при който сте използвали разделяне на подпроблеми и комбиниране на решения?
- Как DP може да подобри ефективността на алгоритми в AI системи, например при оптимизация или търсене?

## 2. Overview
Динамичното програмиране (DP) е метод за решаване на сложни проблеми, като ги разбива на по-малки, припокриващи се подпроблеми и запазва решенията им, за да избегне повторни изчисления. Този подход е ключов в оптимизацията на алгоритми, особено когато проблемът има структура на оптимално подструктуриране и припокриващи се подпроблеми.

В контекста на AI системи и софтуерното инженерство, DP често се използва за задачи като намиране на най-кратък път, оптимално разпределение на ресурси, или моделиране на вероятности в скрити маркови модели. Той позволява значително намаляване на времевата сложност, което е критично за реални приложения с големи входни данни.

Класическите DP шаблони са структурирани подходи, които помагат да се идентифицират и решават типични DP проблеми. Разбирането и овладяването на тези шаблони е фундаментално за всеки, който иска да проектира ефективни алгоритми и да разбира сложни системи.

## 3. Key Concepts
- **Overlapping Subproblems** – Проблемът може да бъде разбит на подпроблеми, които се повтарят многократно. Представете си го като многократно решаване на една и съща задача, което DP оптимизира чрез запомняне.
- **Optimal Substructure** – Оптималното решение на цялата задача се състои от оптимални решения на нейните подзадачи. Аналогично на пъзел, където всяка част трябва да е правилно поставена, за да се получи цялостна картина.
- **Memoization** – Техника за запаметяване на вече изчислени резултати, за да се избегнат повторни изчисления. Мислете за това като за бележник, в който записвате отговорите на подпроблеми.
- **Tabulation** – Итеративен подход, при който се изгражда таблица с решения от най-малките подпроблеми нагоре. Това е като да запълвате таблица с резултати, за да стигнете до крайния отговор.
- **State and Transition** – Представяне на подпроблемите като състояния и начините за преминаване между тях. Подобно на навигация в граф, където всяка стъпка е преход към ново състояние.

## 4. Step-by-step Learning Path
1. **Разберете основите на DP**  
   Фокус: Концепции като припокриващи се подпроблеми и оптимална подструктура.  
   Задача: Решете класическия проблем с изчисляване на n-тото число от Фибоначи с и без DP.  
   Въпроси: Какво е припокриване на подпроблеми? Защо DP е по-ефективно от рекурсия?

2. **Изучете Memoization и Tabulation**  
   Фокус: Разлика между двата подхода и кога да се използват.  
   Задача: Имплементирайте решението на проблема за намиране на най-дългата обща подниз (Longest Common Subsequence) с двата метода.  
   Въпроси: Как memoization намалява броя на изчисленията? Кои са предимствата на табулацията?

3. **Запознайте се с класическите DP шаблони**  
   Фокус: Разпознаване на шаблони като "Knapsack", "Partition", "Grid Path" и др.  
   Задача: Решете задачата "0/1 Knapsack" с табулация.  
   Въпроси: Какви са ключовите състояния в Knapsack? Как се дефинира преходът?

4. **Практикувайте изграждане на DP решения от нулата**  
   Фокус: Анализ на проблема, дефиниране на състояния, формулиране на преходи.  
   Задача: Решете проблем с оптимално разпределение на ресурси, например "Coin Change".  
   Въпроси: Как дефинирате състоянията? Как избирате преходите?

5. **Оптимизация и анализ на сложността**  
   Фокус: Намаляване на пространствената сложност, разбиране на времевата сложност.  
   Задача: Оптимизирайте пространствената сложност на решението за "Longest Increasing Subsequence".  
   Въпроси: Какво е trade-off между време и памет? Как DP решенията се скалират с размера на входа?

## 5. Examples

### Пример 1: Фибоначи с Memoization (Python)
```python
def fib_memo(n, memo={}):
    if n <= 1:
        return n
    if n not in memo:
        memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)
    return memo[n]
```

### Пример 2: 0/1 Knapsack с Tabulation (Python)
```python
def knapsack(weights, values, W):
    n = len(weights)
    dp = [[0]*(W+1) for _ in range(n+1)]
    for i in range(1, n+1):
        for w in range(W+1):
            if weights[i-1] <= w:
                dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]] + values[i-1])
            else:
                dp[i][w] = dp[i-1][w]
    return dp[n][W]
```

### Пример 3: Най-дълга обща подниз (Longest Common Subsequence)
```python
def lcs(X, Y):
    m, n = len(X), len(Y)
    dp = [[0]*(n+1) for _ in range(m+1)]
    for i in range(1, m+1):
        for j in range(1, n+1):
            if X[i-1] == Y[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    return dp[m][n]
```

## 6. Common Pitfalls
- **Липса на ясно дефинирани състояния** – Неясното формулиране на състояния води до объркване и грешки. Винаги започвайте с дефиниране на състоянията и какво те представят.
- **Пренебрегване на припокриващите се подпроблеми** – Ако не използвате memoization или tabulation, алгоритъмът може да стане експоненциален.
- **Неправилно обновяване на таблицата** – Грешки в индексирането или условията при обновяване на dp масивите са често срещани.
- **Оптимизация преди коректност** – Оптимизирайте пространствената или времевата сложност само след като имате работещо решение.
- **Забравяне за гранични случаи** – Обработвайте правилно базовите случаи, за да избегнете runtime грешки.

## 7. Short Retrieval Quiz
1. Какво е основното предимство на динамичното програмиране спрямо чистата рекурсия?  
2. Какво означава "optimal substructure"?  
3. Кога използваме memoization, а кога tabulation?  
4. Какво представлява състоянието в DP?  
5. Какво е припокриващ се подпроблем?  
6. Дайте пример за класически DP проблем.  
7. Как може да оптимизираме пространствената сложност на DP решение?

## 8. Quick Recap
- Динамичното програмиране решава проблеми чрез разбиване на припокриващи се подпроблеми и запаметяване на решенията им.
- Ключови концепции са припокриващи се подпроблеми, оптимална подструктура, memoization и tabulation.
- Класическите DP шаблони помагат да се идентифицират и решават типични задачи като Knapsack, LCS и др.
- Винаги дефинирайте ясно състоянията и преходите между тях.
- Започнете с коректно решение, след което оптимизирайте по време и памет.
- Често срещани грешки са неправилно дефинирани състояния и пропуснати базови случаи.
- Практиката с реални задачи е най-добрият начин за усвояване на DP.

## 9. Spaced Review Plan

| Interval  | Review Prompt                                          |
|-----------|-------------------------------------------------------|
| 1 day     | Обяснете с прости думи какво е динамично програмиране. |
| 3 days    | Опишете разликите между memoization и tabulation.     |
| 1 week    | Решете класически DP проблем (например Knapsack).       |
| 1 month   | Прегледайте и оптимизирайте съществуващо DP решение.   |