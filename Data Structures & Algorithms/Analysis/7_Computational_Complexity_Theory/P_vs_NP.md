# P_vs_NP

## 1. Activate Prior Knowledge

- Какво означава, че една задача е „лесна“ или „трудна“ за компютър да реши?
- Можете ли да си представите разлика между намиране на решение и проверка дали дадено решение е вярно?
- Как мислите, защо въпросът дали P = NP е важен за разработката на алгоритми в изкуствения интелект и софтуерното инженерство?

## 2. Overview

P vs NP е един от най-големите нерешени проблеми в теоретичната информатика и математиката. Той се занимава с въпроса дали всички проблеми, чиито решения могат да бъдат проверени бързо (в полиномиално време), могат и да бъдат намерени бързо. Това е фундаментален въпрос за ефективността на алгоритмите и границите на изчислителната мощ.

В контекста на изкуствения интелект и софтуерното инженерство, този проблем определя дали сложни задачи като оптимизация, планиране и доказване на свойства могат да бъдат решени ефективно или остават практически нерешими. Ако P = NP, много задачи, които днес смятаме за изключително трудни, биха могли да бъдат решавани бързо, което би променило из основи компютърните науки.

Този въпрос също така влияе върху сигурността на криптографските системи, тъй като много криптографски алгоритми разчитат на това, че определени задачи са трудни за решаване, но лесни за проверка.

## 3. Key Concepts

- **P (Polynomial time)** – Клас задачи, които могат да бъдат решени от алгоритъм за време, растящо полиномиално с размера на входа. Представете си задачи, които компютърът може да реши „бързо“ и ефективно.
- **NP (Nondeterministic Polynomial time)** – Клас задачи, за които дадено решение може да бъде проверено за полиномиално време, но не е ясно дали може да бъде намерено бързо. Аналогия: ако някой ви даде отговор, можете бързо да проверите дали е правилен, но да го намерите сами може да е трудно.
- **NP-complete** – Най-трудните задачи в NP, за които ако се намери бърз алгоритъм, всички задачи в NP могат да се решават бързо. Те са „центърът“ на проблема P vs NP.
- **Reduction (Редукция)** – Процесът на преобразуване на един проблем в друг, за да се покаже, че ако вторият е лесен, и първият също ще бъде лесен. Това е като да преведеш задача на друг език, за да я решиш по-лесно.
- **Verifier (Проверител)** – Алгоритъм, който проверява дали дадено решение е вярно за даден проблем, и работи в полиномиално време.

## 4. Step-by-step Learning Path

1. **Фокус:** Разберете дефинициите на класовете P и NP.  
   **Задача:** Прочетете и формулирайте с прости думи какво означава „полиномиално време“.  
   **Въпроси:** Какво означава алгоритъм да работи в полиномиално време? Защо е важно?

2. **Фокус:** Изучете примери на задачи в P и NP.  
   **Задача:** Намерете пример за задача в P (напр. сортиране) и задача в NP (напр. проверка на решение на судоку).  
   **Въпроси:** Как се различава намирането на решение от проверката му?

3. **Фокус:** Разберете концепцията за NP-complete задачи и редукции.  
   **Задача:** Прочетете за SAT (Boolean satisfiability problem) и защо е NP-complete. Опитайте да намерите пример за редукция от SAT към друг проблем.  
   **Въпроси:** Какво означава, че SAT е NP-complete? Какво е редукция?

4. **Фокус:** Изследвайте последствията от P = NP и P ≠ NP.  
   **Задача:** Напишете кратко есе за това какво би означавало доказателство, че P = NP, за индустрията и науката.  
   **Въпроси:** Какви биха били практическите последици от P = NP? Защо много учени смятат, че P ≠ NP?

5. **Фокус:** Приложете знанията в код.  
   **Задача:** Имплементирайте прост алгоритъм за проверка на решение на NP задача (напр. проверка на решение на судоку).  
   **Въпроси:** Каква е разликата между алгоритъма за проверка и алгоритъма за решаване?

## 5. Examples

- **Пример 1: Сортиране (в P)**  
  Сортирането на списък с числа може да се направи за време O(n log n), което е полиномиално. Това означава, че сортирането е в клас P.

- **Пример 2: Судоку проверка (в NP)**  
  Ако ви дадат попълнена судоку таблица, можете бързо да проверите дали решението е валидно, но намирането на решението от нулата е по-трудно.

- **Пример 3: SAT задача (NP-complete)**  
  Boolean satisfiability problem (SAT) пита дали съществува комбинация от стойности на булеви променливи, която прави дадена формула вярна. Проверка на дадено решение е бърза, но намирането му е трудно.

```python
# Проверка на решение за судоку (примерен код)
def is_valid_sudoku(board):
    def is_valid_block(block):
        block = [x for x in block if x != '.']
        return len(block) == len(set(block))
    
    for i in range(9):
        if not is_valid_block([board[i][j] for j in range(9)]):  # редове
            return False
        if not is_valid_block([board[j][i] for j in range(9)]):  # колони
            return False
    
    for i in (0, 3, 6):
        for j in (0, 3, 6):
            block = [board[x][y] for x in range(i, i+3) for y in range(j, j+3)]
            if not is_valid_block(block):
                return False
    return True
```

## 6. Common Pitfalls

- **Смесване на намиране и проверка на решение** – Често се бърка дали задачата е лесна за намиране или само за проверка. Важно е да се разбере, че NP означава „лесна за проверка“, а не непременно „лесна за решаване“.
- **Подценяване на значението на редукциите** – Редукциите са ключови за разбирането на NP-complete задачи. Без тях не можем да класифицираме задачи правилно.
- **Прекалено опростяване на проблема** – P vs NP е дълбок и сложен въпрос. Не бива да се приема, че „просто“ ще намерим бърз алгоритъм за NP задачи без сериозни доказателства.
- **Игнориране на практическите аспекти** – Въпреки теоретичната сложност, много NP задачи имат ефективни приближени или евристични решения, които са полезни в реалния свят.

## 7. Short Retrieval Quiz

1. Какво означава класът P?
2. Какво е разликата между P и NP?
3. Какво представлява NP-complete задача?
4. Какво е редукция и защо е важна?
5. Какво би означавало, ако се докаже, че P = NP?
6. Дайте пример за задача в NP.
7. Защо проверката на решение е по-лесна от намирането му при NP задачи?

## 8. Quick Recap

- P е клас задачи, решими бързо (полиномиално време).
- NP е клас задачи, чиито решения могат да се проверят бързо.
- NP-complete задачите са най-трудните в NP и свързват всички NP задачи чрез редукции.
- Въпросът дали P = NP е фундаментален за теорията на алгоритмите и има огромни практически последствия.
- Редукциите са инструмент за класифициране на задачи.
- Проверка на решение е различна от намиране на решение.
- Доказателството за P = NP или P ≠ NP остава нерешено и е една от най-големите загадки в компютърните науки.

## 9. Spaced Review Plan

| Време след учене | Промпт за преговор                                    |
|------------------|-------------------------------------------------------|
| 1 ден            | Обяснете с прости думи какво е P и NP.                |
| 3 дни            | Дайте пример за NP-complete задача и обяснете защо.  |
| 1 седмица        | Опишете какво представлява редукцията между задачи.  |
| 1 месец          | Обсъдете практическите последствия от P = NP.         |