# Heap_Sort

## 1. Activate Prior Knowledge
- Какво представлява сортирането и защо е важно в софтуерните системи, особено при обработка на големи данни?
- Какви структури от данни познавате, които поддържат бърз достъп до максимума или минимума?
- Как бихте използвали сортиране в контекста на приоритетни опашки в AI алгоритми като A* или в системи за планиране?

## 2. Overview
Heap Sort е алгоритъм за сортиране, базиран на структурата от данни "купчина" (heap). Той използва двоична купчина, за да организира елементите така, че най-големият (или най-малкият) елемент винаги да е на върха, което позволява ефективно извличане и сортиране.

Heap Sort се вписва в категорията на алгоритмите с времева сложност O(n log n), което го прави стабилен избор за сортиране на големи масиви с гарантирана производителност. За разлика от Quick Sort, Heap Sort не зависи от случайния избор на пивот и има по-предсказуеми времена на изпълнение.

В контекста на AI и софтуерното инженерство, Heap Sort е полезен при реализация на приоритетни опашки, които са основа за алгоритми за търсене и оптимизация. Разбирането на Heap Sort помага да се осъзнаят по-дълбоко принципите на управление на приоритети и ефективно сортиране.

## 3. Key Concepts
- **Heap (Купчина)** – специална дървовидна структура, която удовлетворява свойството на купчината: всеки родителски възел е по-голям (max-heap) или по-малък (min-heap) от своите деца. Мислете за купчината като за "пирамида", където върхът е най-важният елемент.
- **Max-Heap** – купчина, в която всеки възел е по-голям или равен на децата си. Това позволява бързо намиране на максимума.
- **Heapify (Купчинно подреждане)** – процесът на преобразуване на масив в купчина или възстановяване на свойството на купчината след промяна.
- **In-place Sorting** – Heap Sort работи директно върху входния масив, без да изисква допълнителна памет, което го прави ефективен по отношение на пространството.
- **Time Complexity (Времева сложност)** – Heap Sort винаги работи за O(n log n), където n е броят на елементите, което го прави надежден при големи данни.

## 4. Step-by-step Learning Path
1. **Разберете структурата на купчината**
   - Фокус: Научете как се изгражда max-heap и какви са неговите свойства.
   - Задача: Ръчно конструирайте max-heap от масив с 7 елемента.
   - Въпроси: Какво е свойството на max-heap? Защо върхът винаги е максималният елемент?

2. **Изучете алгоритъма Heapify**
   - Фокус: Разберете как се възстановява свойството на купчината след промяна.
   - Задача: Имплементирайте функция heapify върху частичен масив.
   - Въпроси: Какво се случва, ако нарушим свойството на купчината? Как heapify го поправя?

3. **Изградете купчина от масив**
   - Фокус: Научете как да превърнете произволен масив в max-heap.
   - Задача: Имплементирайте buildHeap функция и тествайте с различни масиви.
   - Въпроси: Защо buildHeap е по-ефективен от повтарящо се heapify за всеки елемент?

4. **Реализирайте Heap Sort**
   - Фокус: Използвайте купчината за сортиране на масив.
   - Задача: Напишете пълна Heap Sort функция, която сортира масив на място.
   - Въпроси: Как Heap Sort използва свойството на купчината за сортиране? Каква е времевата сложност?

5. **Приложете Heap Sort в реален проект**
   - Фокус: Интегрирайте Heap Sort в система, която изисква сортиране или приоритетна опашка.
   - Задача: Използвайте Heap Sort за сортиране на задачи по приоритет в симулация на scheduler.
   - Въпроси: Как Heap Sort подобрява управлението на приоритети? Кога бихте предпочели Heap Sort пред други алгоритми?

## 5. Examples

### Пример 1: Конвертиране на масив в max-heap
```python
def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[left] > arr[largest]:
        largest = left

    if right < n and arr[right] > arr[largest]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

arr = [3, 9, 2, 1, 4, 5]
n = len(arr)
for i in range(n//2 - 1, -1, -1):
    heapify(arr, n, i)
print(arr)  # Изход: [9, 4, 5, 1, 3, 2]
```

### Пример 2: Пълна Heap Sort имплементация
```python
def heap_sort(arr):
    n = len(arr)

    # Построяване на max-heap
    for i in range(n//2 - 1, -1, -1):
        heapify(arr, n, i)

    # Извличане на елементи от купчината
    for i in range(n-1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]  # Преместване на текущия максимум в края
        heapify(arr, i, 0)

arr = [12, 11, 13, 5, 6, 7]
heap_sort(arr)
print(arr)  # Изход: [5, 6, 7, 11, 12, 13]
```

### Пример 3: Използване на Heap Sort за приоритетна опашка
В системи за планиране, където задачите имат приоритет, Heap Sort може да сортира задачите по приоритет, позволявайки изпълнението им в правилен ред.

## 6. Common Pitfalls
- **Неправилно индексиране при heapify** – често грешка е объркване между индекси на родители и деца, което води до нарушаване на свойството на купчината.
- **Забравяне да се обнови размерът на купчината при сортиране** – при изваждане на максимума размерът на купчината трябва да се намалява, за да не се включват вече сортирани елементи.
- **Използване на min-heap вместо max-heap без адаптация** – Heap Sort изисква max-heap за сортиране във възходящ ред; използването на min-heap без промяна на логиката води до грешен резултат.
- **Прекомерно използване на допълнителна памет** – Heap Sort е in-place алгоритъм; използването на допълнителни структури може да намали ефективността.
- **Непознаване на времевата сложност** – подценяването на O(n log n) може да доведе до избор на Heap Sort в неподходящи ситуации, където по-бързи алгоритми са възможни.

## 7. Short Retrieval Quiz
1. Какво е основното свойство на max-heap?
2. Какво прави функцията heapify?
3. Каква е времевата сложност на Heap Sort?
4. Защо Heap Sort е in-place алгоритъм?
5. Как Heap Sort използва структурата на купчината за сортиране?
6. Какво се случва с размера на купчината по време на сортиране?
7. В какви ситуации Heap Sort е предпочитан пред Quick Sort?

## 8. Quick Recap
- Heap Sort използва структурата max-heap за ефективно сортиране.
- Свойството на купчината гарантира, че върхът е максималният елемент.
- Процесът heapify възстановява свойството на купчината след промени.
- Алгоритъмът е in-place и има времева сложност O(n log n).
- Heap Sort е стабилен избор за системи с приоритетни опашки и големи масиви.
- Често срещани грешки включват неправилно индексиране и управление на размера на купчината.
- Разбирането на Heap Sort подобрява уменията за работа с приоритети и оптимизация.

## 9. Spaced Review Plan

| Време след учене | Промпт за преглед                                    |
|-------------------|-----------------------------------------------------|
| 1 ден             | Обяснете свойството на max-heap и функцията heapify.|
| 3 дни             | Опишете стъпките за изграждане на купчина от масив. |
| 1 седмица         | Имплементирайте Heap Sort и обяснете неговата сложност.|
| 1 месец           | Сравнете Heap Sort с други алгоритми за сортиране и приложението му в AI системи.|