# Designing_custom_data_structures

## 1. Activate Prior Knowledge
- Какви са основните типове данни, които използвате в програмирането, и как те влияят върху производителността на софтуерните системи?
- Какво представлява абстракцията на данни и защо е важно да създаваме собствени структури, вместо да използваме само вградените?
- Как мислите, че изборът на структура от данни може да повлияе на ефективността на AI алгоритми или големи софтуерни системи?

## 2. Overview
Дизайнът на персонализирани структури от данни е фундаментален процес в софтуерното инженерство и разработката на AI системи. Той позволява създаването на оптимизирани, адаптирани към конкретни задачи структури, които подобряват ефективността, управлението на паметта и четимостта на кода. В по-широк контекст, тези структури служат като основа за алгоритми и системи, които обработват големи обеми информация или изискват специфични операции.

В съвременните AI системи, където данните са огромни и комплексни, правилно проектираните структури могат да ускорят обработката и да намалят изчислителните ресурси. Освен това, те улесняват модулността и поддръжката на софтуера, което е критично за дългосрочната устойчивост на проектите.

Разбирането на принципите за проектиране на структури от данни дава възможност за създаване на по-гъвкави и мащабируеми системи, които могат да се адаптират към променящите се изисквания и натоварвания.

## 3. Key Concepts
- **Абстрактен тип данни (ADT)** – Описание на поведение и операции върху данни, без да се уточнява конкретната им реализация. Мислете за ADT като за договор, който структурата трябва да спазва.
- **Инкапсулация** – Скриване на вътрешната реализация на структурата, предоставяйки само необходимите методи за взаимодействие. Подобно на дистанционно управление, което не ви показва вътрешните схеми.
- **Времева сложност** – Мярка за времето, необходимо за изпълнение на операция спрямо размера на данните. Анализът помага да се избере най-подходящата структура.
- **Паметна ефективност** – Колко памет заема структурата и как се управлява динамичното разпределение. Представете си куфар, който трябва да бъде достатъчно голям, но не и прекалено тежък.
- **Свързани списъци, дървета, хеш таблици** – Често използвани структури с различни свойства за достъп и модификация на данни.
- **Имутабилност** – Структури, които не се променят след създаването си, важни за паралелно програмиране и AI модели.

## 4. Step-by-step Learning Path
1. **Разгледайте основните вградени структури от данни**  
   - Фокус: Разберете как работят масиви, списъци и речници.  
   - Задача: Имплементирайте прост динамичен масив на избран език.  
   - Въпроси: Как се осъществява достъпът до елемент? Какво е времето за добавяне на елемент?

2. **Изучете абстрактните типове данни и тяхната спецификация**  
   - Фокус: Научете се да дефинирате интерфейс за структура от данни.  
   - Задача: Опишете интерфейс за стек или опашка.  
   - Въпроси: Какви операции са задължителни? Какви са ограниченията?

3. **Проектирайте собствена структура за специфична задача**  
   - Фокус: Изберете проблем и създайте структура, оптимизирана за него.  
   - Задача: Имплементирайте хеш таблица с отворено адресиране.  
   - Въпроси: Как се справя с колизии? Каква е сложността на търсене?

4. **Оптимизирайте и анализирайте производителността**  
   - Фокус: Измерете времето и паметта на вашата структура.  
   - Задача: Сравнете производителността на вашата хеш таблица с вградената.  
   - Въпроси: Кои операции са най-бавни? Какво може да се подобри?

5. **Интегрирайте структурата в по-голяма система**  
   - Фокус: Вижте как структурата взаимодейства с други компоненти.  
   - Задача: Използвайте структурата в малък AI алгоритъм (напр. класификация).  
   - Въпроси: Как структурата влияе на цялостната ефективност? Как се поддържа кодът?

## 5. Examples
### Пример 1: Имплементация на стек с масив
```python
class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        if not self.is_empty():
            return self.items.pop()
        raise IndexError("pop from empty stack")

    def is_empty(self):
        return len(self.items) == 0
```

### Пример 2: Хеш таблица с отворено адресиране (линейно пробиране)
```python
class HashTable:
    def __init__(self, size=10):
        self.size = size
        self.table = [None] * size

    def _hash(self, key):
        return hash(key) % self.size

    def insert(self, key, value):
        idx = self._hash(key)
        start_idx = idx
        while self.table[idx] is not None:
            if self.table[idx][0] == key:
                self.table[idx] = (key, value)
                return
            idx = (idx + 1) % self.size
            if idx == start_idx:
                raise Exception("Hash table is full")
        self.table[idx] = (key, value)

    def get(self, key):
        idx = self._hash(key)
        start_idx = idx
        while self.table[idx] is not None:
            if self.table[idx][0] == key:
                return self.table[idx][1]
            idx = (idx + 1) % self.size
            if idx == start_idx:
                break
        raise KeyError(f"{key} not found")
```

### Пример 3: Дърво за търсене (BST) – основни операции
```python
class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None

def insert(root, key):
    if root is None:
        return Node(key)
    if key < root.key:
        root.left = insert(root.left, key)
    else:
        root.right = insert(root.right, key)
    return root
```

## 6. Common Pitfalls
- **Пренебрегване на времевата сложност** – Избиране на структура без анализ на операции, което води до бавна работа при големи данни. Решение: винаги анализирайте алгоритмичната сложност.
- **Лоша инкапсулация** – Излагане на вътрешни данни директно, което затруднява поддръжката и води до грешки. Решение: използвайте интерфейси и методи за достъп.
- **Недостатъчно тестване при гранични случаи** – Пропускане на проверки при празни структури или при пълна хеш таблица. Решение: пишете тестове за всички възможни сценарии.
- **Прекомерна оптимизация в началото** – Опит за усложняване на структурата без нужда, което забавя разработката. Решение: започнете с прост дизайн и оптимизирайте при нужда.
- **Неправилно управление на паметта** – Особено при езици без автоматично събиране на боклук, което води до изтичане на памет. Решение: следете за освобождаване на ресурси.

## 7. Short Retrieval Quiz
1. Какво е абстрактен тип данни и защо е важен?
2. Каква е разликата между масив и свързан списък?
3. Какво представлява хеш таблица и как се справя с колизии?
4. Защо е важно да инкапсулираме данните в структурата?
5. Какво означава времева сложност O(1)?
6. Кога бихте избрали дърво пред масив?
7. Какви са предимствата на имутабилните структури?

## 8. Quick Recap
- Персонализираните структури от данни са ключови за ефективността и адаптивността на софтуерните системи.
- Абстрактните типове данни дефинират интерфейс, отделен от реализацията.
- Времевата и паметната сложност са критични при избора и дизайна на структура.
- Инкапсулацията подобрява надеждността и поддръжката на кода.
- Практическата имплементация и тестване са задължителни за успешен дизайн.
- Оптимизацията трябва да бъде базирана на реални нужди и измервания.
- Разбирането на различните структури и техните свойства улеснява решаването на сложни инженерни задачи.

## 9. Spaced Review Plan

| Време       | Прегледна задача                                      |
|-------------|------------------------------------------------------|
| 1 ден       | Отговорете на краткия тест и прегледайте ключовите концепции. |
| 3 дни       | Имплементирайте една от структурите от примера и анализирайте сложността. |
| 1 седмица   | Създайте малък проект, използващ персонализирана структура за конкретна задача. |
| 1 месец     | Прегледайте всички стъпки и сравнете различни структури за една и съща задача. |