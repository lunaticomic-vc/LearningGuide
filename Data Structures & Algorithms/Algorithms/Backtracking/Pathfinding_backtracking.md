# Pathfinding_backtracking

## 1. Activate Prior Knowledge

- Какво представлява алгоритъмът за търсене на път (pathfinding) и в какви ситуации се използва в софтуерните системи?
- Какво знаете за метода на обратно проследяване (backtracking) и как той може да помогне при решаване на проблеми с търсене?
- Можете ли да предвидите как backtracking може да се приложи за намиране на път в лабиринт или граф?

## 2. Overview

Backtracking е метод за решаване на проблеми чрез систематично изследване на всички възможни решения и връщане назад (backtrack), когато се установи, че даден път не води до валидно решение. В контекста на pathfinding, backtracking се използва за намиране на път от начална точка до цел, като се изследват всички възможни маршрути.

Този подход е особено полезен при задачи, където пространството на решения е голямо и няма предварително известен оптимален път. Backtracking позволява да се избегнат безсмислени пътища, като се връща назад при достигане на задънена улица.

В по-широк контекст, backtracking е част от клас алгоритми за търсене и оптимизация, които се използват в изкуствения интелект, роботиката и софтуерното инженерство за решаване на сложни проблеми като лабиринти, пъзели и задачи с ограничения.

## 3. Key Concepts

- **Backtracking** – метод за решаване на проблеми чрез рекурсивно изследване на всички възможни опции и връщане назад при неуспех. Можете да го представите като "проба и грешка", но систематизирана и организирана.
- **Pathfinding** – процесът на намиране на път от една точка до друга в граф или мрежа. Аналогия: намиране на най-краткия маршрут в градска карта.
- **State Space** – всички възможни състояния или позиции, които алгоритъмът може да посети по време на търсенето.
- **Pruning** – техника за отрязване на части от дървото на решенията, които не водят до валидно решение, за да се подобри ефективността.
- **Recursive Exploration** – използване на рекурсия за изследване на възможните пътища, където всяко рекурсивно извикване разглежда следващата стъпка.
- **Dead End** – състояние, от което не може да се продължи към целта, което налага връщане назад.

## 4. Step-by-step Learning Path

1. **Разберете основите на рекурсията и backtracking**
   - Фокус: Как работи рекурсията и как backtracking използва рекурсия за търсене.
   - Задача: Напишете рекурсивна функция, която изброява всички възможни комбинации на символи от даден набор.
   - Въпроси: Какво се случва, когато функцията достигне "dead end"? Как се връща назад?

2. **Запознайте се с представянето на лабиринти и графи**
   - Фокус: Как да моделираме лабиринт или граф като матрица или списък със съседни върхове.
   - Задача: Създайте двумерна матрица, която представя лабиринт с проходими и непреходими клетки.
   - Въпроси: Какво означава дадена клетка да е "посетена"? Защо е важно да отбелязваме посетените клетки?

3. **Имплементирайте базов backtracking алгоритъм за намиране на път**
   - Фокус: Изследване на всички възможни посоки и връщане назад при задънена улица.
   - Задача: Напишете функция, която намира път от начална до крайна точка в лабиринт, използвайки backtracking.
   - Въпроси: Какво се случва, ако няма път? Как алгоритъмът избягва безкрайни цикли?

4. **Оптимизирайте чрез pruning и маркиране на посетени състояния**
   - Фокус: Как да избегнете излишни изследвания и да подобрите ефективността.
   - Задача: Добавете маркиране на посетени клетки и отрязване на вече изследвани пътища.
   - Въпроси: Какво е значението на pruning? Какво би се случило без маркиране на посетени клетки?

5. **Приложете backtracking в по-сложни сценарии**
   - Фокус: Използване на backtracking за пъзели, задачи с ограничения и динамично променящи се графи.
   - Задача: Решете пъзел "N-Queens" или подобна задача с backtracking.
   - Въпроси: Как backtracking се адаптира към различни типове проблеми? Какви са ограниченията му?

## 5. Examples

### Пример 1: Намиране на път в лабиринт (Python)

```python
def backtrack(maze, x, y, path, visited):
    rows, cols = len(maze), len(maze[0])
    if x < 0 or y < 0 or x >= rows or y >= cols or maze[x][y] == 1 or visited[x][y]:
        return False
    path.append((x, y))
    visited[x][y] = True
    if (x, y) == (rows - 1, cols - 1):
        return True
    if (backtrack(maze, x + 1, y, path, visited) or
        backtrack(maze, x, y + 1, path, visited) or
        backtrack(maze, x - 1, y, path, visited) or
        backtrack(maze, x, y - 1, path, visited)):
        return True
    path.pop()
    return False

maze = [
    [0, 0, 1, 0],
    [1, 0, 1, 0],
    [0, 0, 0, 0],
    [0, 1, 1, 0]
]
path = []
visited = [[False]*len(maze[0]) for _ in range(len(maze))]
if backtrack(maze, 0, 0, path, visited):
    print("Path found:", path)
else:
    print("No path found")
```

### Пример 2: Решаване на N-Queens с backtracking (Python)

```python
def is_safe(board, row, col):
    for i in range(row):
        if board[i] == col or \
           board[i] - i == col - row or \
           board[i] + i == col + row:
            return False
    return True

def solve_n_queens(n, row=0, board=[], solutions=[]):
    if row == n:
        solutions.append(board[:])
        return
    for col in range(n):
        if is_safe(board, row, col):
            board.append(col)
            solve_n_queens(n, row + 1, board, solutions)
            board.pop()

solutions = []
solve_n_queens(8, 0, [], solutions)
print(f"Number of solutions for 8-queens: {len(solutions)}")
```

## 6. Common Pitfalls

- **Липса на маркиране на посетени състояния** – води до безкрайни цикли и неефективност. Винаги отбелязвайте кои възли или клетки са вече посетени.
- **Прекалено широко търсене без pruning** – изследването на всички възможни пътища без отрязване може да бъде експоненциално бавно.
- **Неправилно връщане назад (backtracking)** – забравяне да се премахне текущото състояние от пътя при връщане назад води до грешки в резултата.
- **Необработване на гранични случаи** – например, когато началната или крайната точка са блокирани.
- **Използване на backtracking за задачи, където има по-ефективни алгоритми** – например, за кратък път в граф с тежести е по-добре да се използва Dijkstra или A*.

## 7. Short Retrieval Quiz

1. Какво представлява backtracking и как се различава от обикновеното търсене?
2. Защо е важно да маркираме посетените състояния при backtracking?
3. Какво означава "pruning" в контекста на backtracking?
4. Как backtracking намира път в лабиринт?
5. Какви са основните ограничения на backtracking при големи пространства на състояния?
6. Какво представлява "dead end" и как backtracking се справя с него?
7. В какви ситуации е по-добре да се използват други алгоритми вместо backtracking?

## 8. Quick Recap

- Backtracking е рекурсивен метод за систематично изследване на всички възможни решения с връщане назад при неуспех.
- В pathfinding backtracking намира път, като изследва възможните маршрути и избягва задънени улици.
- Маркирането на посетени състояния е ключово за избягване на безкрайни цикли и подобряване на ефективността.
- Pruning позволява отрязване на неизгодни пътища и ускорява търсенето.
- Backtracking е универсален, но може да бъде бавен при големи пространства на състояния.
- Подходящ е за задачи с ограничения и пъзели, където други алгоритми не са приложими.
- Практическите задачи като лабиринти и N-Queens демонстрират силата и ограниченията на метода.

## 9. Spaced Review Plan

| Време след учене | Промпт за преглед                                   |
|-------------------|----------------------------------------------------|
| 1 ден             | Обяснете с прости думи как работи backtracking.    |
| 3 дни             | Опишете как backtracking намира път в лабиринт.    |
| 1 седмица         | Избройте основните грешки при имплементация.       |
| 1 месец           | Сравнете backtracking с други pathfinding алгоритми.|