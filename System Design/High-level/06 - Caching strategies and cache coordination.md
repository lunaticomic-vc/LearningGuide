# 06 - Caching strategies and cache coordination

## 1. Activate Prior Knowledge

- Какво е кеш и защо го използваме в компютърните системи и софтуерното инженерство?
- Можете ли да си спомните случай, когато промяна в данните не се е отразила веднага в дадено приложение? Какво може да е причинило това?
- Какви са потенциалните предизвикателства при използване на кеш в разпределени системи или AI приложения?

## 2. Overview

Кеширането е техника за временно съхранение на често използвани или скъпо струващи за изчисление данни, с цел ускоряване на достъпа и намаляване на натоварването върху източника на истината (например база данни или външен API). В съвременните софтуерни системи, особено при мащабируеми уеб приложения и AI системи, кеширането е критично за постигане на висока производителност и ниска латентност.

Изборът на подходяща кешираща стратегия зависи от характера на данните, честотата на обновяване и изискванията за консистентност. В разпределени среди, където множество сървъри или услуги споделят кеш, възниква необходимост от координация между тях, за да се избегнат несъответствия и остарели данни.

Правилното прилагане на кеширане и координация на кеша може значително да подобри потребителското изживяване, да намали разходите и да увеличи устойчивостта на системата. Въпреки това, неправилната употреба може да доведе до трудни за откриване бъгове, загуба на данни или неконсистентни резултати.

## 3. Key Concepts

- Cache (Кеш) – Бърза памет или слой за съхранение, който държи копия на често използвани данни, за да ускори достъпа до тях. Мислете за кеша като за чекмедже с най-често използваните инструменти на работното ви място.
- Cache Invalidation (Инвалидиране на кеш) – Процесът на премахване или обновяване на остарели данни в кеша, за да се гарантира точност. Подобно е на това да изхвърлите развалена храна от хладилника.
- Cache Consistency (Консистентност на кеша) – Степента, до която кешираните данни отразяват актуалното състояние на източника. Представете си, че всички копия на един документ трябва да са еднакви.
- Write-through, Write-back, Write-around – Различни стратегии за това кога и как се записват данните в кеша и основното хранилище.
- Cache Coordination (Координация на кеша) – Механизми за синхронизиране на кеша между множество възли или услуги, така че всички да виждат актуални данни.
- Cache Stampede – Явление, при което много заявки едновременно се опитват да обновят един и същ кеширан елемент, често водещо до претоварване.
- TTL (Time To Live) – Време, за което даден елемент остава валиден в кеша, преди да бъде автоматично премахнат.

## 4. Step-by-step Learning Path

1. **Разберете основите на кеша**
   - Фокус: Какво е кеш и защо се използва.
   - Практическа задача: Намерете място в текущия си проект, където може да се добави кеширане (например резултат от скъп API call).
   - Въпроси: Как кешът ускорява достъпа до данни? Какви са потенциалните рискове?

2. **Изучете основните кеширащи стратегии**
   - Фокус: Write-through, write-back, write-around, TTL.
   - Практическа задача: Имплементирайте прост кеш с TTL в избран език (например Python dict с време на валидност).
   - Въпроси: Каква е разликата между write-through и write-back? Кога бихте използвали TTL?

3. **Разберете нуждата от координация на кеша**
   - Фокус: Проблеми при разпределени кешове (несъответствия, cache stampede).
   - Практическа задача: Симулирайте сценарий с два сървъра, които споделят кеш и обновяват едни и същи данни.
   - Въпроси: Какви проблеми могат да възникнат без координация? Какво е cache stampede?

4. **Изучете техники за координация на кеша**
   - Фокус: Инвалидиране, pub/sub, distributed locks.
   - Практическа задача: Използвайте Redis pub/sub за синхронизиране на кеш между два процеса.
   - Въпроси: Как pub/sub помага при координация? Какви са ограниченията на distributed locks?

5. **Оценете и оптимизирайте кеша**
   - Фокус: Метрики (hit rate, latency), мониторинг и tuning.
   - Практическа задача: Добавете логване на cache hits/misses във вашия кеш и анализирайте резултатите.
   - Въпроси: Какво означава висок cache hit rate? Как бихте подобрили кеша при нисък hit rate?

## 5. Examples

### Пример 1: Кеширане на резултати от ML inference

```python
import time

cache = {}
TTL = 60  # seconds

def expensive_inference(input_data):
    # Скъпа ML операция
    time.sleep(2)
    return f"Result for {input_data}"

def get_inference(input_data):
    now = time.time()
    if input_data in cache:
        value, timestamp = cache[input_data]
        if now - timestamp < TTL:
            return value  # Cache hit
    # Cache miss
    result = expensive_inference(input_data)
    cache[input_data] = (result, now)
    return result
```

### Пример 2: Инвалидиране на кеш при обновяване на данни

Когато потребител обнови профила си, изтриваме кеша за този потребител:

```python
def update_user_profile(user_id, new_data):
    db.update(user_id, new_data)
    cache.pop(user_id, None)  # Инвалидиране на кеша
```

### Пример 3: Координация на кеша с Redis Pub/Sub

Един сървър публикува събитие за обновяване, другите слушат и инвалидизират локалния кеш.

```python
import redis

r = redis.Redis()
p = r.pubsub()
p.subscribe('cache_invalidation')

def on_message(message):
    if message['type'] == 'message':
        cache_key = message['data'].decode()
        cache.pop(cache_key, None)

# В друг процес:
r.publish('cache_invalidation', 'user:123')
```

## 6. Common Pitfalls

- **Остарели данни (Stale data):** Забравено инвалидиране води до показване на стари резултати. Решение: Винаги инвалидирайте или обновявайте кеша при промяна на данните.
- **Cache stampede:** Множество заявки едновременно обновяват кеша. Решение: Използвайте locking или singleflight механизми.
- **Прекалено кратък или дълъг TTL:** Кратък TTL намалява ефективността, дълъг TTL увеличава риска от остарели данни. Решение: Тествайте и настройвайте TTL според нуждите.
- **Липса на мониторинг:** Без наблюдение не знаете дали кешът работи ефективно. Решение: Логвайте cache hits/misses и анализирайте.
- **Неправилна координация в разпределени среди:** Може да доведе до несъответствия. Решение: Използвайте pub/sub или централизирани кешове.

## 7. Short Retrieval Quiz

1. Каква е основната цел на кеширането в софтуерните системи?
2. Какво представлява cache invalidation и защо е важно?
3. Каква е разликата между write-through и write-back кеширане?
4. Какво е cache stampede и как може да се предотврати?
5. Как pub/sub помага при координация на кеша?
6. Какви метрики бихте използвали за оценка на ефективността на кеша?
7. Какви са рисковете при неправилно избран TTL?

## 8. Quick Recap

- Кешът ускорява достъпа до данни, като съхранява често използвани резултати.
- Има различни стратегии за кеширане и запис – write-through, write-back, write-around.
- Инвалидиране и координация на кеша са критични за консистентност, особено в разпределени системи.
- TTL определя колко дълго даден елемент остава валиден в кеша.
- Cache stampede може да претовари системата и трябва да се предотвратява.
- Мониторингът на cache hits/misses е важен за оптимизация.
- Изборът на подходяща стратегия зависи от нуждите на приложението и характера на данните.

## 9. Spaced Review Plan

| Review Time | Prompt                                                      |
|-------------|-------------------------------------------------------------|
| 1 day       | Обяснете разликата между write-through и write-back кеширане. |
| 3 days      | Опишете как бихте координирали кеша в разпределена система.  |
| 1 week      | Дайте пример за cache stampede и как бихте го предотвратили. |
| 1 month     | Кои са основните метрики за оценка на кеша и какво показват? |