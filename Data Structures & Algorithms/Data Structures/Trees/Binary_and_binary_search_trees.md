# Binary_and_binary_search_trees

## 1. Activate Prior Knowledge
- Какво представлява двоичното дърво и какви са основните му характеристики?
- Какво е търсене в структура от данни и защо е важно за ефективността на алгоритмите?
- Как бихте използвали двоично дърво в контекста на AI системи, например за бързо търсене или сортиране на данни?

## 2. Overview
Двоичното дърво е фундаментална структура от данни, в която всеки възел има максимум два наследника – ляв и десен. Тази структура е особено полезна за организиране на данни по начин, който позволява бърз достъп, вмъкване и изтриване.

Двоичното дърво за търсене (Binary Search Tree, BST) е специален вид двоично дърво, при което за всеки възел всички стойности в лявото поддърво са по-малки, а в дясното – по-големи от стойността на възела. Това свойство позволява ефективно търсене, което е от ключово значение в много софтуерни системи и AI приложения, където бързият достъп до данни е критичен.

В по-широк контекст, BST се използват в бази данни, файлови системи и различни алгоритми за сортиране и търсене. Разбирането на тяхната структура и поведение е основа за изграждане на по-сложни и оптимизирани системи.

## 3. Key Concepts
- **Node (Възел)** – Основният елемент на дървото, съдържащ стойност и препратки към ляв и десен наследник. Можем да си го представим като кутия с две врати.
- **Binary Tree (Двоично дърво)** – Дърво, в което всеки възел има не повече от два наследника. Аналогично на семейно дърво с максимум двама деца.
- **Binary Search Tree (BST)** – Двоично дърво с допълнително правило: стойностите в лявото поддърво са по-малки, а в дясното – по-големи от стойността на възела.
- **Traversal (Обхождане)** – Процес на посещение на всички възли в дървото по определен ред (in-order, pre-order, post-order). Можем да го сравним с разглеждане на всички стаи в къща по различни маршрути.
- **Insertion (Вмъкване)** – Добавяне на нов възел в дървото, като се запазва правилото на BST.
- **Search (Търсене)** – Намиране на възел със зададена стойност чрез сравняване и навигиране по дървото.
- **Balance (Баланс)** – Степен на равномерно разпределение на възлите, която влияе върху ефективността на операциите.

## 4. Step-by-step Learning Path
1. **Разбиране на структурата на двоично дърво**
   - Фокус: Запознайте се с основните компоненти – възли, ляв и десен наследник.
   - Задача: Нарисувайте двоично дърво с поне 5 възела.
   - Въпроси: Какво означава „двоично“? Колко наследници може да има един възел?

2. **Обхождане на двоично дърво**
   - Фокус: Научете трите основни начина за обхождане – in-order, pre-order, post-order.
   - Задача: Напишете ръчно обхождане на дърво с примерни стойности.
   - Въпроси: Какъв е резултатът от in-order обхождането? Защо е полезно?

3. **Вмъкване и търсене в BST**
   - Фокус: Разберете правилата за вмъкване и търсене в BST.
   - Задача: Имплементирайте функция за вмъкване и търсене в BST на предпочитан език.
   - Въпроси: Как се избира ляв или десен наследник при вмъкване? Какво се случва, ако търсената стойност не съществува?

4. **Баланс и ефективност**
   - Фокус: Изследвайте как балансът влияе на времето за търсене.
   - Задача: Създайте BST с неравномерно разпределение и измерете времето за търсене.
   - Въпроси: Какво е най-лошият случай за BST? Как може да се подобри балансът?

5. **Приложения в реални системи**
   - Фокус: Разгледайте как BST се използват в бази данни и AI.
   - Задача: Анализирайте примерен код или система, използваща BST.
   - Въпроси: Защо BST са предпочитани пред линейното търсене? Как се използват в AI?

## 5. Examples
### Пример 1: Създаване на BST и търсене
```python
class Node:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.val = key

def insert(root, key):
    if root is None:
        return Node(key)
    if key < root.val:
        root.left = insert(root.left, key)
    else:
        root.right = insert(root.right, key)
    return root

def search(root, key):
    if root is None or root.val == key:
        return root
    if key < root.val:
        return search(root.left, key)
    return search(root.right, key)

# Създаване на BST
root = None
for value in [50, 30, 70, 20, 40, 60, 80]:
    root = insert(root, value)

# Търсене на стойност
result = search(root, 60)
print("Found" if result else "Not found")
```

### Пример 2: In-order обхождане (сортиране)
```python
def inorder(root):
    return inorder(root.left) + [root.val] + inorder(root.right) if root else []

print(inorder(root))  # Извежда: [20, 30, 40, 50, 60, 70, 80]
```

### Пример 3: Балансиране (концептуално)
- Ако добавяме елементи в нарастващ ред, BST се превръща в линейна структура (списък).
- Решение: използване на AVL или Red-Black дървета за автоматично балансиране.

## 6. Common Pitfalls
- **Неправилно вмъкване** – не спазване на правилото за ляво/дясно поддърво, което води до нарушаване на BST свойството.
- **Игнориране на баланс** – създаване на дърво с лош баланс, което намалява ефективността до линейна.
- **Липса на обработка на дубликати** – неясна политика за вмъкване на вече съществуващи стойности.
- **Грешки при обхождане** – неправилен ред на посещение, което води до некоректни резултати.
- **Забравяне за базовия случай при рекурсия** – води до runtime грешки или безкрайни цикли.

## 7. Short Retrieval Quiz
1. Какво е двоично дърво?
2. Какво е основното правило, което дефинира BST?
3. Какъв е резултатът от in-order обхождане на BST?
4. Какво се случва при търсене на стойност, която не съществува в BST?
5. Защо балансът е важен за BST?
6. Какво е най-лошият случай за времето на търсене в BST?
7. Какво представлява възел в двоично дърво?

## 8. Quick Recap
- Двоичното дърво е структура с максимум два наследника на възел.
- BST поддържа сортиран ред чрез правило за стойности в ляво и дясно поддърво.
- Обхождането на дървото може да бъде in-order, pre-order или post-order.
- Вмъкването и търсенето в BST са ефективни при балансирани дървета.
- Лошият баланс превръща BST в линейна структура с лоша производителност.
- BST са широко използвани в софтуерни системи и AI за бърз достъп до данни.
- Практическото имплементиране изисква внимание към рекурсия и обработка на гранични случаи.

## 9. Spaced Review Plan

| Време след учене | Промпт за преглед                                  |
|------------------|---------------------------------------------------|
| 1 ден            | Опишете структурата и правилата на BST.           |
| 3 дни            | Напишете псевдокод за вмъкване и търсене в BST.   |
| 1 седмица        | Обяснете защо балансът е важен и как се постига.  |
| 1 месец          | Дайте пример за приложение на BST в реална система.|