# Approximation_algorithms

## 1. Activate Prior Knowledge
- Какво разбирате под термина „алгоритъм за оптимизация“ и защо някои задачи са трудни за решаване точно?
- В кои ситуации в софтуерното инженерство или изкуствения интелект бихте предпочели бързо, но приблизително решение пред точно, но бавно?
- Какво е вашето разбиране за компромиса между точност и време за изпълнение в алгоритмите?

## 2. Overview
Approximation algorithms са алгоритми, които намират решения близки до оптималното за сложни оптимизационни задачи, при които намирането на точно решение е изчислително непрактично или невъзможно в разумно време. Те са особено важни за NP-трудни проблеми, където точните алгоритми имат експоненциална сложност.

В контекста на системи за изкуствен интелект и софтуерно инженерство, approximation algorithms позволяват бързо вземане на решения, което е критично при обработка на големи данни, планиране, разпознаване на образи и други задачи, където времето за реакция е ограничено.

Тези алгоритми осигуряват гаранции за качество на решението, изразени чрез коефициент на приближение, което описва колко близо е намереното решение до оптималното. Това прави approximation algorithms ценен инструмент за инженерите, които трябва да балансират между ефективност и точност.

## 3. Key Concepts
- **NP-трудни задачи** – Клас задачи, за които не е известно бързо (полиномиално) решение, но решенията могат да се проверят бързо. Аналогия: пъзел, който е лесно да провериш дали е сглобен правилно, но трудно да го сглобиш.
- **Коефициент на приближение (Approximation ratio)** – Мярка за това колко близо е решението на алгоритъма до оптималното. Например, коефициент 2 означава, че решението е най-много два пъти по-лошо от оптималното.
- **Жадни алгоритми (Greedy algorithms)** – Подход, който взема локално оптимални решения на всяка стъпка с надеждата да достигне глобално добро решение. Аналогия: да събираш най-големите монети първо, за да събереш максимална сума бързо.
- **Локално търсене (Local search)** – Метод, който започва от някакво решение и го подобрява чрез малки промени, докато не се достигне локален минимум или максимум.
- **Hardness of approximation** – Теоретични граници, които показват доколко е възможно да се приближи оптималното решение за дадена задача.

## 4. Step-by-step Learning Path
1. **Фокус:** Разбиране на NP-трудността и защо точните алгоритми са непрактични.  
   **Задача:** Изследвайте примери на NP-трудни задачи като проблема с коммивояжера (TSP).  
   **Въпроси:** Какво означава NP-трудност? Защо е важно да имаме приближени решения?

2. **Фокус:** Изучаване на жадни алгоритми като основен подход за приближение.  
   **Задача:** Имплементирайте жаден алгоритъм за проблема за покриване на множества (Set Cover).  
   **Въпроси:** Как жадният алгоритъм избира следващия елемент? Какъв е коефициентът на приближение?

3. **Фокус:** Анализ на коефициента на приближение и доказателства за граници.  
   **Задача:** Докажете коефициент на приближение за жадния алгоритъм на Set Cover.  
   **Въпроси:** Какво означава „гаранция за приближение“? Как се използва при оценка на алгоритъма?

4. **Фокус:** Изучаване на локално търсене и подобряване на решения.  
   **Задача:** Имплементирайте локално търсене за проблема за максимално независим набор от върхове (Maximum Independent Set).  
   **Въпроси:** Как локалното търсене подобрява решенията? Какво е локален минимум?

5. **Фокус:** Приложение на approximation algorithms в реални AI системи.  
   **Задача:** Анализирайте как приближени алгоритми се използват в планиране или оптимизация на ресурси.  
   **Въпроси:** Защо приближенията са критични в AI? Какви са рисковете при използването им?

## 5. Examples
### Пример 1: Жаден алгоритъм за Set Cover
```python
def greedy_set_cover(universe, subsets):
    covered = set()
    cover = []
    while covered != universe:
        subset = max(subsets, key=lambda s: len(s - covered))
        cover.append(subset)
        covered |= subset
    return cover

universe = set(range(1, 11))
subsets = [{1,2,3}, {2,4,5}, {3,6,7}, {4,8,9}, {5,10}]
print(greedy_set_cover(universe, subsets))
```

### Пример 2: Приближение за проблема на коммивояжера (TSP) с триъгълно неравенство
- Използва се MST (минимално покриващо дърво) за намиране на тур, който е не повече от два пъти по-дълъг от оптималния.

### Пример 3: Локално търсене за максимално независимо множество
- Започва се с произволно множество върхове, след което се добавят или премахват върхове, за да се увеличи размерът, без да се нарушава независимостта.

## 6. Common Pitfalls
- **Подценяване на сложността на доказателствата:** Много студенти приемат приближението за дадено, без да разберат доказателствата за коефициента на приближение.
- **Прилагане на жадни алгоритми без анализ:** Жадните решения не винаги са добри за всички задачи; важно е да се анализира тяхната ефективност.
- **Игнориране на границите на приближение:** Някои задачи имат доказани граници, които не могат да се подобрят; опитите да се надхвърлят тези граници са загуба на време.
- **Локално търсене без стратегия за избягване на локални минимуми:** Без подходящи техники, алгоритъмът може да се „заклещи“ в подоптимални решения.
- **Пренебрегване на практическата приложимост:** Теоретичните гаранции не винаги означават, че алгоритъмът е подходящ за конкретен реален проблем.

## 7. Short Retrieval Quiz
1. Какво представлява коефициентът на приближение?
2. Защо approximation algorithms са важни при NP-трудни задачи?
3. Как работи жадният алгоритъм за Set Cover?
4. Какво е локално търсене и как се използва при приближение?
5. Каква е разликата между точен и приближен алгоритъм?
6. Какво означава „hardness of approximation“?
7. Какво е основното предизвикателство при доказване на приближения?

## 8. Quick Recap
- Approximation algorithms предлагат бързи решения с гарантирана близост до оптималното за сложни задачи.
- Те са ключови за NP-трудни проблеми, където точните решения са непрактични.
- Коефициентът на приближение измерва качеството на решението.
- Жадните алгоритми и локалното търсене са основни техники за приближение.
- Теоретичните граници показват доколко е възможно да се приближи оптималното решение.
- Прилагането в AI и софтуерното инженерство изисква баланс между точност и ефективност.
- Внимание към доказателствата и практическите ограничения е критично.

## 9. Spaced Review Plan

| Време след учене | Промпт за преглед                                      |
|-------------------|-------------------------------------------------------|
| 1 ден             | Обяснете с прости думи какво е approximation algorithm и защо е важен. |
| 3 дни             | Прегледайте жадния алгоритъм за Set Cover и неговия коефициент на приближение. |
| 1 седмица         | Опишете локалното търсене и как помага за подобряване на решения. |
| 1 месец           | Преговор на теоретичните граници и приложението на approximation algorithms в AI системи. |