# Counting_Radix_Bucket_Sort

## 1. Activate Prior Knowledge
- Какви са основните предизвикателства при сортирането на големи масиви от данни в софтуерни системи?
- Как бихте използвали сортиращ алгоритъм за оптимизиране на обработката на данни в AI система, например при сортиране на числови характеристики?
- Какво знаете за разликите между сравняващи и не-сравняващи сортиращи алгоритми?

## 2. Overview
Counting, Radix и Bucket Sort са три алгоритъма за сортиране, които не се базират на сравнения между елементите, а използват специфични свойства на данните, като цифри или диапазони. Те са особено ефективни при сортиране на цели числа или данни с ограничен диапазон стойности.

Тези алгоритми често се използват в системи, където скоростта и ефективността са критични, например при сортиране на големи масиви от числови данни в AI приложения, обработка на изображения или бази данни. Те могат да бъдат комбинирани или адаптирани, за да се възползват от силните страни на всеки, създавайки хибридни подходи.

Разбирането на Counting, Radix и Bucket Sort е важно за софтуерните инженери, защото позволява избор на най-подходящия алгоритъм според характеристиките на входните данни и изискванията за производителност.

## 3. Key Concepts
- **Counting Sort** – алгоритъм, който брои колко пъти всяка стойност се среща в масива и използва тази информация, за да построи сортиран изход. Може да се сравни с подреждане на книги по брой страници, като първо преброяваме колко книги има с всяка стойност.
- **Radix Sort** – сортира числата поцифрено, започвайки от най-малко значимата цифра към най-значимата (или обратното). Представете си сортиране на пощенски кодове по цифри една по една.
- **Bucket Sort** – разделя данните в няколко "кофи" (интервали), сортира всяка кофа поотделно (често с друг алгоритъм), след което обединява резултатите. Аналогия: сортиране на монети по номинал в различни кутии.
- **Stable Sort** – алгоритъм, който запазва относителния ред на елементите с еднакви стойности, важно за Radix Sort.
- **Time Complexity** – времето, което алгоритъмът изисква за изпълнение, често изразено с O-нотация.

## 4. Step-by-step Learning Path
1. **Фокус:** Разберете принципа на Counting Sort.  
   **Задача:** Имплементирайте Counting Sort за масив от цели числа в диапазона 0–100.  
   **Въпроси:** Как Counting Sort използва броене, за да сортира? Защо е ефективен при ограничен диапазон?

2. **Фокус:** Изучете Radix Sort и неговото сортиране по цифри.  
   **Задача:** Напишете Radix Sort, който сортира масив от цели числа, използвайки Counting Sort като подфункция.  
   **Въпроси:** Как Radix Sort използва Counting Sort? Защо е важно сортирането да е стабилно?

3. **Фокус:** Разберете Bucket Sort и кога е подходящ.  
   **Задача:** Сортирайте масив от реални числа в интервала [0,1) с Bucket Sort, като използвате Insertion Sort за всяка кофа.  
   **Въпроси:** Как Bucket Sort разделя данните? Какъв е ефектът от броя кофи върху производителността?

4. **Фокус:** Анализирайте кога да изберете всеки алгоритъм според характеристиките на данните.  
   **Задача:** Сравнете производителността на трите алгоритъма върху различни входни данни (големи/малки, с/без повторения).  
   **Въпроси:** Кога Counting Sort е по-добър от Radix Sort? Какви са ограниченията на Bucket Sort?

## 5. Examples

### Counting Sort (Python)
```python
def counting_sort(arr):
    max_val = max(arr)
    count = [0] * (max_val + 1)
    for num in arr:
        count[num] += 1
    sorted_arr = []
    for val, freq in enumerate(count):
        sorted_arr.extend([val] * freq)
    return sorted_arr

print(counting_sort([4,2,2,8,3,3,1]))
# Output: [1,2,2,3,3,4,8]
```

### Radix Sort (Python)
```python
def counting_sort_for_radix(arr, exp):
    n = len(arr)
    output = [0] * n
    count = [0] * 10

    for i in range(n):
        index = (arr[i] // exp) % 10
        count[index] += 1

    for i in range(1, 10):
        count[i] += count[i-1]

    for i in range(n-1, -1, -1):
        index = (arr[i] // exp) % 10
        output[count[index] - 1] = arr[i]
        count[index] -= 1

    for i in range(n):
        arr[i] = output[i]

def radix_sort(arr):
    max_val = max(arr)
    exp = 1
    while max_val // exp > 0:
        counting_sort_for_radix(arr, exp)
        exp *= 10

arr = [170, 45, 75, 90, 802, 24, 2, 66]
radix_sort(arr)
print(arr)
# Output: [2, 24, 45, 66, 75, 90, 170, 802]
```

### Bucket Sort (Python)
```python
def insertion_sort(bucket):
    for i in range(1, len(bucket)):
        up = bucket[i]
        j = i - 1
        while j >= 0 and bucket[j] > up:
            bucket[j + 1] = bucket[j]
            j -= 1
        bucket[j + 1] = up
    return bucket

def bucket_sort(arr):
    n = len(arr)
    buckets = [[] for _ in range(n)]

    for num in arr:
        index = int(num * n)
        buckets[index].append(num)

    for i in range(n):
        buckets[i] = insertion_sort(buckets[i])

    sorted_arr = []
    for bucket in buckets:
        sorted_arr.extend(bucket)
    return sorted_arr

arr = [0.42, 0.32, 0.23, 0.52, 0.25, 0.47, 0.51]
print(bucket_sort(arr))
# Output: [0.23, 0.25, 0.32, 0.42, 0.47, 0.51, 0.52]
```

## 6. Common Pitfalls
- **Counting Sort с голям диапазон:** Ако диапазонът на стойностите е много голям, Counting Sort използва прекалено много памет и става неефективен.
- **Radix Sort без стабилност:** Ако подфункцията за сортиране не е стабилна, Radix Sort няма да работи правилно.
- **Bucket Sort с неправилен брой кофи:** Твърде малко кофи водят до неефективно сортиране вътре в кофите, твърде много – до излишна памет и време за управление.
- **Неправилно индексиране:** При Bucket Sort и Radix Sort грешки в изчисляването на индекси могат да доведат до загуба или дублиране на елементи.
- **Игнориране на типа данни:** Counting и Radix Sort са най-подходящи за цели числа или фиксирани формати, не за произволни обекти без ясна цифрова репрезентация.

## 7. Short Retrieval Quiz
1. Каква е основната идея зад Counting Sort?
2. Защо Radix Sort изисква стабилно сортиране на поднивата?
3. Как Bucket Sort разделя входните данни?
4. Кога Counting Sort е неефективен?
5. Какво е времевата сложност на Radix Sort при сортиране на n числа с d цифри?
6. Какво означава "стабилен" сортиращ алгоритъм?
7. Как броят на кофите влияе на производителността на Bucket Sort?

## 8. Quick Recap
- Counting, Radix и Bucket Sort са не-сравняващи алгоритми, подходящи за специфични типове данни.
- Counting Sort брои честотата на стойностите и е ефективен при ограничен диапазон.
- Radix Sort сортира поцифрено, използвайки стабилни подсортирания.
- Bucket Sort разделя данните в интервали и сортира всяка кофа поотделно.
- Изборът на алгоритъм зависи от характеристиките на данните и изискванията за производителност.
- Неспазването на стабилност или неправилното индексиране води до грешки.
- Практическата имплементация изисква внимание към паметта и времето за изпълнение.

## 9. Spaced Review Plan

| Време след учене | Промпт за преговор                                      |
|-------------------|--------------------------------------------------------|
| 1 ден             | Обяснете принципа на Counting Sort с пример.           |
| 3 дни             | Опишете как Radix Sort използва Counting Sort.         |
| 1 седмица         | Сравнете предимствата и недостатъците на трите алгоритъма. |
| 1 месец           | Имплементирайте Bucket Sort и анализирайте ефективността му върху различни входни данни. |