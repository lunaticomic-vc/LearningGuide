# Graph_representations_(matrix,_list,_edge_list)

## 1. Activate Prior Knowledge

- Какво представлява графът като структура от данни и къде бихте го използвали в софтуерни системи или AI?
- Какви са предимствата и недостатъците на различните начини за съхранение на връзки между обекти?
- Как бихте представили мрежа от взаимосвързани елементи, за да оптимизирате търсене, добавяне или премахване на връзки?

## 2. Overview

Графовете са фундаментални структури от данни, които моделират взаимовръзки между обекти. Те намират приложение в множество области като социални мрежи, препоръчителни системи, компютърни мрежи и изкуствен интелект. За да работим ефективно с графове, е необходимо да изберем подходящ начин за тяхното представяне в паметта.

Трите основни начина за представяне на граф са: матрица на съседство, списък на съседите и списък на ребрата. Всеки от тях има различни характеристики по отношение на използваната памет, бързината на достъп и удобството при модификации. Изборът на подходяща репрезентация е ключов за ефективността на алгоритмите, които работят върху графа.

В контекста на AI системи и софтуерното инженерство, правилната структура за граф може да подобри производителността на алгоритми за търсене, класификация и оптимизация. Например, при работа с големи и разредени графове, списъкът на съседите често е по-ефективен от матрицата на съседство.

## 3. Key Concepts

- **Graph (Граф)** – Множество от върхове (nodes) и ребра (edges), които свързват тези върхове. Може да бъде насочен или ненасочен.
- **Adjacency Matrix (Матрица на съседство)** – Двумерен масив, където всяка клетка показва дали има ребро между два върха. Представя графа чрез матрица с размер n×n, където n е броят върхове.
- **Adjacency List (Списък на съседите)** – За всеки връх се съхранява списък с върховете, с които е свързан. По-ефективен при разредени графове.
- **Edge List (Списък на ребрата)** – Списък от двойки (или тройки, ако ребрата имат тегло), които описват директно връзките между върховете.
- **Sparse vs Dense Graph (Разреден срещу плътен граф)** – Разреден граф има малко ребра спрямо броя върхове, докато плътен граф има много ребра, близо до максималния брой.
- **Memory Complexity (Паметова сложност)** – Колко памет заема представянето на графа, което зависи от броя върхове и ребра.
- **Time Complexity (Времева сложност)** – Колко време отнема достъпването или модифицирането на графа чрез дадена репрезентация.

## 4. Step-by-step Learning Path

1. **Запознайте се с основните компоненти на графа**  
   - Фокус: Върхове, ребра, насочени и ненасочени графове.  
   - Задача: Нарисувайте малък граф с 5 върха и няколко ребра, обозначете дали е насочен или не.  
   - Въпроси: Какво е разликата между насочен и ненасочен граф? Какво представлява ребро?

2. **Разучете матрицата на съседство**  
   - Фокус: Как се създава и използва матрица за граф.  
   - Задача: Създайте матрица на съседство за вашия граф от предишната задача.  
   - Въпроси: Каква е паметовата сложност на матрицата? Как се проверява дали две върхове са свързани?

3. **Изследвайте списъка на съседите**  
   - Фокус: Представяне чрез списък на съседите и предимства при разредени графове.  
   - Задача: Напишете списък на съседите за същия граф.  
   - Въпроси: Кога списъкът на съседите е по-ефективен от матрицата? Как се добавя ново ребро?

4. **Разгледайте списъка на ребрата**  
   - Фокус: Как се съхраняват ребрата директно и кога е полезно.  
   - Задача: Създайте списък на ребрата за вашия граф, включително тегла, ако има такива.  
   - Въпроси: Какво е предимството на списъка на ребрата при динамично добавяне на ребра? Как се намира дали ребро съществува?

5. **Сравнете трите представяния по памет и време**  
   - Фокус: Анализ на предимствата и недостатъците в различни сценарии.  
   - Задача: Направете таблица с плюсове и минуси на всяка репрезентация за вашия граф.  
   - Въпроси: Коя репрезентация бихте избрали за плътен граф? А за разреден?

6. **Практическа имплементация**  
   - Фокус: Имплементирайте избрана репрезентация на граф в предпочитан език (например Python или C++).  
   - Задача: Напишете функции за добавяне на връх, добавяне на ребро и проверка на съседство.  
   - Въпроси: Как се променя структурата при добавяне на нов връх? Как се оптимизира достъпът?

## 5. Examples

### Пример 1: Матрица на съседство за ненасочен граф с 4 върха

```python
# 0 1 2 3
graph = [
    [0, 1, 0, 0],  # Връх 0 е свързан с връх 1
    [1, 0, 1, 1],  # Връх 1 е свързан с върхове 0, 2, 3
    [0, 1, 0, 0],  # Връх 2 е свързан с връх 1
    [0, 1, 0, 0]   # Връх 3 е свързан с връх 1
]
```

### Пример 2: Списък на съседите за същия граф

```python
graph = {
    0: [1],
    1: [0, 2, 3],
    2: [1],
    3: [1]
}
```

### Пример 3: Списък на ребрата с тегла (насочен граф)

```python
edges = [
    (0, 1, 5),  # ребро от 0 към 1 с тегло 5
    (1, 2, 3),
    (1, 3, 2)
]
```

## 6. Common Pitfalls

- **Използване на матрица на съседство за големи разредени графове** – води до излишна консумация на памет. Избягвайте, ако броят ребра е много по-малък от n².
- **Забравяне да обновите и двете посоки при ненасочен граф в списъка на съседите** – може да доведе до несъответствия.
- **Неправилно индексиране на върхове** – особено при използване на списъци, където върховете не са последователни числа.
- **Пренебрегване на тежестите на ребрата** – ако графът е тегловен, не включвайте ребрата без тегло.
- **Неоптимално търсене на съседство в списък на ребрата** – търсенето е линейно, което е бавно за големи графове.

## 7. Short Retrieval Quiz

1. Какво представлява матрицата на съседство?
2. Кога списъкът на съседите е по-подходящ от матрицата?
3. Как се представя ребро в списъка на ребрата?
4. Каква е паметовата сложност на матрицата на съседство за граф с n върха?
5. Какво е основното предимство на списъка на съседите при разредени графове?
6. Какво трябва да се направи при добавяне на ребро в ненасочен граф, използващ списък на съседите?
7. Каква е разликата между насочен и ненасочен граф?

## 8. Quick Recap

- Графовете могат да се представят чрез матрица на съседство, списък на съседите или списък на ребрата.
- Матрицата на съседство е удобна за плътни графове, но изисква O(n²) памет.
- Списъкът на съседите е по-ефективен за разредени графове и позволява бързо обхождане на съседите.
- Списъкът на ребрата е удобен за динамично добавяне и премахване на ребра, но търсенето е по-бавно.
- Изборът на представяне зависи от характеристиките на графа и задачите, които трябва да се изпълнят.
- Важно е да се следи коректността при обновяване на структури, особено при ненасочени графове.
- Практическата имплементация изисква внимание към индексиране, паметова ефективност и времева сложност.

## 9. Spaced Review Plan

| Време след учене | Промпт за преглед                                      |
|------------------|-------------------------------------------------------|
| 1 ден            | Обяснете трите основни представяния на граф и техните предимства. |
| 3 дни            | Направете пример с матрица на съседство и списък на съседите за малък граф. |
| 1 седмица        | Сравнете паметовата и времевата сложност на трите представяния. |
| 1 месец          | Имплементирайте функция за добавяне на ребро и проверка на съседство в избрана репрезентация. |