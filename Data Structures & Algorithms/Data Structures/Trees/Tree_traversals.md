# Tree_traversals

## 1. Activate Prior Knowledge
- Какво представлява дървовидната структура в компютърните науки и къде я срещаме в софтуерните системи?
- Какви са възможните начини за обхождане на елементи в линейна структура като списък и как това се променя при дървовидна структура?
- Защо ефективното обхождане на дърво е критично в алгоритми за търсене и обработка на данни в изкуствения интелект?

## 2. Overview
Обхождането на дърво (tree traversal) е фундаментална операция в компютърните науки, която позволява систематично посещаване на всички възли в дървовидна структура. Този процес е ключов за задачи като търсене, сортиране, и манипулиране на данни, които са организирани йерархично.

В контекста на софтуерното инженерство и изкуствения интелект, дървовидните структури често моделират сложни зависимости и решения — например в дървета на решения, синтактични дървета или графи на знания. Разбирането на различните методи за обхождане и техните свойства е критично за оптимизиране на алгоритми и за правилното интерпретиране на данните.

Обхожданията се делят основно на три вида: pre-order, in-order и post-order, всеки със специфично приложение и поведение. Освен тях, съществува и breadth-first traversal (обхождане на нива), което е важно за алгоритми като търсене в ширина.

## 3. Key Concepts
- **Node (възел)** – Основната единица на дървото, съдържа данни и препратки към други възли (деца). Можем да си го представим като „кутия“, която държи информация и връзки.
- **Root (корен)** – Възелът, от който започва дървото. Той няма родител и е началната точка за обхождане.
- **Leaf (лист)** – Възел без деца, „крайна точка“ в дървото.
- **Pre-order traversal** – Обхождане, при което първо се посещава възелът, след това децата му. Аналогично на „посещаване преди обработка“.
- **In-order traversal** – Обхождане, при което първо се посещава лявото дете, след това възелът, после дясното дете. Често се използва при двоични дървета за извличане на сортиран списък.
- **Post-order traversal** – Обхождане, при което първо се посещават децата, а накрая възелът. Подходящо за изчисляване на стойности отдолу-нагоре.
- **Breadth-first traversal (обхождане на нива)** – Посещение на възлите по нива, от корена надолу, като се преминава през всички възли на едно ниво преди следващото.
- **Recursive vs Iterative traversal** – Два подхода за имплементация; рекурсивният използва стек на извикванията, итеративният – явен стек или опашка.

## 4. Step-by-step Learning Path
1. **Запознайте се с основните структури на дърво**
   - Фокус: Разберете как са изградени възлите и връзките между тях.
   - Задача: Създайте прост двоичен дървовиден клас с възли, съдържащи цели числа.
   - Въпроси: Какво е коренът? Как се различава лист от вътрешен възел?

2. **Имплементирайте Pre-order traversal рекурсивно**
   - Фокус: Разберете логиката на посещение на възлите.
   - Задача: Напишете функция, която отпечатва стойностите на възлите в pre-order.
   - Въпроси: В какъв ред се посещават възлите? Какво се случва, ако дървото е празно?

3. **Разширете с In-order и Post-order traversal**
   - Фокус: Сравнете различните обхождания и техните резултати.
   - Задача: Имплементирайте in-order и post-order функции и тествайте с примерни дървета.
   - Въпроси: Кога in-order traversal връща сортиран списък? Какво е приложението на post-order?

4. **Изучете Breadth-first traversal (BFS)**
   - Фокус: Разберете разликата между дълбочинно и ширинно обхождане.
   - Задача: Имплементирайте BFS с помощта на опашка.
   - Въпроси: Какво е предимството на BFS при търсене? Как се управлява опашката?

5. **Практикувайте итеративни версии на traversal**
   - Фокус: Разберете как да избегнете рекурсия чрез стекове.
   - Задача: Напишете итеративен pre-order traversal.
   - Въпроси: Как стекът замества рекурсивния стек? Кога итеративният подход е по-подходящ?

6. **Приложете traversal в реален проблем**
   - Фокус: Използвайте traversal за решаване на задача, например изчисляване на сума на възлите.
   - Задача: Напишете функция, която изчислява сумата на всички стойности в дървото чрез post-order traversal.
   - Въпроси: Защо post-order е подходящ за агрегация? Какво би се променило при pre-order?

## 5. Examples

### Пример 1: Pre-order traversal (рекурсивно)
```python
class Node:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

def preorder(node):
    if node:
        print(node.val, end=' ')
        preorder(node.left)
        preorder(node.right)

# Създаване на дърво
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)

preorder(root)  # Изход: 1 2 4 5 3
```

### Пример 2: Breadth-first traversal (BFS)
```python
from collections import deque

def bfs(root):
    if not root:
        return
    queue = deque([root])
    while queue:
        node = queue.popleft()
        print(node.val, end=' ')
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)

bfs(root)  # Изход: 1 2 3 4 5
```

### Пример 3: In-order traversal за сортиране
```python
def inorder(node):
    if node:
        inorder(node.left)
        print(node.val, end=' ')
        inorder(node.right)

inorder(root)  # Изход: 4 2 5 1 3
```

## 6. Common Pitfalls
- **Пропускане на базовия случай в рекурсията** – води до безкрайни извиквания и срив на програмата.
- **Неправилно управление на опашката или стека при итеративно обхождане** – може да доведе до пропускане на възли или грешен ред.
- **Смесване на типовете traversal** – например използване на in-order traversal при дърво, което не е двоично търсещо, без да се разбира последствието.
- **Неотчитане на празни възли (None)** – при имплементация, което води до runtime грешки.
- **Пренебрегване на ефективността при големи дървета** – рекурсивните обхождания могат да доведат до стек overflow, ако дървото е много дълбоко.

## 7. Short Retrieval Quiz
1. Каква е разликата между pre-order и post-order traversal?
2. Кой traversal метод връща сортиран списък при двоично търсещо дърво?
3. Какво представлява breadth-first traversal и с каква структура данни се реализира?
4. Защо е важно да имаме базов случай в рекурсивните traversal функции?
5. Какво е лист в контекста на дървовидна структура?
6. Кога е по-подходящ итеративен traversal пред рекурсивен?
7. Какво се случва, ако не проверим за None възли при обхождане?

## 8. Quick Recap
- Дървовидните структури са йерархични и изискват специални методи за обхождане.
- Основните видове traversal са pre-order, in-order, post-order и breadth-first.
- Pre-order посещава възела преди децата, in-order между децата, post-order след децата.
- Breadth-first traversal обхожда дървото по нива, използвайки опашка.
- Рекурсивните traversal са интуитивни, но итеративните са по-ефективни при дълбоки дървета.
- Правилното разбиране на traversal е ключово за алгоритми в търсене, сортиране и изкуствен интелект.
- Често срещани грешки включват липса на базов случай и неправилно управление на стек/опашка.

## 9. Spaced Review Plan

| Време след учене | Промпт за преговор                                   |
|-------------------|-----------------------------------------------------|
| 1 ден             | Опишете основните видове traversal и тяхното приложение. |
| 3 дни             | Имплементирайте pre-order и breadth-first traversal.     |
| 1 седмица         | Обяснете кога и защо да използвате post-order traversal. |
| 1 месец           | Решете задача с дървовидна структура, използвайки traversal за агрегация на данни. |