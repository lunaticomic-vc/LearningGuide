# Z_algorithm_and_prefix_function

## 1. Activate Prior Knowledge

- Какви алгоритми познавате за търсене на поднизове в текст и какви са техните ограничения по време на изпълнение?
- Как бихте използвали предварително изчислени данни за даден низ, за да ускорите търсенето на повтарящи се модели в него?
- В контекста на системи за обработка на естествен език или анализ на геномни последователности, какви предизвикателства срещате при намирането на повтарящи се шаблони?

## 2. Overview

Алгоритъмът Z и префикс функцията (prefix function) са фундаментални техники за ефективно търсене и анализ на низове. Те позволяват бързо намиране на повтарящи се модели, което е ключово в много области като компютърна лингвистика, биоинформатика и оптимизация на текстови търсачки.

Z-алгоритъмът изчислява масив, който за всяка позиция в низа показва дължината на най-дългия префикс, започващ от тази позиция и съвпадащ с префикса на целия низ. Това позволява бързо откриване на съвпадения без излишни сравнения.

Префикс функцията, използвана в алгоритъма на Кнут-Морис-Прат (KMP), измерва най-дългия собствен префикс на подниза, който също е суфикс. Тази информация се използва, за да се избегне повторно сравнение на вече проверени символи при търсене на шаблон в текст.

Тези алгоритми са важни, защото оптимизират задачи, които иначе биха изисквали квадратично време, до линейно време, което е критично при работа с големи обеми данни.

## 3. Key Concepts

- **Z-масив (Z-array)** – Масив, където всяка стойност показва дължината на най-дългия префикс на низа, започващ от текущата позиция, който съвпада с префикса на целия низ. Ментален модел: „отместване на прозореца, който търси съвпадения с началото“.
- **Префикс функция (Prefix function)** – За всеки индекс в низа показва дължината на най-дългия собствен префикс, който е и суфикс на подниза до този индекс. Аналогия: „най-добрата точка за рестарт при неуспешно съвпадение“.
- **Собствен префикс** – Префикс на низа, който не е равен на целия низ.
- **Суфикс** – Крайна част от низа.
- **Линейно време (O(n))** – Времева сложност, при която времето за изпълнение расте пропорционално на дължината на низа.
- **Алгоритъм на Кнут-Морис-Прат (KMP)** – Алгоритъм за търсене на шаблон в текст, който използва префикс функция за оптимизация.

## 4. Step-by-step Learning Path

1. **Запознайте се с основните дефиниции на префикси, суфикси и съвпадения.**  
   *Задача:* Напишете няколко примера за префикси и суфикси на даден низ.  
   *Въпроси:* Какво е собствен префикс? Как се различава от обикновения префикс?

2. **Разберете как се изчислява Z-масивът.**  
   *Задача:* Изчислете ръчно Z-масива за кратък низ, например "aabcaabxaaaz".  
   *Въпроси:* Какво означава стойността в Z-масива на позиция i? Как помага това при търсене?

3. **Изучете алгоритъма за изчисляване на префикс функцията.**  
   *Задача:* Изчислете префикс функцията за низ "ababcabab".  
   *Въпроси:* Как префикс функцията помага при избягване на повторни сравнения?

4. **Прилагайте Z-алгоритъма и префикс функцията за търсене на шаблон в текст.**  
   *Задача:* Имплементирайте функция, която намира всички позиции на шаблон в текст с помощта на Z-алгоритъма.  
   *Въпроси:* Какво е времевото сложност на този подход? Как се различава от наивното търсене?

5. **Изследвайте приложенията в реални системи.**  
   *Задача:* Анализирайте как тези алгоритми се използват в системи за откриване на плагиатство или геномни анализи.  
   *Въпроси:* Защо линейното време е критично в тези приложения? Какви са ограниченията?

## 5. Examples

### Пример 1: Изчисляване на Z-масив

```python
def calculate_z_array(s):
    n = len(s)
    z = [0] * n
    l, r = 0, 0
    for i in range(1, n):
        if i <= r:
            z[i] = min(r - i + 1, z[i - l])
        while i + z[i] < n and s[z[i]] == s[i + z[i]]:
            z[i] += 1
        if i + z[i] - 1 > r:
            l, r = i, i + z[i] - 1
    return z

s = "aabcaabxaaaz"
print(calculate_z_array(s))
# Изход: [0, 1, 0, 0, 3, 1, 0, 0, 2, 1, 1, 0]
```

### Пример 2: Изчисляване на префикс функция

```python
def prefix_function(s):
    n = len(s)
    pi = [0] * n
    for i in range(1, n):
        j = pi[i - 1]
        while j > 0 and s[i] != s[j]:
            j = pi[j - 1]
        if s[i] == s[j]:
            j += 1
        pi[i] = j
    return pi

s = "ababcabab"
print(prefix_function(s))
# Изход: [0, 0, 1, 2, 0, 1, 2, 3, 4]
```

### Пример 3: Търсене на шаблон с помощта на Z-алгоритъм

```python
def z_algorithm_search(text, pattern):
    concat = pattern + "$" + text
    z = calculate_z_array(concat)
    result = []
    p_len = len(pattern)
    for i in range(p_len + 1, len(concat)):
        if z[i] == p_len:
            result.append(i - p_len - 1)
    return result

text = "ababcababcababc"
pattern = "ababc"
print(z_algorithm_search(text, pattern))
# Изход: [0, 5, 10]
```

## 6. Common Pitfalls

- **Неправилно инициализиране на границите (l, r) в Z-алгоритъма.** Това води до грешни стойности и загуба на линейност. Винаги проверявайте актуализацията на границите.
- **Смесване на индекси при изчисляване на префикс функцията.** Внимавайте с индексацията и условните проверки, за да не се получат цикли или грешки.
- **Игнориране на специални символи при конкатенация (например "$" в търсенето с Z-алгоритъм).** Трябва да се използва символ, който не се среща в низа, за да се избегнат фалшиви съвпадения.
- **Опит за използване на Z-алгоритъм или префикс функция за нерелевантни задачи без адаптация.** Те са специализирани за текстови операции и не са универсални решения за всички видове данни.
- **Пренебрегване на крайни случаи като празен низ или низ с един символ.** Винаги тествайте такива случаи.

## 7. Short Retrieval Quiz

1. Какво показва стойността на Z-масива на позиция i?
2. Каква е ролята на префикс функцията в алгоритъма на Кнут-Морис-Прат?
3. Какво означава „собствен префикс“?
4. Каква е времевата сложност на Z-алгоритъма?
5. Защо се използва специален символ при конкатенация в Z-алгоритъма?
6. Как префикс функцията помага да се избегнат повторни сравнения?
7. Какво представлява суфиксът на низ?

## 8. Quick Recap

- Z-алгоритъмът и префикс функцията са линейно време алгоритми за анализ на низове.
- Z-масивът показва дължината на най-дългия префикс, съвпадащ с част от низа, започващ от дадена позиция.
- Префикс функцията измерва най-дългия собствен префикс, който е и суфикс на подниз.
- Тези алгоритми оптимизират търсенето на шаблони в текст, избягвайки излишни сравнения.
- Те са широко използвани в компютърна лингвистика, биоинформатика и системи за търсене.
- Внимателното управление на индекси и граници е ключово за правилната им работа.
- Практическото им приложение изисква разбиране на структурата на низовете и особеностите на алгоритмите.

## 9. Spaced Review Plan

| Време след учене | Преговорен въпрос                                   |
|-------------------|----------------------------------------------------|
| 1 ден             | Какво представлява Z-масивът и как се изчислява?  |
| 3 дни             | Как префикс функцията помага при търсене на шаблон?|
| 1 седмица         | Опишете стъпките на Z-алгоритъма и ролята на l, r.|
| 1 месец           | Кога и защо бихте използвали Z-алгоритъм вместо KMP? |