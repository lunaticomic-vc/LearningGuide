# Lock_free_and_wait_free_algorithms

## 1. Activate Prior Knowledge

- Какво знаете за проблемите, свързани с конкурентен достъп до споделена памет в многопоточни системи?
- Какви са основните предизвикателства при синхронизацията на нишки в съвременните AI системи и софтуерни приложения?
- Можете ли да предвидите как алгоритми без блокиране (lock-free) и без изчакване (wait-free) могат да подобрят производителността и надеждността на системи с множество нишки?

## 2. Overview

Lock-free и wait-free алгоритмите са специални техники за синхронизация, които позволяват на множество нишки да работят върху споделени данни без да използват традиционни блокировки (locks). Това е особено важно в съвременните системи, където забавянията и блокировките могат да доведат до сериозни проблеми с производителността и надеждността.

Lock-free алгоритмите гарантират, че поне една нишка ще направи напредък в ограничено време, докато wait-free алгоритмите осигуряват, че всяка нишка ще завърши своята операция в ограничен брой стъпки. Тези свойства са критични за системи с високи изисквания за време за реакция, като реалновременни AI приложения и мултипроцесорни среди.

Тези алгоритми се използват широко в библиотеки за конкурентни структури от данни, операционни системи и среди за паралелно програмиране, където традиционните блокировки могат да доведат до взаимно заключване (deadlock) или загуба на производителност.

## 3. Key Concepts

- **Lock-free** – Алгоритъм, при който поне една нишка напредва в ограничено време, без да блокира другите. Мислете за него като за "гаранция за прогрес" в конкурентна среда.
- **Wait-free** – Алгоритъм, който гарантира, че всяка нишка завършва своята операция в ограничен брой стъпки, независимо от други нишки. Това е "гаранция за справедливост и бързина".
- **Atomic operation** – Елементарна операция, която се изпълнява изцяло или изобщо не, без възможност за прекъсване. Аналогично на "магическо натискане на бутон", което никой не може да прекъсне.
- **Compare-and-swap (CAS)** – Често използвана атомарна операция, която сравнява стойност в паметта с очаквана и ако съвпадат, я заменя с нова. Мислете за това като "проверка и актуализация в един ход".
- **ABA problem** – Проблем, при който стойност в паметта се променя от A на B и обратно на A, което може да заблуди CAS операцията. Представете си, че някой сменя табелка и после я връща обратно, без да се забележи.
- **Progress condition** – Условие, което описва какъв вид напредък е гарантиран от алгоритъма (например lock-free или wait-free).

## 4. Step-by-step Learning Path

1. **Фокус:** Разберете основите на конкурентното програмиране и проблемите с блокировките.  
   **Практическа задача:** Напишете прост многопоточен код с mutex и наблюдавайте поведението при блокиране.  
   **Въпроси за припомняне:** Какво е deadlock? Защо блокировките могат да забавят програмата?

2. **Фокус:** Изучете атомарните операции и CAS.  
   **Практическа задача:** Имплементирайте малък пример с CAS за актуализация на споделена променлива.  
   **Въпроси за припомняне:** Как работи CAS? Защо е важна атомарността?

3. **Фокус:** Разберете разликата между lock-free и wait-free алгоритми.  
   **Практическа задача:** Анализирайте примерен lock-free стек и идентифицирайте гаранциите за прогрес.  
   **Въпроси за припомняне:** Каква е разликата между lock-free и wait-free?

4. **Фокус:** Изучете ABA проблема и техники за решаването му (например използване на счетоводни броячи).  
   **Практическа задача:** Модифицирайте CAS пример, за да предотвратите ABA проблема.  
   **Въпроси за припомняне:** Какво е ABA проблемът? Как може да се избегне?

5. **Фокус:** Практикувайте с реални структури от данни (стек, опашка) с lock-free и wait-free алгоритми.  
   **Практическа задача:** Имплементирайте lock-free стек и тествайте с множество нишки.  
   **Въпроси за припомняне:** Какви са предимствата на lock-free структури от данни в реални приложения?

## 5. Examples

### Пример 1: Lock-free стек с CAS (C++)

```cpp
#include <atomic>
#include <iostream>

struct Node {
    int value;
    Node* next;
};

std::atomic<Node*> head(nullptr);

void push(int val) {
    Node* new_node = new Node{val, nullptr};
    do {
        new_node->next = head.load(std::memory_order_relaxed);
    } while (!head.compare_exchange_weak(new_node->next, new_node,
                                         std::memory_order_release,
                                         std::memory_order_relaxed));
}

bool pop(int &result) {
    Node* old_head = head.load(std::memory_order_relaxed);
    while (old_head) {
        if (head.compare_exchange_weak(old_head, old_head->next,
                                       std::memory_order_acquire,
                                       std::memory_order_relaxed)) {
            result = old_head->value;
            delete old_head;
            return true;
        }
    }
    return false;
}
```

### Пример 2: Wait-free брояч (Java)

```java
import java.util.concurrent.atomic.AtomicInteger;

class WaitFreeCounter {
    private AtomicInteger counter = new AtomicInteger(0);

    public int increment() {
        return counter.getAndIncrement();
    }

    public int get() {
        return counter.get();
    }
}
```

## 6. Common Pitfalls

- **Игнориране на ABA проблема** – Много lock-free алгоритми са уязвими към ABA, което може да доведе до неправилно поведение. Използвайте техники като pointer tagging или счетоводни броячи.
- **Неправилно използване на паметни бариери** – Грешките в memory ordering могат да доведат до непредвидими резултати. Винаги проверявайте спецификациите на atomic операциите.
- **Прекомерна сложност** – Опитът да се направи алгоритъм wait-free може да усложни кода и да намали четимостта. Започнете с lock-free и преминете към wait-free, ако е необходимо.
- **Пренебрегване на тестове с множество нишки** – Липсата на обширни тестове в конкурентна среда може да скрие сериозни грешки.

## 7. Short Retrieval Quiz

1. Каква е основната разлика между lock-free и wait-free алгоритми?
2. Какво представлява атомарната операция compare-and-swap (CAS)?
3. Какво е ABA проблемът и защо е опасен?
4. Защо lock-free алгоритмите са важни за AI системи?
5. Какво гарантира wait-free алгоритъм за всяка нишка?
6. Какво може да се случи, ако не се използват правилно паметните бариери?
7. Коя е основната цел на lock-free алгоритмите?

## 8. Quick Recap

- Lock-free алгоритмите гарантират, че поне една нишка напредва, без блокировки.
- Wait-free алгоритмите гарантират, че всяка нишка завършва операцията си в ограничено време.
- Атомарните операции като CAS са основата на тези алгоритми.
- ABA проблемът е често срещан капан, който трябва да се избягва.
- Тези алгоритми подобряват производителността и надеждността в конкурентни системи.
- Правилното използване на паметни бариери е критично за коректност.
- Практическата имплементация изисква внимателно тестване и разбиране на прогрес условията.

## 9. Spaced Review Plan

| Време след учене | Промпт за преглед                                      |
|------------------|-------------------------------------------------------|
| 1 ден            | Обяснете разликата между lock-free и wait-free.       |
| 3 дни            | Опишете как работи CAS и защо е важен.                |
| 1 седмица        | Идентифицирайте ABA проблема и методи за предотвратяване. |
| 1 месец          | Дайте пример за lock-free структура от данни и нейните предимства. |