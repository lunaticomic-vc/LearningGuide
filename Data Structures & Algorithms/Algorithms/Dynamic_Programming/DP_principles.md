# DP_principles

## 1. Activate Prior Knowledge
- Какво знаете за динамичното програмиране (DP) и кога сте го използвали в софтуерни проекти или AI системи?
- Можете ли да дадете пример за проблем, който изглежда сложен, но може да бъде решен чрез разбиване на по-малки подпроблеми?
- Как мислите, защо е важно да оптимизираме изчисленията при решаване на рекурсивни задачи?

## 2. Overview
Динамичното програмиране (DP) е метод за решаване на сложни проблеми чрез разбиването им на по-малки, припокриващи се подпроблеми. Вместо да решаваме всеки подпроблем многократно, DP запазва резултатите от вече решените подпроблеми, за да ги използва повторно. Това значително намалява времето за изпълнение и прави възможно решаването на задачи, които иначе биха били изчислително непрактични.

DP се използва широко в алгоритми, оптимизация, изкуствен интелект и софтуерно инженерство, особено когато трябва да се намери оптимално решение в голямо пространство от възможности. Той е основен инструмент за задачи като намиране на най-кратък път, оптимално разпределение на ресурси, и моделиране на последователности.

Разбирането на принципите на DP е ключово за изграждане на ефективни AI системи, където изчислителните ресурси са ограничени, а решенията трябва да са бързи и точни. DP също така развива умения за структуриране на проблеми и мислене в термини на подпроблеми и оптимални решения.

## 3. Key Concepts
- **Подпроблем (Subproblem)** – по-малка част от оригиналния проблем, която може да бъде решена независимо. Аналогия: сглобяване на пъзел чрез първо решаване на отделни части.
- **Припокриващи се подпроблеми (Overlapping Subproblems)** – ситуация, в която едни и същи подпроблеми се решават многократно. DP избягва това чрез запомняне на вече решените.
- **Оптимална подструктура (Optimal Substructure)** – ако оптималното решение на проблема може да бъде конструирано от оптималните решения на неговите подпроблеми.
- **Мемоизация (Memoization)** – техника за съхранение на резултатите от подпроблеми, за да се избегне повторно изчисление. Може да се представи като „запомняне“ на отговорите.
- **Табулиране (Tabulation)** – итеративен подход за DP, при който се попълва таблица с решения на подпроблеми от най-малките към по-големите.
- **Рекурсия (Recursion)** – метод за дефиниране на решение чрез повикване на същата функция с по-малки входни данни, често използван в DP.

## 4. Step-by-step Learning Path
1. **Разберете основния проблем и неговите подпроблеми**
   - Фокус: Идентифицирайте подпроблемите и проверете дали те се припокриват.
   - Задача: Изберете класически проблем (напр. Фибоначи) и формулирайте подпроблемите.
   - Въпроси: Какви са подпроблемите? Защо те се припокриват?

2. **Проверете за оптимална подструктура**
   - Фокус: Убедете се, че оптималното решение на основния проблем може да се изгради от оптималните решения на подпроблемите.
   - Задача: Докажете оптималната подструктура за избрания проблем.
   - Въпроси: Може ли да се състави решение от подрешения? Как?

3. **Изберете подход: мемоизация или табулиране**
   - Фокус: Разберете разликите и предимствата на двата подхода.
   - Задача: Имплементирайте мемоизация за Фибоначи и след това табулиране.
   - Въпроси: Кой подход е по-ефективен по време и памет? Защо?

4. **Оптимизирайте пространствената сложност**
   - Фокус: Намалете използваната памет чрез наблюдение на зависимостите.
   - Задача: Оптимизирайте DP решение за проблем с линейна памет.
   - Въпроси: Каква част от таблицата е необходима за изчисление? Може ли да се съхранява по-малко?

5. **Приложете DP в реален инженеринг проблем**
   - Фокус: Изберете проблем от AI или софтуерно инженерство.
   - Задача: Решете задача за оптимално планиране или маршрутизиране с DP.
   - Въпроси: Как DP подобрява ефективността? Какви са ограниченията?

## 5. Examples

### Пример 1: Фибоначи с мемоизация (Python)
```python
def fib(n, memo={}):
    if n <= 1:
        return n
    if n not in memo:
        memo[n] = fib(n-1, memo) + fib(n-2, memo)
    return memo[n]

print(fib(10))  # Изход: 55
```

### Пример 2: Най-дълга обща подредба (LCS) с табулиране (Python)
```python
def lcs(X, Y):
    m, n = len(X), len(Y)
    dp = [[0]*(n+1) for _ in range(m+1)]
    for i in range(1, m+1):
        for j in range(1, n+1):
            if X[i-1] == Y[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    return dp[m][n]

print(lcs("AGGTAB", "GXTXAYB"))  # Изход: 4
```

### Пример 3: Оптимално разпределение на задачи (Task Scheduling)
- Задача: Намерете максималната стойност на задачи, които могат да се изпълнят без припокриване.
- DP решението използва сортиране и таблица за максимална стойност до всяка задача.

## 6. Common Pitfalls
- **Игнориране на припокриващите се подпроблеми** – води до експоненциална сложност.
- **Липса на оптимална подструктура** – DP не е приложимо, ако оптималните решения на подпроблемите не водят до оптимално решение.
- **Грешки при индексиране в таблиците** – често водят до неправилни резултати.
- **Прекомерна употреба на рекурсия без мемоизация** – може да доведе до стек overflow и бавна работа.
- **Недостатъчно оптимизиране на пространството** – използване на излишна памет, което е критично при големи входни данни.

## 7. Short Retrieval Quiz
1. Какво представляват припокриващите се подпроблеми?
2. Защо е важна оптималната подструктура в DP?
3. Каква е разликата между мемоизация и табулиране?
4. Кога DP не е подходящ метод за решаване на проблем?
5. Как може да се оптимизира пространствената сложност в DP?
6. Какво е основното предимство на DP пред чистата рекурсия?
7. Дайте пример за реален проблем, който може да се реши с DP.

## 8. Quick Recap
- DP решава сложни проблеми чрез разбиване на припокриващи се подпроблеми.
- Оптималната подструктура е ключово условие за прилагане на DP.
- Мемоизация и табулиране са двата основни подхода за имплементация.
- DP значително подобрява ефективността спрямо наивна рекурсия.
- Важно е да се оптимизира използването на памет при големи задачи.
- DP е широко приложим в AI, оптимизация и софтуерно инженерство.
- Избягвайте често срещани грешки като неправилно индексиране и липса на кеширане.

## 9. Spaced Review Plan

| Време след изучаване | Промпт за преглед                                  |
|----------------------|---------------------------------------------------|
| 1 ден                | Обяснете с прости думи какво е динамично програмиране и защо е полезно. |
| 3 дни                | Прегледайте разликите между мемоизация и табулиране и дайте пример.    |
| 1 седмица            | Опишете стъпките за решаване на проблем с DP и приложете на нов пример.|
| 1 месец              | Преговорете общите грешки и как да ги избегнете при имплементация на DP. |