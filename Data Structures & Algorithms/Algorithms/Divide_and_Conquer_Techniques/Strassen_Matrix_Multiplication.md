# Strassen_Matrix_Multiplication

## 1. Activate Prior Knowledge

- Какво знаете за класическото умножение на матрици и какво е неговото времево усложнение?
- Защо бързото умножение на матрици е важно в съвременните AI системи и софтуерни приложения?
- Можете ли да предположите как може да се намали броят на операциите при умножение на матрици, без да се губи точност?

## 2. Overview

Strassen алгоритъмът за умножение на матрици е революционен метод, който намалява времевата сложност на класическото умножение. Класическият метод изисква O(n³) операции за умножение на две n×n матрици, докато Strassen намалява това до приблизително O(n^2.81), което е значително подобрение при големи размери.

Този алгоритъм е особено важен в области като машинно обучение, компютърна графика и научни изчисления, където матричните операции са в основата на много алгоритми и системи. По-бързото умножение на матрици води до по-бързо обучение на модели и по-ефективна обработка на данни.

Strassen използва техника, наречена "разделяй и владей", като разделя матриците на по-малки блокове и комбинира резултатите с по-малко умножения, отколкото при класическия подход. Това изисква по-внимателна организация на изчисленията, но постига значителна икономия на ресурси.

## 3. Key Concepts

- **Matrix Multiplication (Умножение на матрици)** – Операция, при която всеки елемент на резултатната матрица се получава като скаларно произведение на ред от първата матрица и колона от втората. Ментален модел: "събиране на произведения".
- **Divide and Conquer (Разделяй и владей)** – Стратегия за решаване на проблем, като се разделя на по-малки подпроблеми, решават се независимо и след това се комбинират. Аналогия: сглобяване на пъзел от по-малки части.
- **Recursive Algorithm (Рекурсивен алгоритъм)** – Алгоритъм, който се извиква сам многократно с по-малки входни данни, докато достигне базов случай.
- **Strassen’s Seven Products (Седемте продукта на Страсен)** – Специални междинни матрици, които се изчисляват, за да се намали броят на умноженията от 8 (класически) на 7.
- **Time Complexity (Времева сложност)** – Мярка за броя операции, необходими за изпълнение на алгоритъма спрямо размера на входа.

## 4. Step-by-step Learning Path

1. **Прегледайте класическото умножение на матрици**
   - Фокус: Разберете как се изчислява всеки елемент и защо е O(n³).
   - Задача: Имплементирайте класическо умножение на две 2×2 матрици.
   - Въпроси: Колко умножения и събирания са необходими за 2×2 матрици? Как се увеличава броят при по-големи матрици?

2. **Запознайте се с принципа "разделяй и владей"**
   - Фокус: Разделяне на матрици на четири подматрици.
   - Задача: Напишете функция, която разделя n×n матрица на четири n/2×n/2 блока.
   - Въпроси: Какво се случва с размерите при разделяне? Какво е базовият случай?

3. **Разберете седемте продукта на Страсен**
   - Фокус: Научете формулите за изчисляване на седемте междинни матрици.
   - Задача: Изчислете ръчно седемте продукта за две 2×2 матрици.
   - Въпроси: Защо са седем, а не осем? Как това намалява сложността?

4. **Имплементирайте Strassen алгоритъма рекурсивно**
   - Фокус: Комбиниране на междинните резултати за получаване на крайния продукт.
   - Задача: Напишете рекурсивна функция за Strassen умножение.
   - Въпроси: Как се обработват матрици с нечетни размери? Какво е базовият случай?

5. **Оптимизирайте и сравнете производителността**
   - Фокус: Измерване на време и памет при класическо и Strassen умножение.
   - Задача: Тествайте алгоритмите с големи матрици и анализирайте резултатите.
   - Въпроси: При какви размери Strassen става по-ефективен? Какви са ограниченията?

## 5. Examples

### Пример 1: Класическо умножение на 2×2 матрици

```python
def classic_multiply(A, B):
    n = len(A)
    C = [[0]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            for k in range(n):
                C[i][j] += A[i][k] * B[k][j]
    return C

A = [[1, 2],
     [3, 4]]
B = [[5, 6],
     [7, 8]]

print(classic_multiply(A, B))
```

### Пример 2: Strassen умножение на 2×2 матрици

```python
def add_matrix(A, B):
    n = len(A)
    return [[A[i][j] + B[i][j] for j in range(n)] for i in range(n)]

def sub_matrix(A, B):
    n = len(A)
    return [[A[i][j] - B[i][j] for j in range(n)] for i in range(n)]

def strassen(A, B):
    n = len(A)
    if n == 1:
        return [[A[0][0] * B[0][0]]]
    mid = n // 2

    # Разделяне на матриците
    A11 = [row[:mid] for row in A[:mid]]
    A12 = [row[mid:] for row in A[:mid]]
    A21 = [row[:mid] for row in A[mid:]]
    A22 = [row[mid:] for row in A[mid:]]

    B11 = [row[:mid] for row in B[:mid]]
    B12 = [row[mid:] for row in B[:mid]]
    B21 = [row[:mid] for row in B[mid:]]
    B22 = [row[mid:] for row in B[mid:]]

    # Седемте продукта на Страсен
    M1 = strassen(add_matrix(A11, A22), add_matrix(B11, B22))
    M2 = strassen(add_matrix(A21, A22), B11)
    M3 = strassen(A11, sub_matrix(B12, B22))
    M4 = strassen(A22, sub_matrix(B21, B11))
    M5 = strassen(add_matrix(A11, A12), B22)
    M6 = strassen(sub_matrix(A21, A11), add_matrix(B11, B12))
    M7 = strassen(sub_matrix(A12, A22), add_matrix(B21, B22))

    # Комбиниране на резултатите
    C11 = add_matrix(sub_matrix(add_matrix(M1, M4), M5), M7)
    C12 = add_matrix(M3, M5)
    C21 = add_matrix(M2, M4)
    C22 = add_matrix(sub_matrix(add_matrix(M1, M3), M2), M6)

    # Сглобяване на крайния резултат
    C = []
    for i in range(mid):
        C.append(C11[i] + C12[i])
    for i in range(mid):
        C.append(C21[i] + C22[i])

    return C

A = [[1, 2],
     [3, 4]]
B = [[5, 6],
     [7, 8]]

print(strassen(A, B))
```

### Пример 3: Използване на Strassen за по-големи матрици (8×8)

- Разделяне на матриците на 4×4 подматрици и рекурсивно прилагане на алгоритъма.
- Практическо упражнение: Имплементирайте и тествайте Strassen за 8×8 матрици.

## 6. Common Pitfalls

- **Неправилно разделяне на матриците при нечетен размер** – Strassen изисква размерите да са степени на 2; за други размери се използва допълнително запълване с нули.
- **Прекалена рекурсия при малки матрици** – При много малки размери класическото умножение е по-ефективно; добра практика е да се премине към класическо умножение под определен праг.
- **Грешки при комбиниране на седемте продукта** – Неправилното събиране и изваждане на междинните матрици води до грешни резултати.
- **Пренебрегване на паметта** – Рекурсивният подход използва допълнителна памет за междинните матрици; оптимизацията е важна при големи размери.
- **Неоптимизирана имплементация** – Липсата на векторизация или паралелизация може да намали реалната полза от алгоритъма.

## 7. Short Retrieval Quiz

1. Каква е времевата сложност на класическото умножение на матрици?
2. Как Strassen алгоритъмът намалява броя на умноженията?
3. Какво представляват седемте продукта на Страсен?
4. Защо е важно да се използва базов случай в рекурсивния алгоритъм?
5. Как се справя Strassen с матрици с размер, който не е степен на 2?
6. Кога класическото умножение може да бъде по-ефективно от Strassen?
7. Какво е основното предимство на Strassen алгоритъма в контекста на AI?

## 8. Quick Recap

- Strassen алгоритъмът намалява сложността на умножение на матрици от O(n³) до около O(n^2.81).
- Използва "разделяй и владей" подход, разделяйки матриците на подматрици.
- Вместо 8 умножения, алгоритъмът прави само 7, чрез специални междинни изчисления.
- Рекурсивната структура изисква базов случай и внимателно комбиниране на резултатите.
- Подходящ е за големи матрици и ускорява изчисленията в AI и научни приложения.
- Трябва да се внимава с размерите на матриците и оптимизацията на паметта.
- Често се комбинира с класическо умножение за малки размери.

## 9. Spaced Review Plan

| Време след изучаване | Промпт за преглед                                    |
|----------------------|-----------------------------------------------------|
| 1 ден                | Обяснете принципа на Strassen алгоритъма с примери.|
| 3 дни                | Имплементирайте разделяне на матрици и седемте продукта.|
| 1 седмица            | Сравнете класическо и Strassen умножение по време и памет.|
| 1 месец              | Опишете кога и защо Strassen е предпочитан в AI системи.|