# Interview_problem_sets

## 1. Activate Prior Knowledge

- Какви видове задачи сте срещали в интервюта за софтуерни инженери и какви умения изискват те?
- Как мислите, че решаването на проблеми в интервюта се свързва с реалния процес на разработка на софтуер и AI системи?
- Кои алгоритмични концепции и структури от данни са най-често използвани при решаване на интервю задачи?

## 2. Overview

Интервю проблемните сетове (Interview problem sets) представляват колекции от задачи, които кандидатите за позиции в софтуерната индустрия решават, за да демонстрират своите умения по програмиране, алгоритми и дизайн на системи. Те са съществена част от процеса на подбор, тъй като позволяват на интервюиращите да оценят аналитичното мислене, способността за решаване на проблеми и техническата компетентност на кандидатите.

Тези задачи обикновено включват алгоритмични предизвикателства, структуриране на данни, оптимизация и понякога дизайн на системи. В контекста на AI системите, те могат да включват и задачи свързани с обработка на големи данни, машинно обучение или оптимизация на модели. Разбирането и овладяването на тези проблеми е ключово за успешното навлизане в индустрията и за ефективната работа в екипи, които разработват сложни софтуерни продукти.

Интервю проблемните сетове също така служат като мост между теоретичните знания и практическите умения, като подготвят кандидатите за реални инженерни предизвикателства. Те стимулират систематичното мислене, умението за разбиване на сложни задачи на по-малки подзадачи и прилагането на доказани алгоритмични техники.

## 3. Key Concepts

- **Algorithmic Complexity** – Мярка за времето и пространството, необходимо за изпълнение на алгоритъм. Аналогично на това колко време и ресурси отнема да изпълниш задача в реалния живот.
- **Data Structures** – Организации на данни като масиви, списъци, дървета и графи, които улесняват ефективното съхранение и достъп. Можем да ги сравним с различни видове шкафове и кутии за съхранение.
- **Recursion** – Метод, при който функцията се извиква сама, за да реши по-малки части от задачата. Подобно на огледала, които се отразяват едно в друго.
- **Dynamic Programming** – Техника за решаване на проблеми чрез разбиване на по-малки подзадачи и запомняне на резултатите, за да се избегне повторение. Представете си, че си водите бележки, за да не правите една и съща работа два пъти.
- **Greedy Algorithms** – Подход, при който се взема най-доброто локално решение с надеждата да се достигне до глобално оптимално. Като да избирате най-вкусната хапка от всяко ястие, надявайки се да се нахраните добре.
- **Backtracking** – Техника за търсене на решения чрез проба и грешка, връщайки се назад при неуспех. Мислете за лабиринт, в който се връщате назад, когато срещнете задънена улица.
- **Big O Notation** – Символен език за описване на най-лошия случай на алгоритмична сложност. Като да оценявате колко дълго ще ви отнеме да прочетете книга в най-бавния случай.

## 4. Step-by-step Learning Path

1. **Фокус:** Разбиране на основните структури от данни  
   **Задача:** Имплементирайте стек и опашка с помощта на масиви или свързани списъци.  
   **Въпроси за припомняне:** Каква е разликата между стек и опашка? Кога е по-подходящо да използваме свързан списък вместо масив?

2. **Фокус:** Изучаване на базови алгоритми за сортиране и търсене  
   **Задача:** Напишете алгоритъм за сортиране чрез сливане (merge sort) и бинарно търсене.  
   **Въпроси за припомняне:** Каква е времевата сложност на merge sort? Как работи бинарното търсене?

3. **Фокус:** Решаване на рекурсивни задачи  
   **Задача:** Решете класическата задача за изчисляване на факториел и Фибоначи с рекурсия.  
   **Въпроси за припомняне:** Какво е рекурсия? Какво е базовият случай?

4. **Фокус:** Динамично програмиране и оптимизация  
   **Задача:** Решете задачата за най-дълга обща подредена последователност (Longest Common Subsequence).  
   **Въпроси за припомняне:** Как динамичното програмиране подобрява ефективността? Как се запомнят междинните резултати?

5. **Фокус:** Решаване на задачи с графи и дървета  
   **Задача:** Имплементирайте алгоритъм за обхождане в дълбочина (DFS) и широчина (BFS).  
   **Въпроси за припомняне:** Каква е разликата между DFS и BFS? Кога е подходящо да използваме всеки от тях?

6. **Фокус:** Практика с интервю задачи от реални компании  
   **Задача:** Решете 3 задачи от платформи като LeetCode или HackerRank, свързани с масиви, низове и хеш таблици.  
   **Въпроси за припомняне:** Какви техники използвахте за оптимизация? Как проверихте коректността на решенията?

## 5. Examples

### Пример 1: Проверка дали низ е палиндром

```python
def is_palindrome(s: str) -> bool:
    return s == s[::-1]

print(is_palindrome("radar"))  # True
print(is_palindrome("hello"))  # False
```

### Пример 2: Имплементация на бинарно търсене

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

print(binary_search([1, 3, 5, 7, 9], 5))  # 2
print(binary_search([1, 3, 5, 7, 9], 6))  # -1
```

### Пример 3: Най-дълга обща подредена последователност (LCS)

```python
def lcs(X, Y):
    m, n = len(X), len(Y)
    dp = [[0]*(n+1) for _ in range(m+1)]
    for i in range(m):
        for j in range(n):
            if X[i] == Y[j]:
                dp[i+1][j+1] = dp[i][j] + 1
            else:
                dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j])
    return dp[m][n]

print(lcs("AGGTAB", "GXTXAYB"))  # 4
```

## 6. Common Pitfalls

- **Игнориране на гранични случаи** – Например празни масиви, много големи или много малки входни данни. Винаги тествайте с различни входове.
- **Прекомерна сложност** – Опит да се реши задача с неефективен алгоритъм, който не е приложим при големи обеми данни.
- **Липса на разбиване на задачата** – Опит да се реши проблем наведнъж, без да се раздели на по-малки, по-лесно управляеми части.
- **Забравяне за оптимизация на паметта** – Използване на излишни структури от данни, което води до ненужно голямо потребление на памет.
- **Неправилна употреба на рекурсия** – Липса на базов случай или прекалено дълбока рекурсия, която води до стек overflow.
- **Пренебрегване на тестване и отстраняване на грешки** – Необходимо е да се пишат тестове и да се проверява коректността на решенията.

## 7. Short Retrieval Quiz

1. Каква е разликата между стек и опашка?
2. Какво представлява алгоритъмът merge sort и каква е неговата времева сложност?
3. Какво е динамично програмиране и как помага при решаването на задачи?
4. Кога е подходящо да използваме алгоритъм за обхождане в широчина (BFS)?
5. Какво е базовият случай при рекурсия?
6. Какво означава Big O нотация?
7. Какво представлява greedy алгоритъм?

## 8. Quick Recap

- Интервю проблемните сетове са ключов инструмент за оценка на техническите умения в софтуерната индустрия.
- Основните концепции включват алгоритми, структури от данни, рекурсия, динамично програмиране и графови алгоритми.
- Практическото решаване на задачи и разбиването им на подзадачи е критично за успеха.
- Тестовете и вниманието към гранични случаи подобряват качеството на решенията.
- Оптимизацията на време и памет е важна за реалистични инженерни приложения.
- Разбирането на алгоритмичната сложност помага при избора на подходящ подход.
- Постоянната практика и преглед на решените задачи водят до трайно усвояване.

## 9. Spaced Review Plan

| Време след учене | Прегледен въпрос                                     |
|------------------|-----------------------------------------------------|
| 1 ден            | Какви са основните структури от данни и кога се използват? |
| 3 дни            | Обяснете принципа на динамичното програмиране.      |
| 1 седмица        | Кога и как се използва бинарно търсене?              |
| 1 месец          | Какви са типичните грешки при решаване на интервю задачи и как да ги избегнем? |