# Shortest_path_algorithms

## 1. Activate Prior Knowledge
- Какво представлява пътят в граф и как бихте дефинирали най-краткия път между две точки?
- Къде в софтуерните системи или в изкуствения интелект може да се използва алгоритъм за намиране на най-кратък път?
- Как мислите, кои фактори влияят върху избора на конкретен алгоритъм за намиране на най-кратък път?

## 2. Overview
Алгоритмите за намиране на най-кратък път са фундаментални инструменти в компютърните науки и инженерството, използвани за намиране на най-ефективния маршрут между две или повече точки в графова структура. Те имат широко приложение в навигационни системи, мрежова оптимизация, роботика, планиране на маршрути и дори в анализ на социални мрежи.

В контекста на изкуствения интелект и софтуерното инженерство, тези алгоритми подпомагат вземането на решения и оптимизирането на ресурси, като минимизират времето, разходите или други мерки за "разстояние". Те са част от по-големи системи за планиране, търсене и оптимизация, които позволяват на машините да работят по-интелигентно и ефективно.

Разбирането на различните алгоритми, техните предимства, ограничения и подходящи случаи на употреба е ключово за изграждането на надеждни и бързи системи. Практическото приложение изисква не само теоретични знания, но и умения за имплементация и оптимизация.

## 3. Key Concepts
- **Граф (Graph)** – структура от върхове (nodes) и ребра (edges), която моделира връзки между обекти. Мислете за карта на град с кръстовища и улици.
- **Най-кратък път (Shortest Path)** – поредица от ребра, свързващи два върха с минимална обща "тегло" или разстояние.
- **Тегло на ребро (Edge Weight)** – числова стойност, която описва "цена" или "разстояние" на преминаване през реброто.
- **Дейкстра (Dijkstra’s Algorithm)** – класически алгоритъм за намиране на най-кратък път в граф с неотрицателни тегла.
- **Белман-Форд (Bellman-Ford Algorithm)** – алгоритъм, който може да работи и с отрицателни тегла, открива и отрицателни цикли.
- **A\* (A-star) Algorithm** – евристичен алгоритъм, който използва оценка (хевристика) за по-бързо намиране на път.
- **Хевристика (Heuristic)** – функция, която оценява колко близо е даден връх до целта, помага за насочване на търсенето.
- **Отрицателен цикъл (Negative Cycle)** – цикъл в графа, чиято сума от теглата е отрицателна, което прави най-краткия път неопределен.

## 4. Step-by-step Learning Path
1. **Запознайте се с основите на графите и представянето им**
   - Задача: Имплементирайте граф с използване на списък със съседство.
   - Въпроси: Какво е разликата между списък със съседство и матрица на съседство? Защо списъкът е по-ефективен при разредени графи?

2. **Разберете алгоритъма на Дейкстра**
   - Задача: Имплементирайте алгоритъма на Дейкстра за граф с неотрицателни тегла.
   - Въпроси: Какво е значението на приоритетната опашка в алгоритъма? Как се обновяват разстоянията?

3. **Изучете алгоритъма на Белман-Форд и обработка на отрицателни тегла**
   - Задача: Имплементирайте Белман-Форд и проверете за отрицателни цикли.
   - Въпроси: Как алгоритъмът открива отрицателни цикли? Защо не може да се използва Дейкстра при отрицателни тегла?

4. **Запознайте се с A\* и хевристичните методи**
   - Задача: Имплементирайте A\* с проста евристика (например Евклидово разстояние).
   - Въпроси: Как хевристиката влияе на производителността? Какво се случва, ако хевристиката не е адекватна?

5. **Приложете алгоритмите на реални задачи**
   - Задача: Използвайте алгоритъм за намиране на най-кратък път в карта на град или мрежа.
   - Въпроси: Какви оптимизации бихте приложили за големи графи? Как да се справите с динамични промени в графа?

## 5. Examples

### Пример 1: Дейкстра на прост граф
```python
import heapq

def dijkstra(graph, start):
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    queue = [(0, start)]
    
    while queue:
        current_distance, current_node = heapq.heappop(queue)
        
        if current_distance > distances[current_node]:
            continue
        
        for neighbor, weight in graph[current_node]:
            distance = current_distance + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(queue, (distance, neighbor))
    return distances

graph = {
    'A': [('B', 1), ('C', 4)],
    'B': [('C', 2), ('D', 5)],
    'C': [('D', 1)],
    'D': []
}

print(dijkstra(graph, 'A'))
```

### Пример 2: Белман-Форд с откриване на отрицателен цикъл
```python
def bellman_ford(graph, start):
    distance = {node: float('inf') for node in graph}
    distance[start] = 0
    
    for _ in range(len(graph) - 1):
        for u in graph:
            for v, w in graph[u]:
                if distance[u] + w < distance[v]:
                    distance[v] = distance[u] + w
    
    # Проверка за отрицателен цикъл
    for u in graph:
        for v, w in graph[u]:
            if distance[u] + w < distance[v]:
                return "Отрицателен цикъл открит"
    return distance
```

### Пример 3: A* с Евклидова хевристика (псевдокод)
```python
def heuristic(a, b):
    return ((a[0] - b[0])**2 + (a[1] - b[1])**2) ** 0.5

def a_star(graph, start, goal):
    open_set = set([start])
    came_from = {}
    g_score = {node: float('inf') for node in graph}
    g_score[start] = 0
    f_score = {node: float('inf') for node in graph}
    f_score[start] = heuristic(start, goal)
    
    while open_set:
        current = min(open_set, key=lambda x: f_score[x])
        if current == goal:
            return reconstruct_path(came_from, current)
        
        open_set.remove(current)
        for neighbor in graph[current]:
            tentative_g_score = g_score[current] + graph[current][neighbor]
            if tentative_g_score < g_score[neighbor]:
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g_score
                f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal)
                open_set.add(neighbor)
    return None
```

## 6. Common Pitfalls
- **Игнориране на отрицателни тегла** – използването на Дейкстра при граф с отрицателни ребра води до грешни резултати.
- **Неправилна инициализация на разстоянията** – забравяне да се зададе началното разстояние на 0 или неправилно задаване на безкрайност.
- **Липса на проверка за отрицателни цикли** – при Белман-Форд е важно да се откриват такива цикли, за да се избегне безкрайно обновяване.
- **Неподходяща хевристика в A\*** – ако хевристиката не е адекватна (например надценява разстоянието), алгоритъмът може да не намери оптималния път.
- **Пренебрегване на сложността и оптимизацията** – при големи графи неефективните имплементации водят до значително забавяне.

## 7. Short Retrieval Quiz
1. Какво представлява най-краткият път в граф?
2. Кога е подходящо да използваме алгоритъма на Белман-Форд вместо Дейкстра?
3. Каква е ролята на хевристиката в алгоритъма A\*?
4. Какво означава отрицателен цикъл и защо е проблем?
5. Какво е основното предимство на списъка със съседство пред матрицата на съседство?
6. Как се използва приоритетната опашка в алгоритъма на Дейкстра?
7. Какво може да се случи, ако хевристиката в A\* надценява разстоянието?

## 8. Quick Recap
- Най-краткият път е минималната "цена" за достигане от един връх до друг в граф.
- Дейкстра е ефективен за графи с неотрицателни тегла.
- Белман-Форд поддържа отрицателни тегла и открива отрицателни цикли.
- A\* използва хевристика за по-бързо намиране на път, като балансира между точност и производителност.
- Правилната структура на данните и инициализация са ключови за коректна имплементация.
- Изборът на алгоритъм зависи от характеристиките на графа и изискванията на приложението.
- Често срещани грешки включват неправилно боравене с тегла и липса на проверки за специални случаи.

## 9. Spaced Review Plan

| Време след учене | Промпт за преглед                                      |
|------------------|-------------------------------------------------------|
| 1 ден            | Обяснете с прости думи как работи алгоритъмът на Дейкстра. |
| 3 дни            | Кога и защо използваме Белман-Форд вместо Дейкстра?   |
| 1 седмица        | Опишете ролята на хевристиката в A\* и как влияе на резултата. |
| 1 месец          | Прегледайте основните алгоритми и опишете типичните грешки при имплементация. |