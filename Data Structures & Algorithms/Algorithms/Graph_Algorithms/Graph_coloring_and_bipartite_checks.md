# Graph_coloring_and_bipartite_checks

## 1. Activate Prior Knowledge

- Какво представлява граф и какви видове графи познавате?
- Как бихте използвали графове за моделиране на проблеми в изкуствения интелект или софтуерното инженерство?
- Какво означава „оцветяване на граф“ и как може да помогне при решаване на задачи като разпределяне на ресурси или проверка на свойства на графа?

## 2. Overview

Graph coloring (оцветяване на граф) е техника, при която на върховете на графа се присвояват цветове така, че съседни върхове да не споделят един и същ цвят. Това е фундаментален проблем в теорията на графите с приложения в планиране, разпределение на ресурси, регистрация на променливи в компилатори и много други области. В контекста на AI системи, graph coloring може да помогне за оптимизиране на задачи, където конфликтите трябва да се избегнат.

Проверка дали даден граф е двуделен (bipartite check) е свързана с възможността да се разделят върховете на две множества, без да има ребра вътре в някое от тях. Това свойство е важно в моделирането на взаимоотношения, като например задачи за съвпадение (matching) или разпознаване на структури в данни.

Тези две теми са тясно свързани: граф е двуделен точно когато може да се оцвети с два цвята без конфликти. Разбирането и прилагането на тези концепции е ключово за ефективното решаване на множество практически задачи в софтуерното инженерство и AI.

## 3. Key Concepts

- **Graph (Граф)** – структура, съставена от върхове (nodes) и ребра (edges), които ги свързват. Мислете за графа като карта на връзки между обекти.
- **Vertex Coloring (Оцветяване на върхове)** – присвояване на цветове на върховете така, че съседни върхове да имат различен цвят. Аналогия: разпределяне на стаи на студенти, които не искат да споделят стая с определени други.
- **Chromatic Number (Хроматично число)** – минималният брой цветове, необходими за оцветяване на графа без конфликт.
- **Bipartite Graph (Двуделен граф)** – граф, чийто върхове могат да се разделят на две множества, без ребра между върхове в едно и също множество. Мислете за двуделен граф като за социална мрежа с две отделни групи, където връзките са само между групите.
- **Bipartite Check (Проверка за двуделен граф)** – алгоритъм, който определя дали графът е двуделен, обикновено чрез оцветяване с два цвята или чрез обход в ширина (BFS).
- **Conflict (Конфликт)** – ситуация, в която две съседни върхове имат един и същ цвят, което е нежелано при оцветяване.
- **Depth-First Search (DFS) и Breadth-First Search (BFS)** – алгоритми за обхождане на граф, използвани за проверка на двуделен характер и оцветяване.

## 4. Step-by-step Learning Path

1. **Запознайте се с основите на графите**
   - Фокус: понятия за върхове, ребра, видове графи.
   - Задача: Нарисувайте прост граф и идентифицирайте върхове и ребра.
   - Въпроси: Какво е съседство в граф? Какво е степен на връх?

2. **Разберете концепцията за оцветяване на граф**
   - Фокус: какво означава оцветяване и защо е важно.
   - Задача: Опитайте ръчно да оцветите малък граф с минимален брой цветове.
   - Въпроси: Какво е хроматичното число? Защо не можем да оцветим граф с по-малко цветове от хроматичното число?

3. **Изучете алгоритми за проверка на двуделен граф**
   - Фокус: BFS и DFS за двуделен тест.
   - Задача: Имплементирайте двуделен тест с BFS на малък граф.
   - Въпроси: Какво означава, ако открием ребро между върхове със същия цвят?

4. **Прилагайте оцветяване за решаване на практически проблеми**
   - Фокус: използване на graph coloring за задачи като разпределение на ресурси.
   - Задача: Моделирайте задача за разпределяне на часове в университет с оцветяване.
   - Въпроси: Как оцветяването помага за избягване на конфликти?

5. **Оптимизирайте и анализирайте алгоритмите**
   - Фокус: сложност, ефективност и ограничения.
   - Задача: Сравнете BFS и DFS подходи за двуделен тест по време на изпълнение.
   - Въпроси: Каква е времевата сложност на двуделен тест? Какво се случва при граф с цикли с нечетна дължина?

## 5. Examples

### Пример 1: Проверка дали граф е двуделен с BFS (Python)

```python
from collections import deque

def is_bipartite(graph):
    color = {}
    for node in graph:
        if node not in color:
            queue = deque([node])
            color[node] = 0
            while queue:
                u = queue.popleft()
                for v in graph[u]:
                    if v not in color:
                        color[v] = 1 - color[u]
                        queue.append(v)
                    elif color[v] == color[u]:
                        return False
    return True

# Примерен граф (ръчно дефиниран)
graph = {
    0: [1, 3],
    1: [0, 2],
    2: [1, 3],
    3: [0, 2]
}

print(is_bipartite(graph))  # Изход: True
```

### Пример 2: Оцветяване на граф с жаден алгоритъм (Greedy coloring)

```python
def greedy_coloring(graph):
    result = {}
    for node in graph:
        available = set(range(len(graph)))
        for neighbor in graph[node]:
            if neighbor in result:
                available.discard(result[neighbor])
        result[node] = min(available)
    return result

graph = {
    0: [1, 2],
    1: [0, 2],
    2: [0, 1, 3],
    3: [2]
}

print(greedy_coloring(graph))  # Примерен изход: {0: 0, 1: 1, 2: 2, 3: 0}
```

## 6. Common Pitfalls

- **Игнориране на цикли с нечетна дължина при двуделен тест** – такива цикли правят графа недвуделен. Винаги проверявайте за конфликти при оцветяване.
- **Използване на неподходящи структури за графа** – например, списък със съседство е по-ефективен от матрица за разредени графи.
- **Прекалено опростяване на оцветяването** – жадният алгоритъм не винаги дава оптимално решение (минимален брой цветове).
- **Забравяне за всички компоненти на графа** – при непълно свързани графи трябва да се проверяват всички компоненти.
- **Неотчитане на посоченост на графа** – алгоритмите за двуделен тест са приложими за неориентирани графи.

## 7. Short Retrieval Quiz

1. Какво означава, че граф е двуделен?
2. Какъв е основният принцип на оцветяване на граф?
3. Кой алгоритъм често се използва за проверка дали граф е двуделен?
4. Какво е хроматично число?
5. Защо жадният алгоритъм за оцветяване не винаги дава оптимално решение?
6. Какво означава конфликт при оцветяване на граф?
7. Какво се случва, ако графът съдържа цикъл с нечетна дължина?

## 8. Quick Recap

- Graph coloring присвоява цветове на върхове така, че съседни върхове да имат различни цветове.
- Двуделен граф може да се оцвети с точно два цвята без конфликти.
- Проверка за двуделен граф се извършва чрез BFS или DFS с оцветяване.
- Жадният алгоритъм за оцветяване е прост, но не винаги оптимален.
- Циклите с нечетна дължина правят графа недвуделен.
- Оцветяването и двуделен тест имат широки приложения в AI и софтуерното инженерство.
- Винаги проверявайте всички компоненти на графа при анализ.

## 9. Spaced Review Plan

| Време след учене | Промпт за преглед                                      |
|-------------------|-------------------------------------------------------|
| 1 ден             | Обяснете с прости думи какво е двуделен граф и защо е важен. |
| 3 дни             | Имплементирайте двуделен тест с BFS на малък граф.    |
| 1 седмица         | Опишете разликите между жаден алгоритъм и оптимално оцветяване. |
| 1 месец           | Приложете graph coloring за решаване на реален проблем с разпределение на ресурси. |