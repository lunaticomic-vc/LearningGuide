# 09 - Concurrency and thread-safety at code level

## 1. Activate Prior Knowledge

- Какво се случва, когато два или повече процеса или нишки опитват да достъпят и променят една и съща променлива едновременно?
- Можете ли да си спомните ситуации, в които програмата ви е работила непредсказуемо или е "забивала" при паралелна обработка?
- Какви са потенциалните рискове при използване на многонитово програмиране в системи с изкуствен интелект или уеб сървъри?

## 2. Overview

Concurrency (едновременност) и thread-safety (нишкова безопасност) са фундаментални теми в съвременното софтуерно инженерство, особено при изграждането на мащабируеми и ефективни системи. Когато множество нишки или процеси работят паралелно, те често трябва да споделят ресурси – памет, файлове или други данни. Без подходящ контрол, това може да доведе до грешки, които са трудни за откриване и възпроизвеждане.

В контекста на AI системи, сървъри или всякакви приложения с висока производителност, правилното управление на едновременния достъп е критично за коректността и стабилността. Thread-safety гарантира, че кодът ще работи правилно, независимо от броя нишки, които го изпълняват едновременно.

Разбирането на тези концепции позволява на инженерите да създават по-надеждни, бързи и мащабируеми приложения. Това включва използване на синхронизационни механизми, избягване на състезателни условия и осигуряване на атомарност при критични операции.

## 3. Key Concepts

- Concurrency (Едновременност) – Способността на една програма да изпълнява няколко задачи "едновременно", често чрез превключване между тях. Представете си готвач, който приготвя няколко ястия паралелно.
- Thread (Нишка) – Лека единица на изпълнение в процеса, която може да работи паралелно с други нишки в същия процес.
- Thread-safety (Нишкова безопасност) – Свойство на кода да функционира коректно при едновременен достъп от множество нишки, без неочаквани странични ефекти.
- Race Condition (Състезателно състояние) – Грешка, възникваща, когато резултатът зависи от неочакван ред на изпълнение на нишките.
- Critical Section (Критична секция) – Част от кода, която трябва да се изпълнява само от една нишка наведнъж, за да се избегнат конфликти.
- Lock/Mutex (Заключване/Мютекс) – Механизъм за синхронизация, който позволява само една нишка да влиза в критична секция в даден момент.
- Deadlock (Задънена улица) – Ситуация, при която две или повече нишки чакат една друга да освободят ресурси, което води до застой.

## 4. Step-by-step Learning Path

1. **Разберете основите на нишките**
   - Фокус: Какво представляват нишките и как се създават.
   - Задача: Създайте проста програма с две нишки, които отпечатват числа.
   - Въпроси: Как се различава нишката от процеса? Как се стартира нишка във вашия език?

2. **Изследвайте състезателни условия**
   - Фокус: Как възникват race conditions.
   - Задача: Напишете код, в който две нишки увеличават една и съща променлива без синхронизация.
   - Въпроси: Какъв е резултатът? Винаги ли е същият?

3. **Научете за критични секции и заключвания**
   - Фокус: Как да защитим споделени ресурси.
   - Задача: Използвайте mutex/lock, за да направите предишния код thread-safe.
   - Въпроси: Какво се промени? Как lock-ът предотвратява проблеми?

4. **Разберете deadlock и как да го избягвате**
   - Фокус: Как възниква deadlock и как да го предотвратим.
   - Задача: Напишете пример с две нишки и два lock-а, които водят до deadlock.
   - Въпроси: Как може да се избегне deadlock в този случай?

5. **Приложете знанията в реален сценарий**
   - Фокус: Синхронизация в по-голям контекст (например кеш, база данни).
   - Задача: Имплементирайте thread-safe кеш с lock.
   - Въпроси: Къде още е важно да се осигури thread-safety?

## 5. Examples

### Пример 1: Race Condition

```python
import threading

counter = 0

def increment():
    global counter
    for _ in range(100000):
        counter += 1

threads = [threading.Thread(target=increment) for _ in range(2)]
for t in threads:
    t.start()
for t in threads:
    t.join()

print(counter)  # Очаквано: 200000, Реално: по-малко (race condition)
```

### Пример 2: Thread-safe с Lock

```python
import threading

counter = 0
lock = threading.Lock()

def increment():
    global counter
    for _ in range(100000):
        with lock:
            counter += 1

threads = [threading.Thread(target=increment) for _ in range(2)]
for t in threads:
    t.start()
for t in threads:
    t.join()

print(counter)  # Винаги 200000
```

### Пример 3: Deadlock

```python
import threading

lock1 = threading.Lock()
lock2 = threading.Lock()

def thread1():
    with lock1:
        with lock2:
            print("Thread 1")

def thread2():
    with lock2:
        with lock1:
            print("Thread 2")

t1 = threading.Thread(target=thread1)
t2 = threading.Thread(target=thread2)
t1.start()
t2.start()
t1.join()
t2.join()
# Програмата може да "забие" поради deadlock
```

## 6. Common Pitfalls

- **Пренебрегване на синхронизацията:** Използване на споделени ресурси без lock води до race conditions.
- **Използване на прекалено много lock-ове:** Това може да доведе до deadlock или до сериозно забавяне на програмата.
- **Грешен обхват на lock:** Заключване на твърде големи части от кода намалява производителността.
- **Неправилно освобождаване на lock:** Забравен или неправилно освободен lock може да блокира други нишки.
- **Смесване на различни синхронизационни механизми:** Това може да доведе до неочаквано поведение и трудни за откриване грешки.

## 7. Short Retrieval Quiz

1. Какво е race condition и кога възниква?
2. Как mutex/lock предотвратява едновременен достъп до критична секция?
3. Какво е deadlock и как може да се получи?
4. Каква е разликата между thread и process?
5. Какво означава даден код да е thread-safe?
6. Какви са рисковете при липса на синхронизация между нишки?
7. Как може да се избегне deadlock?

## 8. Quick Recap

- Concurrency позволява едновременна обработка на задачи, но изисква внимателно управление на споделени ресурси.
- Thread-safety гарантира, че кодът работи коректно при паралелно изпълнение.
- Race conditions възникват при неконтролиран достъп до споделени данни.
- Locks и mutex-и са основни инструменти за синхронизация.
- Deadlock е опасна ситуация, която може да блокира цялата система.
- Добрата практика изисква минимизиране на критичните секции и внимателно проектиране на синхронизацията.
- Thread-safety е критична за надеждността на мащабируеми и многонитови системи.

## 9. Spaced Review Plan

| Review Time | Prompt                                                   |
|-------------|---------------------------------------------------------|
| 1 day       | Обяснете с пример какво е race condition и как се решава. |
| 3 days      | Опишете как бихте направили даден клас thread-safe.      |
| 1 week      | Какви са основните причини за deadlock и как да ги избегнете? |
| 1 month     | Дайте пример от практика, където thread-safety е критична. |