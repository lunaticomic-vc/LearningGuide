# Grid_and_graph_DP

## 1. Activate Prior Knowledge
- Какво представлява динамичното програмиране (DP) и как се прилага при решаване на проблеми с оптимизация?
- Как бихте представили двумерна мрежа (grid) или граф (graph) като структура от възли и ръбове в контекста на алгоритми?
- В кои ситуации при разработка на AI системи или софтуерни приложения бихте използвали DP върху граф или мрежа?

## 2. Overview
Динамичното програмиране върху мрежи и графи е мощна техника за решаване на комплексни проблеми, които могат да бъдат разбити на по-малки, припокриващи се подпроблеми. Този подход е особено полезен, когато търсим оптимални пътища, максимални стойности или минимални разходи в структури, които имат множество възможни състояния и преходи.

В контекста на двумерни мрежи (grids), DP често се използва за намиране на пътища с минимална сума, максимален брой стъпки или други оптимални критерии. При графите, DP може да се прилага за задачи като намиране на най-кратък път, броене на пътища или решаване на задачи с ограничени ресурси.

Тази техника е фундаментална за много AI системи, като роботика (навигиране в среда), планиране и оптимизация, както и за софтуерни инженерни задачи, включително анализ на мрежи и обработка на големи данни.

## 3. Key Concepts
- **Dynamic Programming (DP)** – метод за решаване на проблеми чрез разбиване на по-малки подпроблеми и запазване на техните решения, за да се избегне повторно изчисление. Мислете за него като за „запомняне“ на вече решени задачи.
- **Grid (Мрежа)** – двумерна структура от клетки, където всяка клетка може да бъде възел с връзки към съседни клетки. Представете си шахматна дъска, където всяка клетка е възел.
- **Graph (Граф)** – абстрактна структура от възли (nodes) и ръбове (edges), която може да бъде насочена или ненасочена. Мислете за карта с градове (възли) и пътища (ръбове).
- **State** – конкретно състояние в DP, което описва текущата позиция или конфигурация в мрежата или графа.
- **Transition** – начинът, по който се преминава от едно състояние към друго, обикновено чрез ръб или движение в мрежата.
- **Memoization** – техника за съхранение на резултати от изчисления, за да се избегне повторно решаване на същия подпроблем.
- **Topological Order** – подредба на възлите в насочен ацикличен граф (DAG), която позволява DP да се изпълнява последователно без цикли.

## 4. Step-by-step Learning Path
1. **Разберете основите на динамичното програмиране**
   - Фокус: Прегледайте класически DP задачи (като Fibonacci, Knapsack).
   - Задача: Реализирайте Fibonacci с мемоизация.
   - Въпроси: Как DP намалява времевата сложност? Какво е припокриващ се подпроблем?

2. **Запознайте се с представянето на мрежи и графи**
   - Фокус: Научете как се моделират grid и graph структури в код.
   - Задача: Създайте двумерен масив за grid и списък със съседи за graph.
   - Въпроси: Каква е разликата между grid и graph? Как се представят ръбове?

3. **Изучете DP върху grid**
   - Фокус: Решете задачи за намиране на път с минимална сума в grid.
   - Задача: Имплементирайте DP алгоритъм за минимална сума по път от горния ляв ъгъл до долния десен.
   - Въпроси: Какви са възможните преходи? Как се дефинира състоянието?

4. **Изучете DP върху графи**
   - Фокус: Разберете как DP се прилага върху DAG.
   - Задача: Реализирайте DP за намиране на най-кратък път в DAG.
   - Въпроси: Защо е важно топологичното сортиране? Как се избягват цикли?

5. **Практикувайте с по-сложни задачи**
   - Фокус: Решавайте задачи с ограничения, като броене на пътища или оптимизация с ресурси.
   - Задача: Имплементирайте броене на всички пътища от изходен възел до целеви в DAG.
   - Въпроси: Как се съхраняват междинните резултати? Как се избягва повторно изчисление?

## 5. Examples

### Пример 1: Минимална сума в grid
```python
def min_path_sum(grid):
    m, n = len(grid), len(grid[0])
    dp = [[0]*n for _ in range(m)]
    dp[0][0] = grid[0][0]

    for i in range(1, m):
        dp[i][0] = dp[i-1][0] + grid[i][0]
    for j in range(1, n):
        dp[0][j] = dp[0][j-1] + grid[0][j]

    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])

    return dp[m-1][n-1]
```

### Пример 2: Най-кратък път в DAG
```python
from collections import defaultdict, deque

def shortest_path_dag(edges, n, start):
    graph = defaultdict(list)
    indegree = [0]*n
    dist = [float('inf')]*n
    dist[start] = 0

    for u, v, w in edges:
        graph[u].append((v, w))
        indegree[v] += 1

    queue = deque([i for i in range(n) if indegree[i] == 0])

    while queue:
        u = queue.popleft()
        for v, w in graph[u]:
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
            indegree[v] -= 1
            if indegree[v] == 0:
                queue.append(v)

    return dist
```

### Пример 3: Броене на пътища в DAG
```python
def count_paths_dag(graph, start, end):
    memo = {}

    def dfs(u):
        if u == end:
            return 1
        if u in memo:
            return memo[u]
        total = 0
        for v in graph[u]:
            total += dfs(v)
        memo[u] = total
        return total

    return dfs(start)
```

## 6. Common Pitfalls
- **Игнориране на гранични случаи в grid** – например, забравяне да инициализирате първия ред и първата колона, което води до грешки при преходите.
- **Опит за DP върху граф с цикли без обработка** – DP изисква DAG или специална обработка на цикли, иначе алгоритъмът може да влезе в безкраен цикъл.
- **Липса на мемоизация или неправилно съхранение на състояния** – води до експоненциална сложност и бавна работа.
- **Неправилно дефиниране на състояния и преходи** – което прави DP алгоритъма неефективен или грешен.
- **Забравяне за топологично сортиране при DP върху графи** – без него не може да се гарантира коректен ред на изчисленията.

## 7. Short Retrieval Quiz
1. Какво представлява състоянието (state) в DP върху grid или graph?
2. Защо е важно топологичното сортиране при DP върху графи?
3. Какво е мемоизация и как помага на DP?
4. Какви са основните разлики между DP върху grid и върху граф?
5. Какво може да се случи, ако приложим DP върху граф с цикли без допълнителна обработка?
6. Кои са основните преходи в DP алгоритъм за минимална сума в grid?
7. Как DP помага при броене на пътища в DAG?

## 8. Quick Recap
- DP върху grid и graph решава сложни задачи чрез разбиване на подпроблеми и запомняне на резултати.
- Grid е двумерна структура, докато graph е по-обща структура с възли и ръбове.
- Състоянието описва текущата позиция или конфигурация, а преходите определят възможните движения.
- Топологичното сортиране е ключово за DP върху DAG, за да се избегнат цикли.
- Мемоизация предотвратява повторното изчисление и ускорява алгоритмите.
- Често срещани грешки включват неправилно дефиниране на състояния и игнориране на цикли.
- Практическите задачи включват намиране на минимални пътища, броене на пътища и оптимизация с ограничения.

## 9. Spaced Review Plan

| Време след учене | Прегледен въпрос                                    |
|------------------|----------------------------------------------------|
| 1 ден            | Какво е състояние и преход в DP върху grid?        |
| 3 дни            | Защо топологичното сортиране е важно при DP върху граф? |
| 1 седмица        | Как мемоизация подобрява ефективността на DP?      |
| 1 месец          | Опишете основните стъпки за решаване на задача с DP върху grid или graph. |