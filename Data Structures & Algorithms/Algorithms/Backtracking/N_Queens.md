# N_Queens

## 1. Activate Prior Knowledge
- Как бихте описали задачата за разполагане на ферзове на шахматна дъска, така че да не се нападат взаимно?
- Какви алгоритми или техники за изкуствен интелект познавате, които решават комбинаторни задачи с ограничения?
- Как бихте използвали решението на N_Queens в контекста на софтуерни системи, които изискват оптимизация или търсене в пространство на състояния?

## 2. Overview
Задачата N_Queens е класически проблем в областта на изкуствения интелект и алгоритмите, който се състои в разполагане на N ферзове на шахматна дъска с размер N×N така, че никой ферз да не може да атакува друг. Това означава, че не трябва да има два ферза в един и същ ред, колона или диагонал.

Този проблем е важен не само като интелектуално предизвикателство, но и като пример за техники за търсене с ограничения (constraint satisfaction problems - CSP). Решенията му и методите, използвани за тяхното намиране, се прилагат в много области на изкуствения интелект, като планиране, оптимизация и разпознаване на шаблони.

В софтуерното инженерство N_Queens служи като учебна платформа за разбиране на backtracking, рекурсия и ефективно ограничаване на търсенето. Освен това, той демонстрира как да се моделират и решават сложни проблеми с множество ограничения, което е ключово за разработката на интелигентни системи.

## 3. Key Concepts
- **Backtracking** – Метод за търсене, който изгражда решения постепенно и се връща назад при достигане на конфликт или безизходица. Може да се представи като „пробване и грешка“, но с интелигентно отхвърляне на неподходящи пътища.
- **Constraint Satisfaction Problem (CSP)** – Задача, при която трябва да се намери стойност за всяка променлива, така че да се удовлетворят всички ограничения. N_Queens е класически пример за CSP.
- **Рекурсия** – Техника, при която функция извиква сама себе си с по-малки подзадачи, често използвана за обхождане на дървовидни структури на решения.
- **Шахматна дъска (N×N)** – Модел на пространство за търсене, където всеки ферз трябва да бъде поставен в уникална позиция без конфликти.
- **Диагонални атаки** – Специфично ограничение, което прави задачата по-сложна, тъй като ферзовете могат да се атакуват по диагонал, не само по редове и колони.

## 4. Step-by-step Learning Path
1. **Разбиране на правилата на N_Queens**
   - Фокус: Запознайте се с ограниченията на задачата.
   - Задача: Нарисувайте 4×4 дъска и опитайте ръчно да поставите 4 ферза без конфликти.
   - Въпроси: Какви са основните ограничения? Защо не могат да са два ферза в един ред?

2. **Имплементиране на базов backtracking алгоритъм**
   - Фокус: Научете как да използвате рекурсия за търсене на решения.
   - Задача: Напишете функция, която поставя ферзове ред по ред, връщайки се назад при конфликт.
   - Въпроси: Как backtracking помага да се избегне излишното търсене? Какво означава „връщане назад“?

3. **Оптимизация чрез проверка на ограничения**
   - Фокус: Намалете времето за проверка на валидност на позициите.
   - Задача: Добавете структури от данни (напр. масиви за колони и диагонали), които бързо да проверяват дали позицията е безопасна.
   - Въпроси: Какви структури използвахте? Как това подобрява ефективността?

4. **Разширяване към по-големи N и анализ на сложността**
   - Фокус: Разберете как расте сложността с увеличаване на N.
   - Задача: Изпълнете алгоритъма за N=8 и N=12, измерете време и брой решения.
   - Въпроси: Как се променя броят на решенията? Какви са ограниченията на backtracking при големи N?

5. **Прилагане на N_Queens в реални системи**
   - Фокус: Свържете теорията с практиката в AI и софтуерното инженерство.
   - Задача: Проектирайте малък модул, който използва N_Queens за демонстрация на CSP решаване.
   - Въпроси: Как бихте използвали този модул в по-голяма система? Какви други проблеми могат да се моделират по подобен начин?

## 5. Examples

### Пример 1: Решаване на 4_Queens с backtracking (Python)
```python
def is_safe(board, row, col):
    for i in range(row):
        if board[i] == col or \
           board[i] - i == col - row or \
           board[i] + i == col + row:
            return False
    return True

def solve_n_queens(n, row=0, board=[]):
    if row == n:
        print(board)
        return
    for col in range(n):
        if is_safe(board, row, col):
            solve_n_queens(n, row + 1, board + [col])

solve_n_queens(4)
```

### Пример 2: Използване на булеви масиви за оптимизация
```python
def solve_n_queens_optimized(n):
    cols = [False] * n
    diag1 = [False] * (2*n - 1)
    diag2 = [False] * (2*n - 1)
    board = []

    def backtrack(row):
        if row == n:
            print(board)
            return
        for col in range(n):
            if not cols[col] and not diag1[row + col] and not diag2[row - col + n - 1]:
                cols[col] = diag1[row + col] = diag2[row - col + n - 1] = True
                board.append(col)
                backtrack(row + 1)
                board.pop()
                cols[col] = diag1[row + col] = diag2[row - col + n - 1] = False

    backtrack(0)

solve_n_queens_optimized(4)
```

## 6. Common Pitfalls
- **Проверка само на редове и колони, без диагонали** – Това води до неправилни решения, защото ферзовете могат да атакуват по диагонал.
- **Използване на неподходящи структури за проверка на безопасност** – Например, проверка на цялата дъска при всяка стъпка е неефективна.
- **Липса на backtracking при конфликт** – Ако не се връщате назад при безизходица, алгоритъмът няма да намери решения.
- **Неправилно индексиране на диагоналите** – Диагоналите трябва да се адресират внимателно, за да не се допускат грешки.
- **Опит за решаване на големи N без оптимизации** – Това води до експоненциално време на изпълнение и невъзможност за завършване.

## 7. Short Retrieval Quiz
1. Какво представлява backtracking и как се използва в N_Queens?
2. Кои са трите основни ограничения при разполагането на ферзове?
3. Какво е CSP и защо N_Queens е пример за такъв проблем?
4. Какви структури от данни могат да оптимизират проверката за безопасност?
5. Какво означава „връщане назад“ в контекста на алгоритъма?
6. Защо е важно да проверяваме диагоналите, а не само редовете и колоните?
7. Как се променя сложността на задачата с увеличаване на N?

## 8. Quick Recap
- N_Queens е класически CSP, който изисква разполагане на N ферзове без взаимни атаки.
- Backtracking е основният метод за решаване, използващ рекурсия и връщане назад при конфликти.
- Проверка на ограничения включва редове, колони и диагонали.
- Оптимизациите с булеви масиви значително ускоряват алгоритъма.
- Задачата илюстрира важни концепции в AI и софтуерното инженерство като търсене с ограничения.
- Неправилната проверка или липсата на backtracking водят до грешки или неефективност.
- Разбирането на N_Queens помага за решаване на по-сложни комбинаторни и оптимизационни задачи.

## 9. Spaced Review Plan

| Време след учене | Промпт за преглед                                      |
|------------------|-------------------------------------------------------|
| 1 ден            | Обяснете как работи backtracking в N_Queens.          |
| 3 дни            | Избройте основните ограничения при разполагане на ферзове. |
| 1 седмица        | Опишете как оптимизациите с булеви масиви подобряват алгоритъма. |
| 1 месец          | Свържете N_Queens с други CSP и приложението им в AI. |