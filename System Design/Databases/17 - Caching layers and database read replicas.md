# 17 - Caching layers and database read replicas

## 1. Activate Prior Knowledge

- Какви проблеми могат да възникнат, когато множество потребители или AI системи правят едновременно заявки към една и съща база данни?
- Как бихте ускорили достъпа до често използвани данни в голямо уеб приложение или AI платформа?
- Кога е по-добре да използваме копие на база данни вместо основната база данни за четене на информация?

## 2. Overview

В съвременните софтуерни и AI системи, бързият и надежден достъп до данни е критично важен. Когато много потребители или процеси изпращат заявки към една база данни, това може да доведе до забавяния, претоварване и дори до сривове на системата. За да се справим с тези предизвикателства, често използваме кеширащи слоеве и реплики за четене на бази данни.

Кеширането представлява съхраняване на често използвани данни в бърза памет (RAM), така че бъдещи заявки да се обслужват мигновено, без да се достига до по-бавната основна база данни. Това значително намалява латентността и натоварването на бекенд системите.

Репликите за четене са копия на основната база данни, които се използват само за заявки за четене. Те позволяват разпределяне на натоварването и увеличават капацитета на системата да обслужва множество заявки едновременно, без да се компрометира целостта на данните при запис.

Тези техники са фундаментални за изграждане на мащабируеми, устойчиви и високопроизводителни системи, особено когато работим с големи обеми данни или AI приложения, които изискват бърз достъп до информация.

## 3. Key Concepts

- Cache (Кеш) – Бърза временна памет, в която се съхраняват често използвани данни за по-бърз достъп. Аналогия: като да държите най-често използваните инструменти на бюрото си, вместо в шкафа.
- Cache Invalidation (Инвалидация на кеш) – Процесът на премахване или обновяване на остарели данни в кеша, за да се гарантира точност.
- Read Replica (Реплика за четене) – Копие на база данни, което се използва само за заявки за четене, без да се извършват промени в него.
- Consistency (Консистентност) – Степента, до която данните в кеша или репликите съвпадат с основната база данни.
- Latency (Латентност) – Времето, необходимо за обслужване на заявка; кеширането и репликите намаляват латентността.
- Write/Read Split (Разделяне на четене/запис) – Практика за насочване на заявки за запис към основната база, а заявки за четене – към репликите.
- Cache Miss/Hit (Промахване/Уцелване на кеша) – Когато заявка намери (hit) или не намери (miss) данните в кеша.

## 4. Step-by-step Learning Path

1. **Разберете нуждата от кеширане и реплики**
   - Фокус: Защо са нужни кеш и реплики в реални системи.
   - Задача: Опишете сценарий, в който базата данни се претоварва от много заявки.
   - Въпроси: Кога натоварването на база данни става критично? Какви са последствията?

2. **Изучете основите на кеширането**
   - Фокус: Как работи кешът, какви типове има (in-memory, distributed).
   - Задача: Инсталирайте Redis или Memcached локално и съхранете/извлечете проста стойност.
   - Въпроси: Какво е cache hit? Какво се случва при cache miss?

3. **Разберете кеш инвалидацията**
   - Фокус: Как се обновяват или изтриват остарели данни в кеша.
   - Задача: Реализирайте TTL (time-to-live) за кеширана стойност в Redis.
   - Въпроси: Какви рискове има при остарял кеш? Как се решават?

4. **Научете за репликите за четене**
   - Фокус: Как се създават и използват read replicas.
   - Задача: Конфигурирайте read replica в MySQL или PostgreSQL (може и с docker).
   - Въпроси: Какви заявки се насочват към репликите? Как се постига консистентност?

5. **Практикувайте разделяне на четене и запис**
   - Фокус: Имплементиране на логика, която насочва заявки за четене към реплика, а за запис – към основната база.
   - Задача: Напишете малък скрипт, който изпраща SELECT към реплика и INSERT към master.
   - Въпроси: Какви са предимствата на този подход? Какви са потенциалните рискове?

## 5. Examples

### Пример 1: Кеширане на резултати от скъпа AI inference операция

```python
import redis

cache = redis.Redis(host='localhost', port=6379, db=0)

def expensive_ai_inference(input_data):
    # Скъпа AI операция
    return "result"

def get_inference(input_data):
    cached = cache.get(input_data)
    if cached:
        return cached.decode()
    result = expensive_ai_inference(input_data)
    cache.set(input_data, result, ex=3600)  # Кеширане за 1 час
    return result
```

### Пример 2: Използване на read replica в Django

```python
# settings.py
DATABASES = {
    'default': {...},  # Master
    'replica': {...},  # Read replica
}

# routers.py
class ReadReplicaRouter:
    def db_for_read(self, model, **hints):
        return 'replica'
    def db_for_write(self, model, **hints):
        return 'default'
```

### Пример 3: Кеширане на резултати от SQL заявка

```python
def get_user_profile(user_id):
    cache_key = f"user_profile:{user_id}"
    profile = cache.get(cache_key)
    if profile:
        return profile
    profile = db.query("SELECT * FROM users WHERE id = %s", user_id)
    cache.set(cache_key, profile, ex=600)  # Кеширане за 10 минути
    return profile
```

## 6. Common Pitfalls

- **Използване на остарял кеш** – Ако не се обновява кешът при промяна на данните, може да се върнат грешни резултати. Решение: използвайте подходяща инвалидация или TTL.
- **Прекалено агресивно кеширане** – Кеширането на твърде много или неподходящи данни може да изчерпи паметта. Решение: кеширайте само често използвани и скъпи за изчисление данни.
- **Лоша консистентност между master и read replica** – Забавяне при синхронизация може да доведе до четене на стари данни. Решение: настройте подходящи политики за репликация и информирайте потребителите за евентуални закъснения.
- **Насочване на заявки за запис към реплика** – Това може да доведе до загуба на данни. Решение: винаги насочвайте заявки за запис към основната база.

## 7. Short Retrieval Quiz

1. Каква е основната цел на кеширането в софтуерните системи?
2. Какво е read replica и за какво се използва?
3. Какво означава cache miss?
4. Какви са рисковете при използване на остарял кеш?
5. Какво представлява разделянето на четене и запис?
6. Какви са предимствата на използването на read replicas?
7. Как се избягва претоварване на кеша?

## 8. Quick Recap

- Кеширането ускорява достъпа до често използвани данни и намалява натоварването на базата данни.
- Репликите за четене позволяват обслужване на повече заявки без да се натоварва основната база.
- Инвалидацията на кеша е критична за точността на данните.
- Разделянето на четене и запис увеличава мащабируемостта и устойчивостта на системата.
- Кешът и репликите трябва да се използват внимателно, за да се избегнат проблеми с консистентността.
- Типични инструменти за кеширане са Redis и Memcached.
- Репликите за четене често се използват в големи уеб и AI системи.

## 9. Spaced Review Plan

| Време      | Преговори/Въпроси                                      |
|------------|--------------------------------------------------------|
| 1 ден      | Обяснете разликата между кеш и read replica.           |
| 3 дни      | Дайте пример за cache invalidation и read/write split. |
| 1 седмица  | Опишете сценарий с проблеми при консистентност.        |
| 1 месец    | Избройте предимствата и рисковете на кеширането.       |