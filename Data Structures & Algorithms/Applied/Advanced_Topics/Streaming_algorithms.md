# Streaming_algorithms

## 1. Activate Prior Knowledge

- Какви са основните предизвикателства при обработката на големи обеми данни в реално време?
- Как бихте оптимизирали алгоритъм, който трябва да работи с ограничена памет и да обработва непрекъснат поток от данни?
- В какви ситуации в AI системи или софтуерно инженерство бихте предпочели да използвате алгоритми за стрийминг пред класически алгоритми за обработка на данни?

## 2. Overview

Streaming алгоритмите са специализирани методи за обработка на данни, които пристигат като непрекъснат поток (stream) и обикновено са твърде големи, за да бъдат съхранени изцяло в паметта. Тези алгоритми позволяват извличане на важна статистическа информация или моделиране на данните в реално време, като използват ограничени ресурси.

В контекста на AI и софтуерното инженерство, streaming алгоритмите са критични за системи, които трябва да реагират бързо на нова информация, като препоръчителни системи, мониторинг на мрежов трафик, обработка на сензорни данни и анализ на социални медии. Те се вписват в по-широкия контекст на обработка на големи данни (Big Data) и real-time analytics.

Тези алгоритми са важни, защото позволяват ефективна обработка на данни, които иначе биха били непрактични за класически подходи, изискващи пълно съхранение и многократно преминаване през данните. Те често използват техники като приближения, хеширане и случайни проби, за да балансират между точност и ресурси.

## 3. Key Concepts

- **Data Stream** – Непрекъснат поток от данни, който пристига последователно и не може да бъде съхранен изцяло. Мислете за него като за река, която тече и не може да бъде спряна или върната назад.
- **One-pass Algorithm** – Алгоритъм, който обработва данните само веднъж, без възможност за повторно четене. Подобно на човек, който чете книга само веднъж и трябва да запомни най-важното.
- **Sketching** – Техника за създаване на компактно представяне (sketch) на големи данни, което позволява бързи приближени изчисления.
- **Approximation Algorithms** – Алгоритми, които дават приближени резултати с гарантирана грешка, вместо точни, за да спестят време и памет.
- **Sliding Window** – Модел, при който алгоритъмът обработва само последните N елемента от потока, като „прозорец“, който се движи напред.
- **Frequency Moments** – Статистики, които описват разпределението на честотите на елементите в потока, важни за задачи като откриване на често срещани елементи.
- **Count-Min Sketch** – Популярен streaming алгоритъм за приближено преброяване на честоти, използващ хеш функции и компактна структура.

## 4. Step-by-step Learning Path

1. **Основи на поточната обработка**
   - Фокус: Разберете какво представлява data stream и защо класическите алгоритми не са подходящи.
   - Задача: Напишете прост скрипт, който чете редове от файл един по един и изчислява средната стойност на числата.
   - Въпроси: Какви са ограниченията при обработка на потоци? Защо не можем да съхраним целия поток?

2. **Приближени алгоритми и sketching**
   - Фокус: Запознайте се с концепцията за приближение и основните техники за sketching.
   - Задача: Имплементирайте Count-Min Sketch за преброяване на честоти на елементи в поток.
   - Въпроси: Как Count-Min Sketch балансира между памет и точност? Какво е ролята на хеш функциите?

3. **Sliding Window модели**
   - Фокус: Научете как да обработвате само последните N елемента от потока.
   - Задача: Имплементирайте алгоритъм, който изчислява подвижна средна стойност за последните 100 елемента.
   - Въпроси: Какви са предимствата и ограниченията на sliding window подхода?

4. **Приложения в AI и софтуерно инженерство**
   - Фокус: Анализирайте реални случаи на използване на streaming алгоритми.
   - Задача: Проектирайте система за откриване на аномалии в мрежов трафик с помощта на streaming алгоритъм.
   - Въпроси: Как streaming алгоритмите подобряват реактивността на системите? Как се справят с шум и непълнота на данните?

## 5. Examples

### Пример 1: Count-Min Sketch на Python

```python
import numpy as np
import mmh3

class CountMinSketch:
    def __init__(self, width, depth):
        self.width = width
        self.depth = depth
        self.table = np.zeros((depth, width), dtype=int)
        self.seeds = np.random.randint(0, 10000, size=depth)

    def add(self, item):
        for i in range(self.depth):
            idx = mmh3.hash(item, self.seeds[i]) % self.width
            self.table[i][idx] += 1

    def estimate(self, item):
        min_count = float('inf')
        for i in range(self.depth):
            idx = mmh3.hash(item, self.seeds[i]) % self.width
            min_count = min(min_count, self.table[i][idx])
        return min_count

cms = CountMinSketch(width=1000, depth=5)
stream = ["apple", "banana", "apple", "orange", "banana", "apple"]
for fruit in stream:
    cms.add(fruit)

print("Estimate count for 'apple':", cms.estimate("apple"))
```

### Пример 2: Sliding window средна стойност

```python
from collections import deque

class SlidingWindowAverage:
    def __init__(self, size):
        self.size = size
        self.window = deque()
        self.sum = 0

    def add(self, value):
        self.window.append(value)
        self.sum += value
        if len(self.window) > self.size:
            self.sum -= self.window.popleft()

    def average(self):
        if not self.window:
            return 0
        return self.sum / len(self.window)

swa = SlidingWindowAverage(3)
for val in [1, 2, 3, 4, 5]:
    swa.add(val)
    print(f"Current average: {swa.average()}")
```

## 6. Common Pitfalls

- **Опит за съхранение на целия поток** – Често новаците се опитват да запазят всички данни, което е непрактично и води до изчерпване на паметта.
- **Недооценяване на грешката при приближени алгоритми** – Важно е да се разбере и контролира степента на приближение, за да не се вземат погрешни решения.
- **Неправилен избор на параметри (напр. размер на sketch)** – Твърде малки параметри водят до висока грешка, твърде големи – до излишна памет.
- **Игнориране на концепцията за drift (промяна на разпределението на данните)** – Потокът може да се променя с времето, което изисква адаптивни алгоритми.
- **Липса на тестване с реални потоци** – Теоретичните модели трябва да се валидират с реални данни и натоварвания.

## 7. Short Retrieval Quiz

1. Какво представлява streaming алгоритъм?
2. Защо класическите алгоритми не са подходящи за обработка на потоци?
3. Какво е Count-Min Sketch и за какво служи?
4. Какво означава „sliding window“ в контекста на streaming алгоритми?
5. Какви са основните предимства на приближените алгоритми?
6. Какво е основното ограничение при one-pass алгоритмите?
7. Защо е важно да се контролира грешката при приближени алгоритми?

## 8. Quick Recap

- Streaming алгоритмите обработват данни в реално време с ограничена памет.
- Те работят с еднократно преминаване през данните и използват приближения.
- Основни техники включват sketching, sliding windows и frequency moments.
- Count-Min Sketch е популярна структура за приближено преброяване на честоти.
- Приближенията балансират между точност и ресурсна ефективност.
- Правилният избор на параметри и адаптация към промени в потока са ключови.
- Те намират широко приложение в AI и системи за анализ на големи данни.

## 9. Spaced Review Plan

| Време след изучаване | Прегледен въпрос                                 |
|----------------------|-------------------------------------------------|
| 1 ден                | Какво е streaming алгоритъм и защо е нужен?    |
| 3 дни                | Обяснете принципа на Count-Min Sketch.          |
| 1 седмица            | Как работи sliding window и кога се използва?  |
| 1 месец              | Кои са основните предизвикателства при streaming алгоритмите? |