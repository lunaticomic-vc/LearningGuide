# DFS_and_BFS_traversals

## 1. Activate Prior Knowledge

- Какво представлява граф и какви видове графове сте срещали досега?
- Как бихте описали процеса на търсене или обхождане в структура от данни като дърво или граф?
- Защо в системи за изкуствен интелект или софтуерно инженерство е важно да изследваме всички възли или състояния в граф?

## 2. Overview

Обхождането на графове чрез алгоритмите DFS (Depth-First Search) и BFS (Breadth-First Search) е фундаментална техника в компютърните науки и изкуствения интелект. Тези алгоритми позволяват систематично изследване на всички възли в граф, което е критично за задачи като намиране на пътища, проверка на свързаност, анализ на мрежи и решаване на проблеми с дървета на състояния.

DFS се фокусира върху изследване на възлите в дълбочина, като следва един път докрай преди да се върне назад. Това го прави подходящ за задачи, където искаме да изследваме възможни решения или пътища в дълбочина, например при търсене на решения в игри или при анализ на структури с много разклонения.

BFS, от друга страна, обхожда графа ниво по ниво, което гарантира намиране на най-краткия път в граф с равни тежести. Това е от ключово значение в приложения като маршрутизация, планиране на път и анализ на социални мрежи.

Разбирането на тези два подхода и тяхното правилно прилагане е основа за ефективно решаване на сложни проблеми в софтуерното инженерство и изкуствения интелект.

## 3. Key Concepts

- **Graph (Граф)** – Структура от възли (върхове) и ребра, които ги свързват. Може да бъде насочен или ненасочен, с тежести или без.
- **Vertex (Връх)** – Елемент от графа, който може да представлява състояние, обект или точка.
- **Edge (Ребро)** – Връзка между два върха, която може да бъде насочена (от един връх към друг) или ненасочена.
- **DFS (Depth-First Search)** – Алгоритъм за обхождане, който изследва възлите в дълбочина, като се движи по един път докрай преди да се върне назад.
- **BFS (Breadth-First Search)** – Алгоритъм за обхождане, който изследва всички възли на едно ниво преди да премине към следващото.
- **Stack (Стек)** – Данна структура, използвана в DFS за проследяване на върховете, които трябва да се посетят.
- **Queue (Опашка)** – Данна структура, използвана в BFS за съхранение на върховете, които предстои да се посетят.
- **Visited Set (Множество посетени)** – Колекция, която пази информация за вече посетените върхове, за да се избегне безкрайно обхождане.
- **Shortest Path (Най-кратък път)** – Път с минимален брой ребра между два върха в граф без тежести, често намиран чрез BFS.

## 4. Step-by-step Learning Path

1. **Запознайте се с основите на графовете**
   - Фокус: Разберете какво представлява граф, видове графове и тяхната структура.
   - Задача: Нарисувайте прост ненасочен граф с поне 5 върха и 6 ребра.
   - Въпроси: Какво е разликата между насочен и ненасочен граф? Какво представлява степента на връх?

2. **Изучете принципите на DFS**
   - Фокус: Разберете как работи DFS, използвайки стек и рекурсия.
   - Задача: Имплементирайте DFS за даден граф и изведете реда на посещение на върховете.
   - Въпроси: Как стекът помага на DFS? Какво се случва, ако не пазим посетените върхове?

3. **Изучете принципите на BFS**
   - Фокус: Разберете как BFS използва опашка за обхождане на графа ниво по ниво.
   - Задача: Имплементирайте BFS и намерете най-краткия път между два върха в ненасочен граф.
   - Въпроси: Защо BFS гарантира най-краткия път? Какво е значението на опашката в BFS?

4. **Сравнете DFS и BFS в реални задачи**
   - Фокус: Анализирайте кога да използвате DFS и кога BFS, в зависимост от задачата.
   - Задача: Изберете задача (напр. проверка за свързаност, намиране на цикъл) и решете с двата алгоритъма.
   - Въпроси: Кои задачи са по-подходящи за DFS? Кога BFS е по-ефективен?

5. **Оптимизирайте и разширете алгоритмите**
   - Фокус: Научете техники за оптимизация, като използване на масиви за посетени, ранно прекъсване и работа с тежести.
   - Задача: Модифицирайте BFS да работи с тежести (например, използвайте приоритетна опашка).
   - Въпроси: Какво е ограничението на стандартния BFS при тежести? Как може да се подобри?

## 5. Examples

### Пример 1: DFS обхождане на граф

```python
def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    print(start)
    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
            
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}

dfs(graph, 'A')
```

### Пример 2: BFS намиране на най-кратък път

```python
from collections import deque

def bfs_shortest_path(graph, start, goal):
    queue = deque([(start, [start])])
    visited = set([start])
    while queue:
        vertex, path = queue.popleft()
        if vertex == goal:
            return path
        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))
    return None

graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}

print(bfs_shortest_path(graph, 'A', 'F'))
```

### Пример 3: Проверка за цикъл с DFS

```python
def has_cycle(graph):
    visited = set()
    rec_stack = set()

    def dfs(v):
        visited.add(v)
        rec_stack.add(v)
        for neighbor in graph[v]:
            if neighbor not in visited:
                if dfs(neighbor):
                    return True
            elif neighbor in rec_stack:
                return True
        rec_stack.remove(v)
        return False

    for node in graph:
        if node not in visited:
            if dfs(node):
                return True
    return False

graph = {
    'A': ['B'],
    'B': ['C'],
    'C': ['A'],  # цикъл A -> B -> C -> A
    'D': []
}

print(has_cycle(graph))  # True
```

## 6. Common Pitfalls

- **Пропускане на множество посетени върхове** – Води до безкрайни цикли и преповтарящо се обхождане.
- **Използване на стек вместо опашка при BFS (или обратното)** – Нарушава логиката на алгоритъма и води до неправилни резултати.
- **Неправилно обработване на насочени графове** – Забравяне, че ребрата имат посока, което променя пътеките.
- **Игнориране на тежести в графа при търсене на най-кратък път** – BFS не работи правилно при тежести, за които трябва да се използват други алгоритми (напр. Dijkstra).
- **Липса на проверка за съществуване на връзки (съседни върхове)** – Води до грешки при обхождане на непълни или динамични графове.

## 7. Short Retrieval Quiz

1. Каква е основната разлика между DFS и BFS?
2. Каква структура от данни използва DFS за проследяване на върховете?
3. Кога BFS гарантира намиране на най-кратък път?
4. Защо е важно да пазим множество посетени върхове?
5. Как бихте проверили дали граф съдържа цикъл с помощта на DFS?
6. Какво се случва, ако при BFS използваме стек вместо опашка?
7. Какъв тип графове изискват модификации на стандартния BFS алгоритъм?

## 8. Quick Recap

- DFS и BFS са основни алгоритми за обхождане на графове с различни стратегии: дълбочина срещу ширина.
- DFS използва стек или рекурсия, докато BFS използва опашка.
- BFS намира най-краткия път в граф без тежести, докато DFS е полезен за задачи като намиране на цикли и изследване на всички пътища.
- Важно е да пазим множество посетени върхове, за да избегнем безкрайни цикли.
- Изборът между DFS и BFS зависи от конкретната задача и структурата на графа.
- При тежести в графа стандартният BFS не е подходящ и трябва да се използват други алгоритми.
- Разбирането и правилното прилагане на тези алгоритми е ключово за ефективно решаване на проблеми в AI и софтуерното инженерство.

## 9. Spaced Review Plan

| Време след учене | Промпт за преглед                                    |
|-------------------|-----------------------------------------------------|
| 1 ден             | Обяснете разликите между DFS и BFS с примери.       |
| 3 дни             | Имплементирайте DFS и BFS за прост граф на хартия.  |
| 1 седмица         | Решете задача за намиране на цикъл с DFS.            |
| 1 месец           | Сравнете приложението на DFS и BFS в реален проект. |