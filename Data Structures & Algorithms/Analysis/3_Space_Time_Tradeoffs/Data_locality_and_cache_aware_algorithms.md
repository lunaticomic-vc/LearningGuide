# Data_locality_and_cache_aware_algorithms

## 1. Activate Prior Knowledge

- Какво знаете за йерархията на паметта в компютърните системи и защо достъпът до различни нива има различна скорост?
- Как мислите, че ефективното използване на кеш паметта може да подобри производителността на алгоритмите, особено в контекста на големи данни и AI модели?
- Можете ли да си представите как лошата локалност на данни може да забави изпълнението на софтуер, който обработва големи масиви от информация?

## 2. Overview

Data locality и cache-aware алгоритмите са ключови понятия в оптимизацията на производителността на съвременните компютърни системи. Те се фокусират върху максималното използване на кеш паметта, която е много по-бърза от основната оперативна памет, но с ограничен капацитет. Целта е да се организират данните и достъпът до тях така, че да се минимализират забавянията, причинени от чести достъпи до бавната памет.

В по-широк контекст, тези техники са особено важни в системи за изкуствен интелект и софтуерно инженерство, където обработката на големи обеми данни и сложни изчисления е ежедневие. Добрата локалност на данни позволява на алгоритмите да работят по-бързо и по-ефективно, като намалява времето за чакане и увеличава пропускателната способност на системата.

Cache-aware алгоритмите не само подобряват производителността, но и намаляват консумацията на енергия, което е критично в мобилни и вградени системи. Те са мост между хардуерните характеристики и софтуерната логика, което ги прави фундаментални за всеки, който иска да създава високопроизводителен и устойчив софтуер.

## 3. Key Concepts

- **Data locality** – концепция, която описва колко близо по време и пространство са достъпите до данни. Има два вида: пространствена (достъп до съседни адреси) и временна (повторен достъп до същите данни).
- **Cache memory** – малка, бърза памет, разположена близо до процесора, която съхранява копия на често използвани данни, за да ускори достъпа.
- **Cache miss** – събитие, при което процесорът не намира нужните данни в кеша и трябва да ги зареди от по-бавна памет, което забавя изпълнението.
- **Cache line/block** – минималната единица данни, която кешът зарежда наведнъж, обикновено няколко десетки байта; добрата локалност означава ефективно използване на кеш линиите.
- **Cache-aware algorithm** – алгоритъм, който е проектиран с оглед на кеш архитектурата, оптимизирайки достъпа до паметта и минимизирайки кеш пропуските.
- **Blocking (tiling)** – техника за разделяне на големи масиви или матрици на по-малки блокове, които се побират в кеша, за да се подобри локалността.
- **Prefetching** – предварително зареждане на данни в кеша преди те да са нужни, с цел намаляване на забавянията.

## 4. Step-by-step Learning Path

1. **Разберете основите на паметната йерархия**
   - Фокус: Как работят регистрите, кеш паметта, RAM и дисковете.
   - Задача: Изследвайте с помощта на инструменти като `perf` или `cachegrind` кеш статистики на проста програма.
   - Въпроси: Какво е кеш miss? Какво е кеш hit?

2. **Изучете видовете локалност на данни**
   - Фокус: Временна и пространствена локалност.
   - Задача: Напишете програма, която достъпва масив по различни начини (редове срещу колони) и измерете времето за изпълнение.
   - Въпроси: Как достъпът по редове влияе на кеша? Защо?

3. **Проучете техники за кеш-осъзнати алгоритми**
   - Фокус: Blocking, tiling и prefetching.
   - Задача: Имплементирайте умножение на матрици с и без blocking и сравнете производителността.
   - Въпроси: Как blocking подобрява кеш локалността? Какво се случва при големи матрици?

4. **Анализирайте реални алгоритми и библиотеки**
   - Фокус: Как съвременните библиотеки като BLAS използват кеш-осъзнати техники.
   - Задача: Прочетете документация или статии за оптимизации в BLAS и опитайте да профилирате изпълнението.
   - Въпроси: Какво прави BLAS по-добър от наивна имплементация? Как кеш локалността влияе?

5. **Прилагане в AI системи**
   - Фокус: Как кеш-осъзнатостта влияе върху производителността на невронни мрежи и обработка на големи данни.
   - Задача: Анализирайте и оптимизирайте част от код за обработка на тензори с оглед на кеш локалността.
   - Въпроси: Как кеш локалността влияе на тренировката на модели? Кои операции са най-чувствителни?

## 5. Examples

### Пример 1: Достъп до масив по редове и колони (C++)

```cpp
#include <iostream>
#include <chrono>

int main() {
    const int N = 1000;
    int matrix[N][N];

    // Инициализация
    for (int i = 0; i < N; ++i)
        for (int j = 0; j < N; ++j)
            matrix[i][j] = i + j;

    // Достъп по редове (добра локалност)
    auto start = std::chrono::high_resolution_clock::now();
    long long sum = 0;
    for (int i = 0; i < N; ++i)
        for (int j = 0; j < N; ++j)
            sum += matrix[i][j];
    auto end = std::chrono::high_resolution_clock::now();
    std::cout << "Row-wise sum time: " 
              << std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count() 
              << " ms\n";

    // Достъп по колони (лоша локалност)
    start = std::chrono::high_resolution_clock::now();
    sum = 0;
    for (int j = 0; j < N; ++j)
        for (int i = 0; i < N; ++i)
            sum += matrix[i][j];
    end = std::chrono::high_resolution_clock::now();
    std::cout << "Column-wise sum time: " 
              << std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count() 
              << " ms\n";

    return 0;
}
```

### Пример 2: Blocking за умножение на матрици (псевдокод)

```pseudo
block_size = 64
for i in 0 to N step block_size:
    for j in 0 to N step block_size:
        for k in 0 to N step block_size:
            for ii in i to min(i+block_size, N):
                for jj in j to min(j+block_size, N):
                    sum = 0
                    for kk in k to min(k+block_size, N):
                        sum += A[ii][kk] * B[kk][jj]
                    C[ii][jj] += sum
```

Този подход подобрява кеш локалността, като работи с по-малки блокове, които се побират в кеша.

## 6. Common Pitfalls

- **Игнориране на паметната йерархия** – писане на алгоритми без мисъл за кеша води до чести кеш пропуски и значително забавяне.
- **Лоша подредба на данните** – например, достъп до двумерен масив по колони в C/C++ (където е редово подреден) води до лоша пространствена локалност.
- **Прекалено малки или големи блокове при blocking** – твърде малките блокове не използват пълния потенциал на кеша, а твърде големите не се побират в кеша и причиняват пропуски.
- **Пренебрегване на prefetching** – не всички архитектури имат автоматично prefetching, а ръчното му използване може да подобри производителността.
- **Оптимизации без профилиране** – без измерване на кеш статистики и време, оптимизациите могат да са неефективни или дори да влошат ситуацията.

## 7. Short Retrieval Quiz

1. Какво представлява кеш miss и защо е важно да се минимизира?
2. Каква е разликата между временна и пространствена локалност?
3. Как blocking подобрява кеш локалността при умножение на матрици?
4. Защо достъпът до двумерен масив по редове е по-бърз от достъп по колони в C/C++?
5. Как prefetching може да подобри производителността на алгоритмите?
6. Какви са рисковете при използване на твърде големи блокове в кеш-осъзнати алгоритми?
7. Как кеш-осъзнатите алгоритми влияят на енергопотреблението?

## 8. Quick Recap

- Data locality означава достъп до данни, които са близо по време и място, което подобрява производителността.
- Cache-aware алгоритмите са проектирани да използват кеш паметта ефективно, минимизирайки кеш miss-овете.
- Blocking (tiling) е ключова техника за подобряване на кеш локалността при големи масиви и матрици.
- Лошата локалност на данни води до значителни забавяния и по-висока консумация на енергия.
- Профилирането и измерването са задължителни за ефективна оптимизация.
- Тези техники са критични в AI системи и софтуер с високи изчислителни изисквания.
- Разбирането на хардуерната архитектура е основа за писане на високопроизводителен софтуер.

## 9. Spaced Review Plan

| Време       | Промпт за преглед                                               |
|-------------|----------------------------------------------------------------|
| 1 ден       | Обяснете с прости думи какво е data locality и защо е важно.  |
| 3 дни       | Опишете техниката blocking и как тя подобрява кеш локалността.|
| 1 седмица   | Прегледайте пример с достъп до масив по редове и колони.       |
| 1 месец     | Дискутирайте как кеш-осъзнатостта влияе на AI алгоритми.      |