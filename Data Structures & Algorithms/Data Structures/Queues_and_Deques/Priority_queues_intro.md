# Priority_queues_intro

## 1. Activate Prior Knowledge

- Какво представлява структурата от данни „опашка“ и как се различава от стек?
- В кои ситуации в софтуерното инженерство или изкуствения интелект бихте искали да обработвате елементи според тяхната важност, а не по реда на постъпване?
- Как бихте реализирали система за управление на задачи, където някои задачи имат по-висок приоритет и трябва да се изпълняват първи?

## 2. Overview

Приоритетната опашка е абстрактна структура от данни, която позволява съхранение на елементи с асоцииран приоритет и извличане на елемента с най-висок (или най-нисък) приоритет. Тя е фундаментална за много алгоритми и системи, където не е достатъчно просто да се обработват елементите в реда на тяхното добавяне, а е необходимо да се вземат предвид важността или спешността им.

В контекста на изкуствения интелект и софтуерното инженерство, приоритетните опашки се използват например в алгоритми за търсене (като A*), управление на задачи в операционни системи, симулации и обработка на събития. Те позволяват ефективно управление на ресурси и оптимално разпределение на изчислителни усилия.

Разбирането на приоритетните опашки е ключово за проектиране на системи с висока производителност и надеждност, където времето за реакция и правилният ред на обработка са критични.

## 3. Key Concepts

- **Priority Queue (Приоритетна опашка)** – структура от данни, която съхранява елементи с приоритет и позволява извличане на елемента с най-висок приоритет. Можете да си я представите като опашка, в която не всички чакат на опашката, а тези с най-важна задача се обслужват първи.
- **Heap (Купчина)** – често използвана имплементация на приоритетна опашка, която е дървовидна структура, поддържаща свойството, че всеки родител е с по-висок приоритет от децата си. Аналогия: купчина от книги, където най-важната книга винаги е на върха.
- **Insertion (Вмъкване)** – операция за добавяне на нов елемент с приоритет в приоритетната опашка.
- **Extract-Max / Extract-Min (Извличане на максимум/минимум)** – операция за премахване и връщане на елемента с най-висок или най-нисък приоритет.
- **Time Complexity (Времева сложност)** – приоритетните опашки позволяват операции като вмъкване и извличане за O(log n), което е значително по-ефективно от сортиране на всички елементи при всяка операция.

## 4. Step-by-step Learning Path

1. **Запознайте се с концепцията за приоритетна опашка**
   - Фокус: Разберете какво представлява приоритетната опашка и защо е нужна.
   - Задача: Напишете кратко описание на ситуация, в която приоритетна опашка е по-добра от обикновена опашка.
   - Въпроси: Какво е основното предимство на приоритетната опашка? В какви приложения е полезна?

2. **Изучете имплементацията чрез купчина (heap)**
   - Фокус: Разберете структурата на купчината и нейните свойства.
   - Задача: Нарисувайте примерна купчина с 7 елемента и покажете как се поддържа свойството на купчината.
   - Въпроси: Какво свойство трябва да се спазва в купчината? Как се намира максималният елемент?

3. **Практикувайте основните операции**
   - Фокус: Вмъкване и извличане на елементи в приоритетна опашка.
   - Задача: Имплементирайте функции за insert и extract в език по избор.
   - Въпроси: Каква е времевата сложност на insert и extract? Как се променя структурата след извличане?

4. **Приложете приоритетната опашка в реален алгоритъм**
   - Фокус: Използване на приоритетна опашка в алгоритъм за търсене (например A*).
   - Задача: Реализирайте опростена версия на алгоритъм A*, използвайки приоритетна опашка.
   - Въпроси: Защо приоритетната опашка е ключова за ефективността на A*? Как се определя приоритетът на елементите?

## 5. Examples

### Пример 1: Имплементация на приоритетна опашка с Python heapq

```python
import heapq

pq = []
heapq.heappush(pq, (2, "task low priority"))
heapq.heappush(pq, (1, "task high priority"))
heapq.heappush(pq, (3, "task lowest priority"))

while pq:
    priority, task = heapq.heappop(pq)
    print(f"Processing {task} with priority {priority}")
```

### Пример 2: Използване на приоритетна опашка в алгоритъм за намиране на най-кратък път (Dijkstra)

```python
import heapq

def dijkstra(graph, start):
    pq = []
    heapq.heappush(pq, (0, start))
    distances = {node: float('inf') for node in graph}
    distances[start] = 0

    while pq:
        current_distance, current_node = heapq.heappop(pq)
        if current_distance > distances[current_node]:
            continue
        for neighbor, weight in graph[current_node].items():
            distance = current_distance + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(pq, (distance, neighbor))
    return distances
```

## 6. Common Pitfalls

- **Неправилно поддържане на свойството на купчината** – при вмъкване или извличане, ако не се пренареди структурата правилно, приоритетната опашка губи коректност.
- **Използване на приоритетна опашка без подходящ приоритет** – ако приоритетите не са добре дефинирани, резултатите могат да са неочаквани.
- **Забравяне, че Python heapq е min-heap по подразбиране** – за max-heap трябва да се инвертират приоритетите.
- **Извличане на елементи без проверка за празна опашка** – води до runtime грешки.
- **Неоптимални операции с линейна сложност** – например сортиране на всички елементи при всяка операция вместо използване на heap.

## 7. Short Retrieval Quiz

1. Какво е основната разлика между обикновена опашка и приоритетна опашка?
2. Какво свойство трябва да има купчината, за да бъде валидна приоритетна опашка?
3. Каква е времевата сложност на операциите insert и extract в приоритетна опашка?
4. Защо приоритетните опашки са важни за алгоритъма A*?
5. Какво трябва да направите, ако искате да използвате max-heap с Python heapq?
6. Какво се случва, ако извлечете елемент от празна приоритетна опашка?
7. Какъв тип приоритетна опашка (min или max) използва Python библиотеката heapq по подразбиране?

## 8. Quick Recap

- Приоритетната опашка позволява извличане на елементи според тяхната важност, а не по ред на постъпване.
- Купчината е най-често използваната структура за ефективна имплементация на приоритетни опашки.
- Основните операции са вмъкване (insert) и извличане на елемента с най-висок приоритет (extract).
- Времевата сложност на тези операции е O(log n), което е много ефективно за големи набори от данни.
- Приоритетните опашки са критични за алгоритми като A* и Dijkstra, както и за управление на задачи и събития.
- В Python библиотеката heapq се използва min-heap по подразбиране.
- Често срещани грешки включват неправилно поддържане на структурата и объркване между min-heap и max-heap.

## 9. Spaced Review Plan

| Време       | Промпт за преглед                                    |
|-------------|-----------------------------------------------------|
| 1 ден       | Обяснете с прости думи какво е приоритетна опашка и защо е полезна. |
| 3 дни       | Опишете как работи купчината и как поддържа приоритетите. |
| 1 седмица   | Имплементирайте insert и extract операции в приоритетна опашка. |
| 1 месец     | Дайте пример за приложение на приоритетна опашка в реален алгоритъм. |