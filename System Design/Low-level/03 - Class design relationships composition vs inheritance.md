# 03 - Class design relationships composition vs inheritance

## 1. Activate Prior Knowledge

- Какви са основните начини за създаване на връзки между класове в обектно-ориентираното програмиране?
- Можете ли да си спомните пример, когато сте използвали наследяване (inheritance) или композиция (composition) в реален проект?
- Как бихте определили разликата между "е-един" (is-a) и "има-един" (has-a) отношения в дизайна на софтуерни системи, например при изграждане на AI компоненти?

## 2. Overview

В обектно-ориентираното програмиране (ООП) връзките между класовете са фундаментални за изграждането на гъвкави и поддържани системи. Двата основни подхода за структуриране на тези връзки са наследяването (inheritance) и композицията (composition). Изборът между тях влияе пряко върху повторната употреба на кода, разширяемостта и устойчивостта на бъдещи промени.

Наследяването позволява на един клас да наследи поведение и свойства от друг, което улеснява повторната употреба, но може да доведе до твърда и трудна за промяна йерархия. Композицията, от друга страна, изгражда сложни обекти чрез комбиниране на по-прости, което насърчава гъвкавост и по-лесна поддръжка.

В контекста на големи системи, като AI платформи или корпоративен софтуер, правилният избор между композиция и наследяване е ключов за минимизиране на техническия дълг и улесняване на бъдещи разширения.

## 3. Key Concepts

- Inheritance (наследяване) – Позволява на един клас (дъщерен) да наследи поведение и свойства от друг (родителски). Аналогия: семейно дърво, където децата наследяват черти от родителите си.
- Composition (композиция) – Създава сложни обекти чрез комбиниране на други обекти. Мислете за това като за строене на кола от различни части (двигател, гуми, волан).
- Is-a relationship – Отношение, при което един клас е специализация на друг (напр. "Куче е Животно").
- Has-a relationship – Отношение, при което един клас съдържа друг като част (напр. "Кола има Двигател").
- Tight coupling (силно свързване) – Когато класовете са твърде зависими един от друг, често поради неправилно използвано наследяване.
- Loose coupling (слабо свързване) – Когато класовете са независими и могат лесно да се променят или заменят, често чрез композиция.

## 4. Step-by-step Learning Path

1. **Разберете основите на наследяването**
   - Фокус: Как работи наследяването и кога е подходящо.
   - Задача: Създайте клас `Animal` и наследете от него клас `Dog`.
   - Въпрос: Какви свойства и методи наследява `Dog` от `Animal`? Кога е подходящо да използвате наследяване?

2. **Изследвайте композицията**
   - Фокус: Как се изграждат обекти чрез композиция.
   - Задача: Създайте клас `Engine` и клас `Car`, като `Car` съдържа обект от тип `Engine`.
   - Въпрос: Какви са предимствата на композицията пред наследяването в този пример?

3. **Сравнете двата подхода**
   - Фокус: Предимства и недостатъци на наследяване vs композиция.
   - Задача: Преработете пример от стъпка 1, така че да използва композиция вместо наследяване.
   - Въпрос: Как се променя гъвкавостта на кода? Какви промени са необходими при добавяне на нови функционалности?

4. **Приложете в реален контекст**
   - Фокус: Избор на подход при проектиране на модул за AI система (напр. обработка на данни).
   - Задача: Опишете с UML диаграма как бихте структурирали модул за обработка на изображения – чрез наследяване или композиция, и защо.
   - Въпрос: Как вашият избор ще повлияе на разширяемостта и поддръжката на системата?

## 5. Examples

### Пример 1: Наследяване

```python
class Animal:
    def speak(self):
        print("Some sound")

class Dog(Animal):
    def speak(self):
        print("Bark")

dog = Dog()
dog.speak()  # Изход: Bark
```

### Пример 2: Композиция

```python
class Engine:
    def start(self):
        print("Engine started")

class Car:
    def __init__(self, engine):
        self.engine = engine

    def start(self):
        self.engine.start()

engine = Engine()
car = Car(engine)
car.start()  # Изход: Engine started
```

### Пример 3: Грешен избор на наследяване

```python
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height

class Square(Rectangle):
    def __init__(self, size):
        super().__init__(size, size)
```
*Тук наследяването може да доведе до проблеми при промяна на ширината или височината поотделно.*

## 6. Common Pitfalls

- Използване на наследяване, когато композицията е по-подходяща – води до твърда йерархия и трудна поддръжка.
- Прекалено дълбоки йерархии – затрудняват разбирането и разширяването на кода.
- Нарушаване на принципа Liskov Substitution – дъщерният клас не може да замести родителския без странични ефекти.
- Прекалено слабо свързване без нужда – може да усложни кода без реална полза.
- Смесване на отговорности – един клас изпълнява прекалено много роли.

## 7. Short Retrieval Quiz

1. Каква е основната разлика между наследяване и композиция?
2. Кога е по-подходящо да използвате композиция вместо наследяване?
3. Какво означава "is-a" отношение? Дайте пример.
4. Какви са рисковете при твърде дълбоки йерархии на наследяване?
5. Как композицията подпомага слабото свързване между класовете?
6. Какво представлява принципът Liskov Substitution?
7. Дайте пример за грешно използване на наследяване.

## 8. Quick Recap

- Наследяването позволява повторна употреба на код чрез "is-a" отношения.
- Композицията изгражда обекти чрез "has-a" отношения и насърчава гъвкавост.
- Правилният избор между двата подхода зависи от контекста и дългосрочните цели.
- Композицията често води до по-слабо свързани и по-лесни за поддръжка системи.
- Дълбоките йерархии на наследяване могат да създадат проблеми при разширяване.
- Принципът Liskov Substitution е ключов за коректното използване на наследяване.
- Анализирайте внимателно изискванията, преди да изберете подход.

## 9. Spaced Review Plan

| Review Time | Prompt                                                                 |
|-------------|------------------------------------------------------------------------|
| 1 day       | Обяснете разликата между наследяване и композиция с пример.             |
| 3 days      | Кога композицията е по-подходяща от наследяването?                     |
| 1 week      | Дайте пример за проблем, възникнал от неправилно използвано наследяване.|
| 1 month     | Как изборът между композиция и наследяване влияе на поддръжката на системата? |