# Sudoku_solver

## 1. Activate Prior Knowledge

- Какво представлява Sudoku и какви са основните правила за решаването му?
- Какви алгоритми или техники познавате, които могат да се използват за решаване на логически пъзели?
- Как бихте интегрирали автоматизиран Sudoku solver в по-голяма система за интелигентни игри или образователен софтуер?

## 2. Overview

Sudoku solver е софтуерна система или алгоритъм, който автоматично решава Sudoku пъзели, следвайки правилата на играта. Той приема като вход частично попълнена 9x9 решетка и връща пълно решение, ако такова съществува. Целта е да се намери валидна конфигурация на цифри от 1 до 9, така че всяка цифра да се появява точно веднъж във всеки ред, колона и 3x3 подрешетка.

В контекста на изкуствения интелект и софтуерното инженерство, Sudoku solver е класически пример за проблем с ограничени условия (constraint satisfaction problem - CSP). Той демонстрира как алгоритми като backtracking, constraint propagation и heuristics могат да бъдат комбинирани за ефективно търсене в голямо пространство от възможности. Разбирането и изграждането на такъв solver развива умения за формализиране на задачи, оптимизация и прилагане на алгоритми за търсене.

Практическото значение на Sudoku solver е двойнствено: от една страна, той служи като учебен инструмент за разбиране на алгоритмични концепции и техники за решаване на CSP, а от друга – като компонент в по-сложни системи за игри, обучение или дори изследване на автоматично доказване на теореми и логически изводи.

## 3. Key Concepts

- **Sudoku puzzle** – 9x9 мрежа, разделена на девет 3x3 подрешетки, където целта е да се попълнят празните клетки с числа от 1 до 9, без повторения в редове, колони и подрешетки. Може да се разглежда като логическа игра с ограничения.
- **Constraint Satisfaction Problem (CSP)** – проблем, при който трябва да се намери стойност за всяка променлива, така че да се удовлетворят всички ограничения. Sudoku е класически пример за CSP.
- **Backtracking** – алгоритъм за търсене, който пробва възможни решения последователно и се връща назад (backtracks), ако срещне конфликт. Подобно на пробване на ключове един по един, докато не се намери правилният.
- **Constraint Propagation** – техника за намаляване на възможните стойности на променливите чрез прилагане на ограничения, преди или по време на търсенето. Аналогично на елиминиране на невъзможни опции в пъзел.
- **Heuristics** – правила или стратегии, които помагат да се избере следващата променлива или стойност за тестване, с цел ускоряване на решаването. Например, избор на клетка с най-малко възможни числа.
- **Uniqueness of solution** – свойство на Sudoku пъзела, че има точно едно валидно решение. Това е важно за валидността и интереса на пъзела.

## 4. Step-by-step Learning Path

1. **Запознаване с правилата на Sudoku и формализацията като CSP**  
   - Фокус: Разберете как Sudoku може да се моделира като проблем с променливи, домейни и ограничения.  
   - Задача: Опишете променливите, домейните и ограниченията за един Sudoku пъзел.  
   - Въпроси: Какви са променливите в Sudoku CSP? Какви ограничения трябва да се спазват?

2. **Имплементиране на базов backtracking алгоритъм**  
   - Фокус: Напишете прост solver, който пробва числа от 1 до 9 във всяка празна клетка и се връща назад при конфликт.  
   - Задача: Имплементирайте функция, която намира първата празна клетка и пробва числа.  
   - Въпроси: Как backtracking гарантира намиране на решение? Какво се случва при конфликт?

3. **Добавяне на constraint propagation (например forward checking)**  
   - Фокус: Намалете домейните на променливите, като елиминирате невъзможни стойности преди да пробвате.  
   - Задача: Имплементирайте forward checking, който след всяко поставяне на число обновява възможните стойности на съседните клетки.  
   - Въпроси: Как constraint propagation подобрява ефективността? Как се актуализират домейните?

4. **Въвеждане на heuristics за избор на променлива и стойност**  
   - Фокус: Използвайте стратегии като MRV (Minimum Remaining Values) и Least Constraining Value.  
   - Задача: Модифицирайте solver-а да избира клетката с най-малко възможни числа и да пробва стойности, които най-малко ограничават останалите.  
   - Въпроси: Какви са предимствата на MRV? Какво е Least Constraining Value?

5. **Тестване и оптимизация**  
   - Фокус: Тествайте solver-а с различни пъзели, включително такива с уникално решение и такива с множество решения.  
   - Задача: Напишете тестове, които проверяват коректността и времето за изпълнение.  
   - Въпроси: Как да проверим дали пъзелът има уникално решение? Какво влияе на времето за решаване?

## 5. Examples

### Пример 1: Проста имплементация на backtracking solver (Python)

```python
def is_valid(board, row, col, num):
    for i in range(9):
        if board[row][i] == num or board[i][col] == num:
            return False
    start_row, start_col = 3 * (row // 3), 3 * (col // 3)
    for i in range(start_row, start_row + 3):
        for j in range(start_col, start_col + 3):
            if board[i][j] == num:
                return False
    return True

def solve_sudoku(board):
    for row in range(9):
        for col in range(9):
            if board[row][col] == 0:
                for num in range(1, 10):
                    if is_valid(board, row, col, num):
                        board[row][col] = num
                        if solve_sudoku(board):
                            return True
                        board[row][col] = 0
                return False
    return True
```

### Пример 2: Използване на MRV heuristic (псевдокод)

```pseudo
function select_unassigned_variable(variables):
    return variable with the smallest domain size
```

### Пример 3: Constraint propagation чрез forward checking

След поставяне на число в клетка, премахнете тази стойност от домейните на всички съседни клетки в същия ред, колона и блок.

## 6. Common Pitfalls

- **Игнориране на constraint propagation** – води до експоненциално време за решаване, защото много невъзможни опции не се елиминират навреме.  
- **Неправилна проверка на валидност** – например пропускане на проверка в 3x3 блока, което води до грешни решения.  
- **Липса на heuristics** – без стратегии за избор на променлива и стойност, търсенето е неефективно и бавно.  
- **Необработване на случаи с множество решения** – solver-ът трябва да може да отчита дали пъзелът има едно или повече решения, особено при тестове.  
- **Модифициране на глобални структури без връщане назад (backtracking)** – води до неправилни състояния и грешки.

## 7. Short Retrieval Quiz

1. Какво представлява backtracking алгоритъмът в контекста на Sudoku solver?  
2. Какво е constraint propagation и как помага при решаването?  
3. Какво означава MRV heuristic?  
4. Защо е важно да проверяваме 3x3 блоковете при валидността на числата?  
5. Как може да се провери дали даден Sudoku пъзел има уникално решение?  
6. Какво се случва, ако solver не използва heuristics?  
7. Какви са основните ограничения в Sudoku?

## 8. Quick Recap

- Sudoku solver автоматично решава Sudoku пъзели чрез алгоритми за търсене и удовлетворяване на ограничения.  
- Sudoku е класически пример за Constraint Satisfaction Problem (CSP).  
- Backtracking е базов подход, който пробва възможни стойности и се връща назад при конфликт.  
- Constraint propagation намалява домейните на променливите и ускорява решаването.  
- Heuristics като MRV и Least Constraining Value подобряват ефективността на solver-а.  
- Важно е да се проверява валидността на всяка стъпка, включително редове, колони и 3x3 блокове.  
- Тестове за уникалност на решението са важна част от практическата имплементация.

## 9. Spaced Review Plan

| Време след учене | Промпт за преглед                                      |
|------------------|-------------------------------------------------------|
| 1 ден            | Обяснете как работи backtracking в Sudoku solver.     |
| 3 дни            | Опишете ролята на constraint propagation и MRV.      |
| 1 седмица        | Имплементирайте кратък код за проверка на валидност.  |
| 1 месец          | Сравнете различни подходи за решаване на Sudoku.      |