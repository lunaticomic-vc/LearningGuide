# Sieve_of_Eratosthenes

## 1. Activate Prior Knowledge
- Какво представляват простите числа и защо са важни в компютърните науки и криптографията?
- Как бихте намерили всички прости числа до дадено число без да проверявате всяко число поотделно?
- Как алгоритми за филтриране и елиминиране на елементи могат да се използват в оптимизацията на софтуерни системи?

## 2. Overview
Решето на Ератостен е класически алгоритъм за намиране на всички прости числа до дадено естествено число n. Той се основава на идеята за последователно премахване на кратни на всяко просто число, започвайки от 2. Това е един от най-ефективните начини за генериране на прости числа при сравнително малки граници.

В контекста на софтуерното инженерство и изкуствения интелект, решето може да се използва като предварителна стъпка за задачи, които изискват бърза проверка на простота или филтриране на данни. Например, при криптографски алгоритми, намирането на големи прости числа е фундаментално.

Алгоритъмът е прост за имплементация, но същевременно демонстрира важни концепции като оптимизация чрез елиминиране, използване на булеви масиви и сложност на алгоритми. Той е отличен пример за това как математическа идея може да бъде превърната в ефективен софтуерен инструмент.

## 3. Key Concepts
- **Прости числа** – числа, които имат точно два делителя: 1 и самото число. Мислете за тях като за "атомите" на числовата система.
- **Кратни** – числа, които се делят на дадено число без остатък. Например, кратните на 3 са 3, 6, 9 и т.н.
- **Булев масив (Boolean array)** – структура от данни, която съдържа само стойности true/false, използвана за маркиране на числа като прости или съставни.
- **Елиминация** – процес на премахване или маркиране на числа, които не отговарят на определени условия (тук – не са прости).
- **Сложност на алгоритъма** – мярка за времето или пространството, което алгоритъмът изисква, обикновено изразена като функция на входния размер n.

## 4. Step-by-step Learning Path
1. **Разберете дефиницията на прости числа**
   - Фокус: Какво е просто число и как да проверим простотата на едно число.
   - Задача: Напишете функция, която проверява дали едно число е просто чрез деление.
   - Въпроси: Какво е просто число? Защо не е ефективно да проверяваме простотата чрез деление за големи n?

2. **Запознайте се с основната идея на решето**
   - Фокус: Как се премахват кратните на всяко просто число.
   - Задача: Ръчно маркирайте кратните на 2 и 3 в списък от 1 до 30.
   - Въпроси: Какви числа остават след премахване на кратните на 2? Защо започваме от 2?

3. **Имплементирайте основния алгоритъм**
   - Фокус: Създаване на булев масив и маркиране на кратните.
   - Задача: Напишете програма на предпочитан език, която намира всички прости числа до 100.
   - Въпроси: Какво означава булевата стойност true/false в контекста на алгоритъма? Защо започваме маркирането от квадратa на текущото просто число?

4. **Оптимизирайте алгоритъма**
   - Фокус: Започване на маркирането от i² и спиране при √n.
   - Задача: Модифицирайте програмата да използва оптимизацията с √n.
   - Въпроси: Защо не е нужно да проверяваме числа над √n? Как това подобрява ефективността?

5. **Приложете алгоритъма в реален проект**
   - Фокус: Използване на решето за филтриране на данни или криптографски задачи.
   - Задача: Интегрирайте решето в малък проект, който генерира прости числа за криптографски ключове.
   - Въпроси: Какви са ограниченията на решето при много големи числа? Как бихте подобрили алгоритъма за такива случаи?

## 5. Examples

### Пример 1: Основна имплементация на Python
```python
def sieve_of_eratosthenes(n):
    primes = [True] * (n+1)
    primes[0], primes[1] = False, False
    p = 2
    while p * p <= n:
        if primes[p]:
            for i in range(p * p, n+1, p):
                primes[i] = False
        p += 1
    return [num for num, is_prime in enumerate(primes) if is_prime]

print(sieve_of_eratosthenes(30))
```

### Пример 2: Използване на решето за филтриране на простите числа в JavaScript
```javascript
function sieveOfEratosthenes(n) {
    let primes = new Array(n + 1).fill(true);
    primes[0] = primes[1] = false;
    for (let p = 2; p * p <= n; p++) {
        if (primes[p]) {
            for (let i = p * p; i <= n; i += p) {
                primes[i] = false;
            }
        }
    }
    return primes.reduce((acc, val, idx) => val ? acc.concat(idx) : acc, []);
}

console.log(sieveOfEratosthenes(50));
```

### Пример 3: Оптимизация чрез започване от p²
В горните примери маркирането започва от p², защото всички по-малки кратни вече са маркирани от по-малки прости числа.

## 6. Common Pitfalls
- **Започване на маркирането от 2p вместо p²** – води до излишна работа и намалява ефективността.
- **Забравяне да маркирате 0 и 1 като несъставни** – те не са прости числа.
- **Използване на неподходящ тип данни за булевия масив** – може да доведе до голямо потребление на памет.
- **Прекалено големи входни стойности без оптимизация** – алгоритъмът може да стане бавен или да изчерпи паметта.
- **Неправилно спиране на цикъла при p * p > n** – може да пропуснете някои прости числа.

## 7. Short Retrieval Quiz
1. Какво представлява просто число?
2. Защо започваме маркирането на кратни от p², а не от 2p?
3. Каква е времевата сложност на решето на Ератостен?
4. Кои числа не са прости и трябва да се изключат предварително?
5. Какво представлява булевият масив в контекста на този алгоритъм?
6. Какво се случва, ако не спрем цикъла при p * p > n?
7. Защо решето е по-ефективно от проверка на простотата чрез деление?

## 8. Quick Recap
- Решето на Ератостен е алгоритъм за намиране на всички прости числа до n чрез последователно премахване на кратни.
- Използва булев масив за маркиране на числа като прости или съставни.
- Маркирането започва от квадратa на текущото просто число (p²), защото по-малките кратни вече са маркирани.
- Цикълът спира при p * p > n, което оптимизира времето за изпълнение.
- Алгоритъмът има времева сложност около O(n log log n), което го прави много ефективен за средни по големина n.
- Числата 0 и 1 не са прости и трябва да се изключат предварително.
- Решето е основа за много по-сложни алгоритми в криптографията и числовите изчисления.

## 9. Spaced Review Plan

| Време след учене | Промпт за преглед                                |
|-------------------|-------------------------------------------------|
| 1 ден             | Обяснете основната идея на решето на Ератостен.|
| 3 дни             | Опишете защо маркирането започва от p².        |
| 1 седмица         | Имплементирайте решето на Ератостен на предпочитан език.|
| 1 месец           | Обсъдете приложенията и ограниченията на решето в криптографията и софтуерното инженерство.|