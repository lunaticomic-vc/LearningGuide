# Recursion_fundamentals_and_recurrence_relations

## 1. Activate Prior Knowledge

- Какво представлява рекурсията и какви примери от ежедневното програмиране познавате?
- Как бихте описали връзката между рекурсията и итерацията?
- Как мислите, че рекурсията може да бъде използвана за моделиране на алгоритми в изкуствения интелект или софтуерното инженерство?

## 2. Overview

Рекурсията е фундаментален метод в компютърните науки, при който функция се извиква сама в рамките на собственото си изпълнение. Тя позволява решаването на сложни проблеми чрез разбиването им на по-малки, подобни подпроблеми. Това е особено полезно при обработка на дървовидни структури, графи и при дефиниране на алгоритми с естествена рекурсивна структура.

В контекста на софтуерното инженерство и изкуствения интелект, рекурсията често служи за реализиране на алгоритми за търсене, оптимизация и динамично програмиране. Разбирането на рекурсията е ключово за ефективното моделиране на проблеми, които имат естествена иерархична или повторяемост.

Рекурсията е тясно свързана с рекурентните уравнения (recurrence relations), които описват времевата сложност или броя на операциите в рекурсивни алгоритми. Анализът на тези уравнения помага да се предвиди ефективността и да се оптимизират решенията.

## 3. Key Concepts

- **Recursion (Рекурсия)** – Метод, при който функция извиква сама себе си с по-прости входни данни, докато достигне базов случай. Може да се сравни с огледало, което се отразява безкрайно, но с условие да спре при определена точка.
- **Base Case (Базов случай)** – Условие, при което рекурсивната функция спира да се извиква и връща директен резултат. Това е „крайна точка“ в рекурсията, която предотвратява безкрайно изпълнение.
- **Recursive Case (Рекурсивен случай)** – Частта от функцията, която извиква сама себе си с по-прости или по-малки параметри, приближавайки се към базовия случай.
- **Recurrence Relation (Рекурентно уравнение)** – Математическо уравнение, което описва стойността на функцията чрез стойности на същата функция с по-малки аргументи. Използва се за анализ на времевата сложност на рекурсивни алгоритми.
- **Stack Frame (Стекова рамка)** – Мястото в паметта, където се съхраняват параметрите, локалните променливи и адресът на връщане за всяко рекурсивно извикване. Може да се визуализира като купчина книги, където всяка книга е едно извикване.
- **Tail Recursion (Опашкова рекурсия)** – Специален вид рекурсия, при която последната операция на функцията е рекурсивното извикване. Позволява оптимизация, при която не се натрупват допълнителни стекови рамки.

## 4. Step-by-step Learning Path

1. **Разберете основите на рекурсията**  
   - Фокус: Какво е рекурсия, базов и рекурсивен случай.  
   - Задача: Напишете рекурсивна функция за изчисляване на факториел на число.  
   - Въпроси: Какво е базовият случай във вашата функция? Защо е необходим?

2. **Изследвайте рекурентните уравнения**  
   - Фокус: Как се описва времевата сложност на рекурсивни алгоритми чрез рекурентни уравнения.  
   - Задача: Запишете рекурентното уравнение за времето на изпълнение на факториел функцията.  
   - Въпроси: Какво означава решението на рекурентното уравнение?

3. **Практикувайте с класически рекурсивни задачи**  
   - Фокус: Фибоначи, търсене в дърво, обхождане на граф.  
   - Задача: Имплементирайте рекурсивна функция за изчисляване на n-тото число от редицата на Фибоначи.  
   - Въпроси: Каква е времевата сложност? Може ли да се оптимизира?

4. **Оптимизация чрез мемоизация и динамично програмиране**  
   - Фокус: Избягване на повторни изчисления в рекурсията.  
   - Задача: Добавете мемоизация към Фибоначи функцията.  
   - Въпроси: Как мемоизацията променя времевата сложност?

5. **Изучете опашкова рекурсия и нейното значение**  
   - Фокус: Разликата между обикновена и опашкова рекурсия.  
   - Задача: Пренапишете факториел функцията като опашкова рекурсия.  
   - Въпроси: Какво е предимството на опашковата рекурсия?

## 5. Examples

### Пример 1: Факториел (рекурсивна дефиниция)

```python
def factorial(n):
    if n == 0:
        return 1  # базов случай
    else:
        return n * factorial(n - 1)  # рекурсивен случай
```

### Пример 2: Рекурентно уравнение за факториел

Времето за изчисление T(n) може да се опише като:

\[
T(n) = T(n-1) + O(1), \quad T(0) = O(1)
\]

Решението е \(T(n) = O(n)\).

### Пример 3: Фибоначи с мемоизация

```python
memo = {}
def fibonacci(n):
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    memo[n] = fibonacci(n-1) + fibonacci(n-2)
    return memo[n]
```

## 6. Common Pitfalls

- **Липса на базов случай** – води до безкрайна рекурсия и препълване на стека. Винаги дефинирайте и проверявайте базовия случай.
- **Повторно изчисляване на същите стойности** – особено при Фибоначи, без мемоизация времето расте експоненциално.
- **Неправилно дефиниране на рекурсивния случай** – може да доведе до грешни резултати или липса на напредък към базовия случай.
- **Прекалено дълбока рекурсия** – при големи входни данни може да се получи стеков overflow. Използвайте опашкова рекурсия или итеративни подходи.
- **Неоптимизирана рекурсия** – понякога итеративните решения са по-ефективни, особено при големи обеми данни.

## 7. Short Retrieval Quiz

1. Какво е базов случай в рекурсията и защо е важен?
2. Какво описва рекурентното уравнение?
3. Каква е основната разлика между обикновена и опашкова рекурсия?
4. Как мемоизацията подобрява рекурсивните алгоритми?
5. Какво може да се случи, ако рекурсивната функция няма базов случай?
6. Как се визуализира стекът при рекурсивни извиквания?
7. Каква е времевата сложност на рекурсивното изчисление на n-тото число от редицата на Фибоначи без мемоизация?

## 8. Quick Recap

- Рекурсията решава проблеми чрез разбиване на по-малки подпроблеми и извикване на функцията сама себе си.
- Базовият случай спира рекурсията и предотвратява безкрайни цикли.
- Рекурентните уравнения описват времевата сложност на рекурсивни алгоритми.
- Мемоизация и динамично програмиране оптимизират рекурсивни решения, избягвайки повторни изчисления.
- Опашковата рекурсия позволява оптимизация на използването на паметта.
- Липсата на базов случай или неправилна рекурсия водят до грешки и препълване на стека.
- Разбирането на рекурсията е ключово за сложни алгоритми в AI и софтуерното инженерство.

## 9. Spaced Review Plan

| Време след първоначално учене | Промпт за преглед                              |
|-------------------------------|------------------------------------------------|
| 1 ден                         | Опишете базов и рекурсивен случай с пример.   |
| 3 дни                         | Запишете и решете рекурентно уравнение за факториел. |
| 1 седмица                     | Имплементирайте функция за Фибоначи с мемоизация. |
| 1 месец                      | Обяснете предимствата на опашковата рекурсия и кога да се използва. |