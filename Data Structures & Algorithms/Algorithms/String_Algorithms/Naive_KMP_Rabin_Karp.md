# Naive_KMP_Rabin_Karp

## 1. Activate Prior Knowledge
- Какви са основните предизвикателства при търсене на поднизове в големи текстове или данни?
- Какви алгоритми за търсене на шаблони познавате и как те влияят на ефективността на софтуерни системи?
- Как бихте използвали алгоритми за търсене на шаблони в контекста на AI, например при обработка на естествен език или анализ на данни?

## 2. Overview
Търсенето на поднизове (string matching) е фундаментална задача в компютърните науки и софтуерното инженерство, особено важна за обработка на текст, биоинформатика, компилатори и системи за търсене. Алгоритмите Naive, KMP (Knuth-Morris-Pratt) и Rabin-Karp предлагат различни подходи за решаване на тази задача, като балансират между простота и ефективност.

Naive алгоритъмът е директен и интуитивен, но неефективен при големи данни. KMP използва предварителна обработка на шаблона, за да избегне ненужни сравнения, което го прави по-бърз в най-лошия случай. Rabin-Karp пък прилага хеширане, за да ускори търсенето, особено когато търсим множество шаблони.

Тези алгоритми са ключови за изграждането на ефективни системи за търсене и анализ, които са основа за много AI приложения като разпознаване на модели, текстова обработка и откриване на аномалии. Разбирането им дава възможност за оптимизиране на софтуер и подобряване на производителността.

## 3. Key Concepts
- **Naive String Matching** – Прост метод, който проверява всеки възможен стартов индекс в текста за съвпадение с шаблона. Модел: „пробвай и греши“.
- **Knuth-Morris-Pratt (KMP) Algorithm** – Алгоритъм, който използва предварително изчислен масив (lps - longest prefix suffix), за да избегне повторно сравняване на символи, които вече са проверени.
- **Longest Prefix Suffix (LPS) Array** – Масив, който за всяка позиция в шаблона показва дължината на най-дългия префикс, който също е суфикс, подпомагащ ефективното преместване на шаблона.
- **Rabin-Karp Algorithm** – Алгоритъм, който използва хеширане на поднизове за бързо откриване на потенциални съвпадения, като сравнява хеш стойности вместо символи.
- **Rolling Hash** – Техника за бързо изчисляване на хеш стойности на последователни поднизове чрез обновяване на хеша при преместване на прозореца.
- **Collision (в хеширането)** – Случай, когато различни поднизове имат еднаква хеш стойност, което изисква допълнителна проверка.

## 4. Step-by-step Learning Path
1. **Разберете Naive алгоритъма**
   - Фокус: Принцип на директно сравняване на символи.
   - Задача: Имплементирайте Naive алгоритъм за търсене на подниз в текст.
   - Въпроси: Какво е времевата сложност в най-лошия случай? Защо е неефективен при големи текстове?

2. **Изучете KMP алгоритъма и LPS масива**
   - Фокус: Изграждане и използване на LPS масива за оптимизация.
   - Задача: Напишете функция, която изчислява LPS масива за даден шаблон.
   - Въпроси: Как LPS масивът помага да се избегнат повторни сравнения? Какво означава стойността в LPS за дадена позиция?

3. **Имплементирайте KMP алгоритъма**
   - Фокус: Използване на LPS за ефективно търсене.
   - Задача: Комбинирайте LPS и търсенето в една функция.
   - Въпроси: Каква е времевата сложност на KMP? Какво се случва при несъвпадение?

4. **Разберете Rabin-Karp алгоритъма и концепцията за хеширане**
   - Фокус: Изчисляване на хеш стойности и rolling hash.
   - Задача: Имплементирайте функция за изчисляване на rolling hash.
   - Въпроси: Какво е предимството на хеширането? Как се справя алгоритъмът с колизии?

5. **Имплементирайте Rabin-Karp за търсене на подниз**
   - Фокус: Сравнение на хешове и проверка на реални съвпадения.
   - Задача: Напишете пълна реализация на Rabin-Karp.
   - Въпроси: В какви случаи Rabin-Karp е по-ефективен от Naive? Какво е влиянието на колизиите върху производителността?

## 5. Examples

### Naive Algorithm (Python)
```python
def naive_search(text, pattern):
    n, m = len(text), len(pattern)
    for i in range(n - m + 1):
        if text[i:i+m] == pattern:
            print(f"Pattern found at index {i}")
```

### KMP LPS Array Computation
```python
def compute_lps(pattern):
    lps = [0] * len(pattern)
    length = 0
    i = 1
    while i < len(pattern):
        if pattern[i] == pattern[length]:
            length += 1
            lps[i] = length
            i += 1
        else:
            if length != 0:
                length = lps[length - 1]
            else:
                lps[i] = 0
                i += 1
    return lps
```

### Rabin-Karp Rolling Hash (simplified)
```python
def rabin_karp(text, pattern, prime=101):
    n, m = len(text), len(pattern)
    base = 256
    hpattern = 0
    htext = 0
    h = 1
    for i in range(m-1):
        h = (h * base) % prime
    for i in range(m):
        hpattern = (base * hpattern + ord(pattern[i])) % prime
        htext = (base * htext + ord(text[i])) % prime
    for i in range(n - m + 1):
        if hpattern == htext:
            if text[i:i+m] == pattern:
                print(f"Pattern found at index {i}")
        if i < n - m:
            htext = (base * (htext - ord(text[i]) * h) + ord(text[i + m])) % prime
            if htext < 0:
                htext += prime
```

## 6. Common Pitfalls
- **Naive алгоритъм:** Пренебрегване на времевата сложност при големи текстове, което води до бавна работа.
- **KMP LPS масив:** Грешки при изчисляване на LPS, особено при обновяване на дължината на префикса, водещи до неправилно поведение.
- **Rabin-Karp:** Игнориране на колизиите при хеширане, което може да доведе до фалшиви положителни съвпадения.
- **Общи:** Забравяне за гранични случаи като празен шаблон или текст, или когато шаблонът е по-дълъг от текста.
- **Оптимизация:** Прекалено усложняване на имплементацията без нужда, което затруднява поддръжката.

## 7. Short Retrieval Quiz
1. Каква е основната идея зад Naive алгоритъма за търсене на подниз?
2. Какво представлява LPS масивът в KMP алгоритъма?
3. Как KMP алгоритъмът подобрява ефективността спрямо Naive?
4. Как Rabin-Karp използва хеширане за търсене на подниз?
5. Какво представлява rolling hash и защо е важен?
6. Как се справя Rabin-Karp с колизиите?
7. Кога Naive алгоритъмът може да бъде по-подходящ от KMP или Rabin-Karp?

## 8. Quick Recap
- Търсенето на подниз е ключова задача с приложения в AI и софтуер.
- Naive алгоритъмът е прост, но неефективен при големи данни.
- KMP използва LPS масив за избягване на излишни сравнения.
- Rabin-Karp прилага хеширане и rolling hash за бързо филтриране на кандидати.
- Колизиите в Rabin-Karp изискват допълнителна проверка.
- Правилната имплементация и разбиране на всеки алгоритъм е критична за ефективност.
- Изборът на алгоритъм зависи от конкретния контекст и размер на данните.

## 9. Spaced Review Plan

| Време след учене | Прегледна задача                                   |
|-------------------|---------------------------------------------------|
| 1 ден             | Обяснете с прости думи как работи KMP алгоритъмът.|
| 3 дни             | Имплементирайте LPS масив за нов шаблон.          |
| 1 седмица         | Сравнете Naive и Rabin-Karp по време на изпълнение.|
| 1 месец           | Опишете случаи, в които Rabin-Karp е по-добър от KMP. |