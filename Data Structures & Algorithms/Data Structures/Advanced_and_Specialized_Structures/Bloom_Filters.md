# Bloom_Filters

## 1. Activate Prior Knowledge
- Как бихте проверили дали даден елемент вече съществува в голям набор от данни, без да съхранявате всички елементи?
- Какви компромиси между точност и ефективност бихте направили при изграждането на система за бързо търсене?
- В контекста на AI или софтуерни системи, как бихте използвали структури от данни, които позволяват бързи проверки за принадлежност?

## 2. Overview
Bloom филтрите са вероятностни структури от данни, предназначени да проверяват дали даден елемент принадлежи към множество. Те са изключително ефективни по отношение на паметта и времето за търсене, като позволяват бързи проверки с малка вероятност за фалшиво положителни резултати, но без фалшиво отрицателни. Това ги прави подходящи за системи, където бързината и ресурсната ефективност са критични, например при филтриране на спам, кеширане или бази данни.

В по-широк контекст Bloom филтрите се използват като първична проверка преди скъпи операции, като достъп до дискови бази данни или мрежови заявки. Те помагат да се намали броят на ненужните операции, като по този начин оптимизират цялостната производителност на системата. Разбирането на техния принцип и ограничения е ключово за проектиране на ефективни и надеждни системи.

## 3. Key Concepts
- **Bloom Filter** – вероятностна структура от данни, която отговаря на въпроса „дали елементът е в множеството?“ с възможност за фалшиво положителен, но никога фалшиво отрицателен отговор.
- **Hash Functions** – множество независими функции, които преобразуват входните данни в индекси в битов масив; ключови за разпределението и точността на филтъра.
- **False Positive Rate** – вероятността Bloom филтърът да върне положителен резултат за елемент, който не е добавен.
- **Bit Array** – основната структура, в която се отбелязват позициите, зададени от хеш функциите; размерът му влияе на точността и капацитета.
- **Set Membership Testing** – процесът на проверка дали даден елемент е част от множеството, използвайки Bloom филтъра.
- **Trade-off between space and accuracy** – компромисът между размера на битовия масив и честотата на фалшивите положителни резултати.

## 4. Step-by-step Learning Path
1. **Фокус:** Основен принцип на Bloom филтъра  
   **Задача:** Прочетете и визуализирайте как се добавя елемент и как се проверява принадлежност.  
   **Въпроси:** Как Bloom филтърът гарантира, че няма фалшиво отрицателни? Какво означава фалшиво положително?

2. **Фокус:** Роля на хеш функциите  
   **Задача:** Имплементирайте 3 различни хеш функции и тествайте разпределението им върху битов масив.  
   **Въпроси:** Защо са необходими няколко хеш функции? Как влияе броят им на точността?

3. **Фокус:** Изчисляване на вероятността за фалшиво положителен резултат  
   **Задача:** Използвайте формулата за false positive rate и експериментирайте с различни размери на битовия масив и брой хеш функции.  
   **Въпроси:** Как размерът на битовия масив влияе на false positive rate? Какъв е оптималният брой хеш функции?

4. **Фокус:** Приложение в реални системи  
   **Задача:** Интегрирайте Bloom филтър в малък проект за кеширане на заявки и измерете подобрението в производителността.  
   **Въпроси:** Как Bloom филтърът намалява броя на ненужните операции? Кога не е подходящ за използване?

## 5. Examples
### Пример 1: Проверка на принадлежност в множество от думи
```python
from bitarray import bitarray
import mmh3

class BloomFilter:
    def __init__(self, size, hash_count):
        self.size = size
        self.hash_count = hash_count
        self.bit_array = bitarray(size)
        self.bit_array.setall(0)

    def add(self, item):
        for i in range(self.hash_count):
            digest = mmh3.hash(item, i) % self.size
            self.bit_array[digest] = 1

    def check(self, item):
        for i in range(self.hash_count):
            digest = mmh3.hash(item, i) % self.size
            if self.bit_array[digest] == 0:
                return False
        return True

bf = BloomFilter(5000, 7)
bf.add("machine learning")
print(bf.check("machine learning"))  # True
print(bf.check("deep learning"))     # False или True (фалшиво положително)
```

### Пример 2: Използване в уеб кеширане
Bloom филтърът се използва за бърза проверка дали URL е кеширан, преди да се направи скъпа заявка към сървъра.

## 6. Common Pitfalls
- **Недостатъчен размер на битовия масив** – води до висока честота на фалшиви положителни, което намалява ефективността.
- **Използване на неподходящи хеш функции** – ако хеш функциите не са независими или равномерно разпределени, се увеличава колизиите.
- **Опит за изтриване на елементи** – стандартният Bloom филтър не поддържа премахване, което може да доведе до грешки.
- **Пренебрегване на компромиса между памет и точност** – неправилното калибриране на параметрите води до неоптимални резултати.
- **Използване при критични системи без допълнителна проверка** – фалшивите положителни могат да причинят проблеми, ако не се управляват правилно.

## 7. Short Retrieval Quiz
1. Какво представлява Bloom филтърът и каква е основната му цел?  
2. Защо Bloom филтърът може да върне фалшиво положителен, но не и фалшиво отрицателен резултат?  
3. Каква е ролята на хеш функциите в Bloom филтъра?  
4. Как се изчислява вероятността за фалшиво положителен резултат?  
5. Какви са ограниченията при премахване на елементи от Bloom филтър?  
6. В какви ситуации Bloom филтърът е особено полезен?  
7. Какви са последиците от използване на твърде малък битов масив?

## 8. Quick Recap
- Bloom филтрите са вероятностни структури за проверка на принадлежност с компромис между памет и точност.  
- Те използват няколко хеш функции, за да зададат позиции в битов масив.  
- Връщат винаги правилен отговор при отрицателна проверка, но могат да върнат фалшиво положителен резултат.  
- Размерът на битовия масив и броят на хеш функциите влияят на точността и ефективността.  
- Не поддържат директно изтриване на елементи.  
- Използват се широко в системи, където бързината и ресурсната ефективност са критични.  
- Правилната настройка и избор на параметри е ключова за успешната им употреба.

## 9. Spaced Review Plan

| Време след учене | Промпт за преговор                                      |
|------------------|--------------------------------------------------------|
| 1 ден            | Обяснете принципа на работа на Bloom филтъра с пример. |
| 3 дни            | Как се изчислява false positive rate и защо е важен?   |
| 1 седмица        | Опишете компромисите при избор на параметри.           |
| 1 месец          | Приложете Bloom филтър в малък проект и анализирайте резултатите. |