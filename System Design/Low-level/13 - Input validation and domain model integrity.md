# 13 - Input validation and domain model integrity

## 1. Activate Prior Knowledge

- Какви са потенциалните рискове, ако в една AI система или уеб приложение не се валидират входните данни?
- Можете ли да си спомните случай, в който неправилно обработени входни данни са довели до грешки или уязвимости в софтуер?
- Какво според вас означава „интегритет на домейн модела“ и защо е важен при сложни системи?

## 2. Overview

Input validation и domain model integrity са фундаментални принципи в софтуерното инженерство, които гарантират, че данните, влизащи в системата, са коректни, безопасни и съответстват на очакванията на бизнес логиката. Input validation се фокусира върху проверката на всички външни (и често вътрешни) входове, за да се предотвратят грешки, атаки или невалидни състояния.

Domain model integrity се отнася до поддържането на вътрешната консистентност на бизнес обектите и логиката. Това означава, че данните в системата винаги отговарят на дефинираните правила и ограничения на домейна, независимо от източника им.

В контекста на AI системи или сложни уеб приложения, правилната валидация и поддържането на интегритет са критични за сигурността, надеждността и предвидимостта на поведението. Липсата им може да доведе до уязвимости като SQL injection, логически грешки или дори сривове на системата.

## 3. Key Concepts

- Input validation – Процесът на проверка дали входните данни отговарят на очаквания формат, тип и ограничения. Може да се сравни с охрана на входа, която допуска само правилно облечени гости.
- Domain model – Абстракция на реалния бизнес, представена чрез обекти, класове и връзки между тях. Мислете за него като за карта на бизнес логиката.
- Integrity constraints – Ограничения, които гарантират, че данните в домейн модела са винаги валидни (например уникалност, задължителни полета, референтна цялост).
- Whitelisting vs. Blacklisting – Два подхода за валидация: разрешаване само на определени стойности (whitelisting) или забраняване на опасни (blacklisting).
- Injection attacks – Тип атаки, при които злонамерени входни данни се използват за манипулиране на заявки или поведение на системата.
- Fail fast – Принцип, според който системата трябва да открива и сигнализира за невалидни входове възможно най-рано.

## 4. Step-by-step Learning Path

1. **Разберете нуждата от input validation**  
   - Фокус: Защо е важно да валидираме входа?  
   - Практическа задача: Намерете пример за уязвимост, причинена от липса на валидация (например SQL injection).  
   - Retrieval: Какви са последствията от липса на валидация? Какви типове атаки познавате?

2. **Изучете техники за валидация**  
   - Фокус: Разлика между client-side и server-side validation; whitelisting vs. blacklisting.  
   - Практическа задача: Напишете функция за валидация на имейл адрес.  
   - Retrieval: Кога трябва да използваме whitelisting? Какво е предимството на server-side validation?

3. **Запознайте се с домейн модела и неговите ограничения**  
   - Фокус: Как се дефинират бизнес правила и ограничения в модела?  
   - Практическа задача: Създайте клас User с ограничения за валидност на username и age.  
   - Retrieval: Какво е integrity constraint? Дайте пример.

4. **Интегрирайте валидация и проверки за интегритет**  
   - Фокус: Къде в архитектурата се поставят различните проверки?  
   - Практическа задача: Добавете валидация в слой на приложението (например във web controller и в домейн модела).  
   - Retrieval: Как се различават валидациите на входа и тези в домейн слоя?

5. **Тествайте и анализирайте поведението при невалидни входове**  
   - Фокус: Как системата реагира на невалидни данни?  
   - Практическа задача: Напишете тестове за гранични случаи и невалидни входове.  
   - Retrieval: Какво означава fail fast? Защо е важно?

## 5. Examples

### Пример 1: Input validation във web форма (Python Flask)

```python
from flask import request, abort

def validate_email(email):
    import re
    pattern = r'^[\w\.-]+@[\w\.-]+\.\w+$'
    return re.match(pattern, email)

@app.route('/register', methods=['POST'])
def register():
    email = request.form['email']
    if not validate_email(email):
        abort(400, "Invalid email address")
    # Продължаваме с регистрацията
```

### Пример 2: Domain model integrity в клас (Java)

```java
public class User {
    private String username;
    private int age;

    public User(String username, int age) {
        if (username == null || username.length() < 3) {
            throw new IllegalArgumentException("Username too short");
        }
        if (age < 18) {
            throw new IllegalArgumentException("User must be at least 18");
        }
        this.username = username;
        this.age = age;
    }
}
```

### Пример 3: SQL Injection при липса на валидация

```python
# Опасен код!
username = input("Username: ")
query = f"SELECT * FROM users WHERE username = '{username}'"
cursor.execute(query)
# Ако username = ' OR 1=1 -- , ще върне всички потребители!
```

## 6. Common Pitfalls

- Прекалено разчитане на client-side validation – Клиентът може да бъде манипулиран; винаги валидирайте и на сървъра.
- Използване на blacklisting вместо whitelisting – По-лесно е да пропуснете опасна стойност; whitelisting е по-сигурен подход.
- Липса на валидация при вътрешни API или batch процеси – Дори вътрешните източници могат да генерират невалидни данни.
- Пренебрегване на гранични случаи – Например, позволяване на празни стойности или твърде дълги входове.
- Слаба обработка на грешки – Неясни или неинформативни съобщения затрудняват откриването на проблеми.

## 7. Short Retrieval Quiz

1. Какво е основната цел на input validation?
2. Каква е разликата между whitelisting и blacklisting?
3. Какво означава domain model integrity?
4. Защо е важно да валидираме данни и на сървъра, а не само на клиента?
5. Дайте пример за integrity constraint.
6. Какво е injection attack и как може да бъде предотвратен?
7. Какво означава fail fast и защо е полезно?

## 8. Quick Recap

- Input validation предотвратява въвеждането на невалидни или опасни данни в системата.
- Domain model integrity гарантира, че бизнес логиката и данните остават коректни и последователни.
- Whitelisting е по-сигурен подход от blacklisting при валидация.
- Валидацията трябва да се извършва както на клиента, така и на сървъра.
- Integrity constraints са бизнес правила, които се прилагат в модела.
- Fail fast принципът помага за ранно откриване на проблеми.
- Пренебрегването на тези принципи води до уязвимости и логически грешки.

## 9. Spaced Review Plan

| Кога      | Преговори/Въпроси                                                                 |
|-----------|-----------------------------------------------------------------------------------|
| 1 ден     | Опишете разликата между input validation и domain model integrity.                 |
| 3 дни     | Дайте пример за SQL injection и как се предотвратява чрез валидация.              |
| 1 седмица | Обяснете защо whitelisting е по-добър подход от blacklisting.                     |
| 1 месец   | Избройте типични грешки при имплементация на валидация и как да ги избегнете.     |